
global _init = false
global fieldMap = null
global arsenal = null
global player = null
global strategy = null
global DEBUG_SCENARIO_TRACE = false  // Enable for score breakdown logging

include('game_entity.lk')
include('field_map_tactical.lk')
include('item.lk')
include('item_roles.lk')
include('game_context.lk')

include('operation_tracker.lk')
include('debug_config.lk')
include('monte_carlo_sim.lk')
include('kill_planning.lk')
include('cooldown_tracker.lk')  // Must be included before scenario_generator to define POISON_PHASE globals
include('enemy_predictor.lk')
include('reachable_graph.lk')
include('performance_infra.lk')
include('cache_manager.lk')
include('tactical_awareness.lk')
include('weight_profiles.lk')
include('strategic_depth.lk')
include('boss_context.lk')

include('strategy/action.lk')
include('bulb_ai.lk')

include('scenario_generator.lk')
include('scenario_simulator.lk')
include('scenario_scorer.lk')
include('scenario_quick_scorer.lk')
include('scenario_mutation.lk')

include('strategy/base_strategy.lk')
include('strategy/unified_strategy.lk')

if (!_init) {
    init()
    _init = true
}

main()

function init() {
    initializeItemRoles()
    player = Player(getCell())
    arsenal = new Arsenal();
    fieldMap = new FieldMap();
    initGameContext(player, arsenal, fieldMap)

    if (detectBossFight()) {
        initBossContext()
    }

    // ALWAYS use UnifiedStrategy
    var buildType = detectBuildType(player)
    var weights = getWeightsForBuild(buildType)
    if (_isBossFight && _bossPhase == "PUZZLE") {
        weights = BOSS_PUZZLE_WEIGHTS
    }

    strategy = new UnifiedStrategy(weights, player, null, arsenal, fieldMap)
    strategy.resetTurnContext()
    strategy.turnOneBuffs()
}

function resetTurnState() {
    // Reset all per-turn global state to prevent stale data leaks
    clearCaches()
    clearPerformanceInfra()
    __operation_log = []
    __operation_totals = []
    __debug_operation = 0
}

function main() {
    // Reset per-turn state EVERY turn (not just turn 1)
    resetTurnState()

    if (getTurn() == 1) {
        // Phase 1: Initialize adjacency map (one-time setup)
        initializeAdjacency()

        // Phase 3: Initialize cooldown tracker
        initializeCooldownTracker()
    }

    player.updateEntity()
    fieldMap.updateMapEntities()

    // Update boss context every turn
    if (_isBossFight) updateBossContext()

    // Debug: say() only works from included files, so call helper
    if (_isBossFight) bossDiag(getCell())

    // PUZZLE phase: direct crystal interaction — skip ALL combat setup.
    // Must run BEFORE expensive init (buildReachableGraph, caches, threat maps)
    // to avoid exhausting the ops budget before reaching puzzle logic.
    if (_isBossFight && _bossPhase == "PUZZLE") {
        if (executePuzzleTurn()) return
    }

    // Target selection: boss-aware override
    var target = null
    if (_isBossFight && _bossPhase == "PUZZLE") {
        target = getBossPuzzleTarget(fieldMap)
    } else if (_isBossFight && _bossPhase == "COMBAT") {
        target = selectCombatTarget(fieldMap)
    }
    if (target == null) {
        target = fieldMap.selectOptimalTarget(['prioritizeLowest': "hp", 'bonusForDebuffed': true])
    }
    if (target == null) target = fieldMap.getClosestEnemy()

    // Update GameContext with current turn state
    updateGameContext(player, target, fieldMap)

    // Phase 3: Cooldown tracking & kill planning
    if (target != null) {
        var cooldownTracker = new CooldownTracker(target)
        var enemies = getAliveEnemies()
        for (var enemyId in enemies) {
            cooldownTracker.updateCooldowns(enemyId)
        }

        var killPlanner = new KillPlanner(arsenal, player, target)
        var killPlan = killPlanner.updateGlobalKillPlan()
        if (killPlan != null && mapContainsKey(killPlan, 'active') && killPlan['active']) {
        }
    }

    // Phase 1: Build reachable graph (replaces redundant pathfinding)
    buildReachableGraph(player._cellPos, player._currMp, player, target, arsenal)

    startOp()
    initializeCaches(player, target, arsenal)
    stopOp("Initialize all caches")

    fieldMap.buildEnemyThreatMap()

    var targetHitCell = null

    if (target != null && strategy.shouldBuildDamageMap()) {
        fieldMap.buildHitMap(target._cellPos)
        targetHitCell = fieldMap.getBestWeaponOrChipCell();
    }

    // Ops hard stop: prevent timeout by checking budget before expensive work
    if (getOperations() > 13000000) {
        debugCritical("[OPS-HARDSTOP] Operations at " + getOperations() + " — skipping scenario engine, using fallback")
        // Emergency: just move toward enemy and attack with best weapon
        if (target != null) {
            moveToward(target._id)
            var bestWeapon = arsenal.getHighestDamageWeapon()
            if (bestWeapon != null) {
                setWeapon(bestWeapon)
                useWeaponOnCell(target._cellPos)
            }
        }
        return
    }

    // Boss weight hot-swap per phase
    if (_isBossFight) {
        strategy._weights = (_bossPhase == "PUZZLE") ? BOSS_PUZZLE_WEIGHTS : BOSS_COMBAT_WEIGHTS
    }

    // All strategies use unified scenario-based execution
    strategy.createAndExecuteScenario(target, targetHitCell)
}
