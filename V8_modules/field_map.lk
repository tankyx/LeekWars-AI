/** ExportÃ© le 10/1/2025, 4:37:42 PM **/

/** 8.0/V8/field_map.lk **/

include('game_entity.lk')

class Cell {
    _id
    _isObstacle = false
    _entityID = -1
    _weaponDamage = 0
    _chipDamage = 0
    _totalDamage = 0
    _bestType = -1
    _hasLOS = false
    _highestDamageWeapon = -1
    _highestDamageChip = -1

    constructor(id, isObstacle, entityID, weaponDamage, chipDamage, hasLOS, highestDamageWeapon, highestDamageChip) {
        this._id = id
        this._isObstacle = isObstacle
        this._entityID = entityID
        this._weaponDamage = weaponDamage
        this._chipDamage = chipDamage
        this._hasLOS = hasLOS
        this._highestDamageWeapon = highestDamageWeapon
        this._highestDamageChip = highestDamageChip
        this._totalDamage = weaponDamage + chipDamage
        if (weaponDamage >= chipDamage && weaponDamage > 0) this._bestType = 0
        else if (chipDamage > weaponDamage) this._bestType = 1
    }
}

class Color {
    _r = 0
    _g = 0
    _b = 0

    constructor(r, g, b) {
        this._r = r
        this._g = g
        this._b = b
    }

    getIntColor() {
        return getColor(this._r, this._g, this._b)
    }
}

class FieldMap {
    cells = [:]
    damageMap = [:]
    entities = [:]
    playerEntity = null

    wColors = [:]
    cColors = [:]

    private static x_offset = 18
    private static y_offset = 17
    private static up_right_offset = 18 - 17
    private static down_right_offset = 18 + 17
    private static down_left_offset = -1 * (18 - 17)
    private static up_left_offset = -1 * (18 + 17)
    private static base_cell = 308
    private static board_cell_count = 613

    constructor() {
        var playerID = getEntity()

        var k = 1;
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            mapPut(this.wColors, wid, new Color((k * 50) % 255, (k * 80) % 255, (k * 110) % 255))
            k++;
        }

        // Assign colors for chips (different palette shift)
        var kc = 1;
        for (var cid in mapKeys(arsenal.playerEquippedChips)) {
            var cObj = arsenal.playerEquippedChips[cid]
            mapPut(this.cColors, cid, new Color((kc * 70) % 255, (kc * 40) % 255, (kc * 95) % 255))
            kc++
        }

    for (var i = 0; i < FieldMap.board_cell_count; i++) {
            var isObs = isObstacle(i)
            var entID = -1

            if (isEntity(i)) {
                entID = getEntityOnCell(i)

                if (entID == playerID && isAlly(entID)) {
                    mapPut(this.entities, entID, new Player(i))
                }
                else {
                    mapPut(this.entities, entID, new Enemy(i))
                }
            }

            mapPut(this.cells, i, new Cell(i, isObs, entID, 0, 0, false, -1, -1))
        }
    }

    updateMapEntities() {
        for (var entity in this.entities) {
            if (entity != null) {
                entity.updateEntity()
            }
        }
    }

    isDamageItem(item) {
        return mapContainsKey(item._effects, EFFECT_DAMAGE) || mapContainsKey(item._effects, EFFECT_POISON)
    }

    buildSingleItemHitMap(localMap, oppCell, item, isWeapon) {
        if (!this.isDamageItem(item)) {
            return localMap
        }
        var minR = item._minRange
        var maxR = item._maxRange
        var launchType = item._launchType
        var aoeType = item._aoeType
        var weapon = isWeapon ? item : null
        var chip = isWeapon ? null : item

        if (launchType == LAUNCH_TYPE_CIRCLE) {
            return getCircleHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        } else if (launchType == LAUNCH_TYPE_STAR) {
            return getStarHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        } else if (launchType == LAUNCH_TYPE_LINE) {
            return getLineHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        } else if (launchType == LAUNCH_TYPE_DIAGONAL) {
            return getDiagonalHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        }
        return localMap
    }

    markLocalHits(localMap, isWeapon) {
        if (isWeapon) {
            for (var c in localMap) {
                if (c._highestDamageWeapon != -1 && mapContainsKey(this.wColors, c._highestDamageWeapon._id)) {
                    mark(c._id, this.wColors[c._highestDamageWeapon._id].getIntColor(), 2)
                    markText(c._id, floor(c._totalDamage), new Color(255, 255, 255).getIntColor(), 2)
                }
            }
        } else {
            for (var cc in localMap) {
                if (cc._highestDamageChip != -1 && mapContainsKey(this.cColors, cc._highestDamageChip._id)) {
                    mark(cc._id, this.cColors[cc._highestDamageChip._id].getIntColor(), 1)
                    markText(cc._id, floor(cc._totalDamage), new Color(200, 255, 200).getIntColor(), 1)
                }
            }
        }
    }

    buildHitMap(oppCell) {
        clearMarks()
        mapClear(this.damageMap)

        // Weapons
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            var localWeaponMap = [:]
            localWeaponMap = this.buildSingleItemHitMap(localWeaponMap, oppCell, wObj, true)
            this.damageMap = mapMerge(this.damageMap, localWeaponMap)
            this.markLocalHits(localWeaponMap, true)
        }

        // Chips
        for (var cid in mapKeys(arsenal.playerEquippedChips)) {
            var chipObj = arsenal.playerEquippedChips[cid]
            var localChipMap = [:]
            localChipMap = this.buildSingleItemHitMap(localChipMap, oppCell, chipObj, false)
            this.damageMap = mapMerge(this.damageMap, localChipMap)
            this.markLocalHits(localChipMap, false)
        }
        return this.damageMap
    }

    getCellID(x, y) {
        return FieldMap.base_cell + FieldMap.x_offset * x + FieldMap.y_offset * y
    }

    getPlayerPos() {
        return player._cellPos
    }

    getAlliesSubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Player) && key != getEntity()
        })
    }

    getEnemySubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Enemy)
        })
    }

    getClosestEnemy() {
        var playerPos = player._cellPos
        var closestEnemy = null
        var closestDist = 999

        var enemies = this.getEnemySubMap()
        for (var e in enemies) {
            var dist = getCellDistance(playerPos, e._cellPos)

            if (dist < closestDist) {
                closestDist = dist
                closestEnemy = e
            }
        }
        return closestEnemy
    }

    getClosestHighestDmgHitCell() {
        var playerPos = player._cellPos
        var closestCell = -1
        var closestDist = 999
        var highestDmg = -1

        for (var c in this.damageMap) {
            var dist = getPathLength(playerPos, c._id)

            // No path to cell
            if (dist == null) {
                continue
            }

            if (c._weaponDamage > highestDmg) {
                highestDmg = c._weaponDamage
                closestDist = dist
                closestCell = c
            }
            else if (c._weaponDamage == highestDmg && dist < closestDist) {
                closestDist = dist
                closestCell = c
            }
        }

        // if cell is unreachable this turn, check if we can reach another cell
        if (closestCell != -1 && closestDist > player._currMp) {
            var potentialCell = this.getClosestHitCell()
            var dist = getPathLength(playerPos, potentialCell._id)


            if (potentialCell != -1 && dist <= player._currMp) {
                closestCell = potentialCell
            }
        }

        return closestCell
    }

    getClosestHitCellForWeapon(weapon) {
        var playerPos = player._cellPos
        var closestCell = -1
        var closestDist = 999

        for (var c in this.damageMap) {
            if (c._highestDamageWeapon == -1) {
                continue
            }

            if (c._highestDamageWeapon._id != weapon._id) {
                continue
            }

            var dist = getPathLength(playerPos, c._id)

            if (dist == null) {
                debug("No path to cell " + c._id)
                continue
            }

            if (dist < closestDist && dist <= player._currMp) {
                closestDist = dist
                closestCell = c
            }
        }
        return closestCell
    }

    getClosestHitCell() {
        var playerPos = this.getPlayerPos()
        var closestCell = -1
        var closestDist = 999

        for (var c in this.damageMap) {
            var dist = getPathLength(playerPos, c._id)

            if (dist == null) {
                debug("No path to cell " + c._id)
                continue
            }

            if (dist < closestDist) {
                closestDist = dist
                closestCell = c
            }
        }
        return closestCell
    }

    getBestWeaponOrChipCell() {
        var best = -1
        var bestDmg = -1
        for (var c in this.damageMap) {
            if (c._totalDamage > bestDmg) {
                bestDmg = c._totalDamage
                best = c
            }
        }
        return best
    }

    getLineHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var curCell = cell
        for (var dir = 0; dir < 4; dir++) {
            for (var dist = minR; dist <= maxR; dist++) {
                if (dir == 0) {
                    curCell = cell - y_offset * dist
                } else if (dir == 1) {
                    curCell = cell + x_offset * dist
                } else if (dir == 2) {
                    curCell = cell + y_offset * dist
                } else if (dir == 3) {
                    curCell = cell - x_offset * dist
                }
                var _hasLOS = lineOfSight(cell, curCell)
                        if (_hasLOS && curCell >= 0 && curCell < FieldMap.board_cell_count) {
                    updateHitCells(hitCells, curCell, weapon, chip)
                }
            }
        }
        return hitCells
    }

    getDiagonalHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var curCell = cell
        for (var dir = 0; dir < 4; dir++) {
            for (var dist = minR; dist <= maxR; dist++) {
                if (dir == 0) {
                    curCell = cell + up_right_offset * dist
                } else if (dir == 1) {
                    curCell = cell + down_right_offset * dist
                } else if (dir == 2) {
                    curCell = cell + down_left_offset * dist
                } else if (dir == 3) {
                    curCell = cell + up_left_offset * dist
                }
                var _hasLOS = lineOfSight(cell, curCell)
                        if (_hasLOS && curCell >= 0 && curCell < FieldMap.board_cell_count) {
                    updateHitCells(hitCells, curCell, weapon, chip) 
                }
            }
        }
        return hitCells
    }

    getStarHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var lineMap = [:]
        lineMap = getLineHits(lineMap, cell, minR, maxR, aoeType, weapon, chip)
        var diagMap = [:]
        diagMap = getDiagonalHits(diagMap, cell, minR, maxR, aoeType, weapon, chip)
        var merged = mapMerge(lineMap, diagMap)
        return mapMerge(hitCells, merged)
    }

    getCircleHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        for (var dx = -maxR; dx <= maxR; dx++) {
            for (var dy = -maxR; dy <= maxR; dy++) {
                var dist = abs(dx) + abs(dy)
                if (dist >= minR && dist <= maxR) {
                    var curCell = cell + FieldMap.x_offset * dx + FieldMap.y_offset * dy
                    var _hasLOS = lineOfSight(cell, curCell)
                            if (_hasLOS && curCell >= 0 && curCell < FieldMap.board_cell_count) {
                        updateHitCells(hitCells, curCell, weapon, chip)
                    }
                }
            }
        }
        return hitCells
    }

    updateHitCells(hitCells, curCell, weapon=null, chip=null) {
        if (weapon == null && chip == null) {
            return hitCells
        }

        if (weapon != null) {
            var scaledDamage = arsenal.getScaledDamage(player._strength, player._magic, player._wisdom, weapon._id)
            scaledDamage *= weapon._maxUse // assume we can hit with all uses
            if (mapContainsKey(hitCells, curCell)) {
                if (hitCells[curCell]._weaponDamage < scaledDamage) {
                    hitCells[curCell]._weaponDamage = scaledDamage
                    hitCells[curCell]._highestDamageWeapon = weapon
                }
            }
            else {
                mapPut(hitCells, curCell, new Cell(curCell, false, getEntityOnCell(curCell), scaledDamage, 0, true, weapon, -1))
            }
        }
        else if (chip != null) {
            var scaledDamage = arsenal.getScaledDamage(player._strength, player._magic, player._wisdom, chip._id)
            scaledDamage *= chip._maxUse // assume we can hit with all uses
            if (mapContainsKey(hitCells, curCell)) {
                if (hitCells[curCell]._chipDamage < scaledDamage) {
                    hitCells[curCell]._chipDamage = scaledDamage
                    hitCells[curCell]._highestDamageChip = chip
                }
            }
            else {
                // Store the chip object (not just its id) so later accesses to _highestDamageChip._id are valid
                mapPut(hitCells, curCell, new Cell(curCell, false, getEntityOnCell(curCell), 0, scaledDamage, true, -1, chip))
            }
        }
        // Recompute aggregate
        if (mapContainsKey(hitCells, curCell)) {
            var cellRef = hitCells[curCell]
            cellRef._totalDamage = cellRef._weaponDamage + cellRef._chipDamage
            if (cellRef._weaponDamage >= cellRef._chipDamage && cellRef._weaponDamage > 0) cellRef._bestType = 0
            else if (cellRef._chipDamage > cellRef._weaponDamage) cellRef._bestType = 1
        }
        return hitCells
    }
}