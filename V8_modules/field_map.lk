/** Export√© le 10/1/2025, 2:35:16 PM **/

/** 8.0/V8/field_map.lk **/

include('game_entity.lk')

class Cell {
    _id
    _isObstacle = false
    _entityID = -1
    _weaponDamage = 0
    _chipDamage = 0
    _hasLOS = false
    _highestDamageWeapon = -1
    _highestDamageChip = -1

    constructor(id, isObstacle, entityID, weaponDamage, chipDamage, hasLOS, highestDamageWeapon, highestDamageChip) {
        this._id = id
        this._isObstacle = isObstacle
        this._entityID = entityID
        this._weaponDamage = weaponDamage
        this._chipDamage = chipDamage
        this._hasLOS = hasLOS
        this._highestDamageWeapon = highestDamageWeapon
        this._highestDamageChip = highestDamageChip
    }
}

class Color {
    _r = 0
    _g = 0
    _b = 0

    constructor(r, g, b) {
        this._r = r
        this._g = g
        this._b = b
    }

    getIntColor() {
        return getColor(this._r, this._g, this._b)
    }
}

class FieldMap {
    cells = [:]
    damageMap = [:]
    entities = [:]
    playerEntity = null

    wColors = [:]

    private static x_offset = 18
    private static y_offset = 17
    private static up_right_offset = 18 - 17
    private static down_right_offset = 18 + 17
    private static down_left_offset = -1 * (18 - 17)
    private static up_left_offset = -1 * (18 + 17)
    private static base_cell = 308

    constructor() {
        var playerID = getEntity()

        var k = 1;
        for (var w in arsenal.playerEquippedWeapons) {
            mapPut(this.wColors, w._id, new Color((k * 50) % 255, (k * 80) % 255, (k * 110) % 255))
            k++;
        }

        for (var i = 0; i < 613; i++) {
            var isObs = isObstacle(i)
            var entID = -1

            if (isEntity(i)) {
                entID = getEntityOnCell(i)

                if (entID == playerID && isAlly(entID)) {
                    mapPut(this.entities, entID, new Player(i))
                }
                else {
                    mapPut(this.entities, entID, new Enemy(i))
                }
            }

            mapPut(this.cells, i, new Cell(i, isObs, entID, 0, 0, false, -1, -1))
        }
    }

    updateMapEntities() {
        for (var entity in this.entities) {
            entity.updateEntity()
        }
    }

    buildHitMap(oppCell) {
        var hitCells = [:]
        var i = 0
        
        clearMarks();
        mapClear(this.damageMap)

        for (var w in arsenal.playerEquippedWeapons) {
            var minR = w._minRange
            var maxR = w._maxRange
            var launchType = w._launchType
            var aoeType = w._aoeType

            if (launchType == LAUNCH_TYPE_CIRCLE) {
                hitCells = getCircleHits(hitCells, oppCell, minR, maxR, aoeType, w, null)
            }
            else if (launchType == LAUNCH_TYPE_STAR) {
                hitCells = getStarHits(hitCells, oppCell, minR, maxR, aoeType, w, null)
            }
            else if (launchType == LAUNCH_TYPE_LINE) {
                hitCells = getLineHits(hitCells, oppCell, minR, maxR, aoeType, w, null)
            }
            else if (launchType == LAUNCH_TYPE_DIAGONAL) {
                hitCells = getDiagonalHits(hitCells, oppCell, minR, maxR, aoeType, w, null)
            }
            else {
                continue
            }

            this.damageMap = mapMerge(this.damageMap, hitCells)
            
            for (var c in hitCells) {
                mark(c._id, this.wColors[c._highestDamageWeapon._id].getIntColor(), 2)
                markText(c._id, floor(c._weaponDamage), new Color(255, 255, 255).getIntColor(), 2)
            }
            
            i++
        }

        for (var c in arsenal.playerEquippedChips) {
            var minR = c._minRange
            var maxR = c._maxRange
            var launchType = c._launchType
            var aoeType = c._aoeType

            if (launchType == LAUNCH_TYPE_CIRCLE) {
                hitCells = getCircleHits(hitCells, oppCell, minR, maxR, aoeType, null, c)
            }
            else if (launchType == LAUNCH_TYPE_STAR) {
                hitCells = getStarHits(hitCells, oppCell, minR, maxR, aoeType, null, c)
            }
            else if (launchType == LAUNCH_TYPE_LINE) {
                hitCells = getLineHits(hitCells, oppCell, minR, maxR, aoeType, null, c)
            }
            else if (launchType == LAUNCH_TYPE_DIAGONAL) {
                hitCells = getDiagonalHits(hitCells, oppCell, minR, maxR, aoeType, null, c)
            }
            else {
                continue
            }

            this.damageMap = mapMerge(this.damageMap, hitCells)
        }
        return this.damageMap
    }

    getCellID(x, y) {
        return FieldMap.base_cell + FieldMap.x_offset * x + FieldMap.y_offset * y
    }

    getPlayerPos() {
        return player._cellPos
    }

    getAlliesSubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Player) && key != getEntity()
        })
    }

    getEnemySubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Enemy)
        })
    }

    getClosestEnemy() {
        var playerPos = player._cellPos
        var closestEnemy = null
        var closestDist = 999

        var enemies = this.getEnemySubMap()
        for (var e in enemies) {
            var dist = getCellDistance(playerPos, e._cellPos)

            if (dist < closestDist) {
                closestDist = dist
                closestEnemy = e
            }
        }
        return closestEnemy
    }

    getClosestHighestDmgHitCell() {
        var playerPos = player._cellPos
        var closestCell = -1
        var closestDist = 999
        var highestDmg = -1

        for (var c in this.damageMap) {
            var dist = getPathLength(playerPos, c._id)

            // No path to cell
            if (dist == null) {
                continue
            }

            if (c._weaponDamage > highestDmg) {
                highestDmg = c._weaponDamage
                closestDist = dist
                closestCell = c
            }
            else if (c._weaponDamage == highestDmg && dist < closestDist) {
                closestDist = dist
                closestCell = c
            }
        }

        // if cell is unreachable this turn, check if we can reach another cell
        if (closestCell != -1 && closestDist > player._currMp) {
            var potentialCell = this.getClosestHitCell()
            var dist = getPathLength(playerPos, potentialCell._id)


            if (potentialCell != -1 && dist <= player._currMp) {
                closestCell = potentialCell
            }
        }

        return closestCell
    }

    getClosestHitCellForWeapon(weapon) {
        var playerPos = player._cellPos
        var closestCell = -1
        var closestDist = 999

        for (var c in this.damageMap) {
            if (c._highestDamageWeapon == -1) {
                continue
            }
            
            if (c._highestDamageWeapon._id != weapon._id) {
                continue
            }

            var dist = getPathLength(playerPos, c._id)

            if (dist == null) {
                debug("No path to cell " + c._id)
                continue
            }

            if (dist < closestDist && dist <= player._currMp) {
                closestDist = dist
                closestCell = c
            }
        }
        return closestCell
    }

    getClosestHitCell() {
        var playerPos = this.getPlayerPos()
        var closestCell = -1
        var closestDist = 999

        for (var c in this.damageMap) {
            var dist = getPathLength(playerPos, c._id)

            if (dist == null) {
                debug("No path to cell " + c._id)
                continue
            }

            if (dist < closestDist) {
                closestDist = dist
                closestCell = c
            }
        }
        return closestCell
    }

    getLineHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var curCell = cell
        for (var dir = 0; dir < 4; dir++) {
            for (var dist = minR; dist <= maxR; dist++) {
                if (dir == 0) {
                    curCell = cell - y_offset * dist
                }
                else if (dir == 1) {
                    curCell = cell + x_offset * dist
                }
                else if (dir == 2) {
                    curCell = cell + y_offset * dist
                }
                else if (dir == 3) {
                    curCell = cell - x_offset * dist
                }
            }
            var _hasLOS = lineOfSight(cell, curCell)
            if (_hasLOS && curCell >= 0 && curCell < 613) {
                updateHitCells(hitCells, curCell, weapon, chip)
            }
        }
        return hitCells
    }

    getDiagonalHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var curCell = cell
        for (var dir = 0; dir < 4; dir++) {
            for (var dist = minR; dist <= maxR; dist++) {
                if (dir == 0) {
                    curCell = cell + up_right_offset * dist
                }
                else if (dir == 1) {
                    curCell = cell + down_right_offset * dist
                }
                else if (dir == 2) {
                    curCell = cell + down_left_offset * dist
                }
                else if (dir == 3) {
                    curCell = cell + up_left_offset * dist
                }
            }
            var _hasLOS = lineOfSight(cell, curCell)
            if (_hasLOS && curCell >= 0 && curCell < 613) {
                updateHitCells(hitCells, curCell, weapon, chip) 
            }
        }
        return hitCells
    }

    getStarHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        hitCells = mapMerge(hitCells, getLineHits(hitCells, cell, minR, maxR, aoeType, weapon))
        hitCells = mapMerge(hitCells, getDiagonalHits(hitCells, cell, minR, maxR, aoeType, weapon))
        return hitCells
    }

    getCircleHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        for (var dx = -maxR; dx <= maxR; dx++) {
            for (var dy = -maxR; dy <= maxR; dy++) {
                var dist = abs(dx) + abs(dy)
                if (dist >= minR && dist <= maxR) {
                    var curCell = cell + FieldMap.x_offset * dx + FieldMap.y_offset * dy
                    var _hasLOS = lineOfSight(cell, curCell)
                    if (_hasLOS && curCell >= 0 && curCell < 613) {
                        updateHitCells(hitCells, curCell, weapon, chip)
                    }
                }
            }
        }
        return hitCells
    }

    updateHitCells(hitCells, curCell, weapon=null, chip=null) {
        if (weapon == null && chip == null) {
            return hitCells
        }

        if (weapon != null) {
            var scaledDamage = arsenal.getScaledDamage(player._strength, player._magic, player._wisdom, weapon._id)
            scaledDamage *= weapon._maxUse // assume we can hit with all uses
            if (mapContains(hitCells, curCell)) {
                if (hitCells[curCell]._weaponDamage < scaledDamage) {
                    hitCells[curCell]._weaponDamage = scaledDamage
                    hitCells[curCell]._highestDamageWeapon = weapon
                }
            }
            else {
                mapPut(hitCells, curCell, new Cell(curCell, false, getEntityOnCell(curCell), scaledDamage, 0, true, weapon, -1))
            }
        }
        else if (chip != null) {
            var scaledDamage = arsenal.getScaledDamage(player._strength, player._magic, player._wisdom, chip._id)
            scaledDamage *= chip._maxUse // assume we can hit with all uses
            if (mapContains(hitCells, curCell)) {
                if (hitCells[curCell]._chipDamage < scaledDamage) {
                    hitCells[curCell]._chipDamage = scaledDamage
                    hitCells[curCell]._highestDamageChip = chip
                }
            }
            else {
                mapPut(hitCells, curCell, new Cell(curCell, false, getEntityOnCell(curCell), 0, scaledDamage, true, -1, chip._id))
            }
        }

        return hitCells
    }
}