include('game_entity.lk')

class Cell {
    _id
    _isObstacle = false
    _entityID = -1
    _weaponDamage = 0
    _chipDamage = 0
    _totalDamage = 0
    _directDamage = 0 // immediate damage portion
    _dotDamage = 0 // cumulative DoT (poison) portion
    _bestType = -1
    _hasLOS = false
    _highestDamageWeapon = -1
    _highestDamageChip = -1
    _weaponsList = [] // all weapons that can fire from this cell
    _chipsList = []   // all chips that can fire from this cell

    constructor(id, isObstacle, entityID, weaponDamage, chipDamage, hasLOS, highestDamageWeapon, highestDamageChip) {
        this._id = id
        this._isObstacle = isObstacle
        this._entityID = entityID
        this._weaponDamage = weaponDamage
        this._chipDamage = chipDamage
        this._hasLOS = hasLOS
        this._highestDamageWeapon = highestDamageWeapon
        this._highestDamageChip = highestDamageChip
        this._totalDamage = weaponDamage + chipDamage
        if (weaponDamage >= chipDamage && weaponDamage > 0) this._bestType = 0
        else if (chipDamage > weaponDamage) this._bestType = 1
    }
}

class Color {
    _r = 0
    _g = 0
    _b = 0

    constructor(r, g, b) {
        this._r = r
        this._g = g
        this._b = b
    }

    getIntColor() {
        return getColor(this._r, this._g, this._b)
    }
}

class FieldMap {
    cells = [:]
    damageMap = [:]
    entities = [:]
    playerEntity = null

    wColors = [:]
    cColors = [:]

    // Per-turn cache for enemy accessible cells (to avoid recomputation across multiple HNS queries)
    _enemyAccessCache = [] // array of ['enemy': Enemy, 'cells': array]
    _enemyAccessCacheTurn = -1
    _enemyAccessCacheIds = [] // parallel list of enemy IDs for quick invalidation

    private static x_offset = 18
    private static y_offset = 17
    private static up_right_offset = 18 - 17
    private static down_right_offset = 18 + 17
    private static down_left_offset = -1 * (18 - 17)
    private static up_left_offset = -1 * (18 + 17)
    private static base_cell = 308
    private static board_cell_count = 613

    constructor() {
        var playerID = getEntity()

        var k = 1;
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            mapPut(this.wColors, wid, new Color((k * 50) % 255, (k * 80) % 255, (k * 110) % 255))
            k++;
        }

        // Assign colors for chips (different palette shift)
        var kc = 1;
        for (var cid in mapKeys(arsenal.playerEquippedChips)) {
            var cObj = arsenal.playerEquippedChips[cid]
            mapPut(this.cColors, cid, new Color((kc * 70) % 255, (kc * 40) % 255, (kc * 95) % 255))
            kc++
        }

    for (var i = 0; i < FieldMap.board_cell_count; i++) {
            var isObs = isObstacle(i)
            var entID = -1

            if (isEntity(i)) {
                entID = getEntityOnCell(i)

                // Check entity type (chest, mob, bulb, turret, leek)
                var entityType = getType(entID)

                if (entityType == ENTITY_CHEST) {
                    mapPut(this.entities, entID, new Chest(i))
                    debug("[ENTITY] Chest detected at cell " + i + " (ID: " + entID + ")")
                }
                else if (isAlly(entID)) {
                    if (entID == playerID) {
                        mapPut(this.entities, entID, new Player(i))
                    } else {
                        mapPut(this.entities, entID, new Player(i)) // Ally teammate (treat as Player for now)
                    }
                }
                else {
                    // Check if this is a boss fight entity (Grail or Crystal) by name
                    var entityName = getName(entID)

                    // Grail: exact name 'graal'
                    if (entityName == "graal") {
                        mapPut(this.entities, entID, new Enemy(i))
                        debug("[ENTITY] Graal detected at cell " + i + " (ID: " + entID + ")")
                    }
                    // Crystals: exact names with color
                    else if (entityName == "red_crystal" || entityName == "green_crystal" || entityName == "blue_crystal" || entityName == "yellow_crystal") {
                        mapPut(this.entities, entID, new Enemy(i))
                        debug("[ENTITY] Crystal '" + entityName + "' detected at cell " + i + " (ID: " + entID + ")")
                    }
                    else {
                        mapPut(this.entities, entID, new Enemy(i))
                    }
                }
            }

            mapPut(this.cells, i, new Cell(i, isObs, entID, 0, 0, false, -1, -1))
        }
    }

    updateMapEntities() {
        // Rescan entire map for new entities (bulbs summoned mid-combat)
        for (var cellId = 0; cellId < 613; cellId++) {
            if (isEntity(cellId)) {
                var entID = getEntityOnCell(cellId)

                // If entity not already tracked, add it
                if (!mapContainsKey(this.entities, entID)) {
                    var entityType = getType(entID)

                    if (entityType == ENTITY_CHEST) {
                        mapPut(this.entities, entID, new Chest(cellId))
                        debug("[ENTITY-SCAN] New chest detected at cell " + cellId)
                    }
                    else if (isAlly(entID)) {
                        mapPut(this.entities, entID, new Player(cellId))
                        debug("[ENTITY-SCAN] New ally detected at cell " + cellId)
                    }
                    else {
                        mapPut(this.entities, entID, new Enemy(cellId))
                        debug("[ENTITY-SCAN] New enemy detected: " + getName(entID) + " (Type=" + entityType + ") at cell " + cellId)
                    }
                }
            }
        }

        // Update all tracked entities
        for (var entity in this.entities) {
            if (entity != null) {
                entity.updateEntity()
            }
        }
    }

    isDamageItem(item) {
        return mapContainsKey(item._effects, EFFECT_DAMAGE) || mapContainsKey(item._effects, EFFECT_POISON)
    }

    // Get all cells affected by AoE around a center cell
    // Returns array of cell IDs affected by the AoE pattern
    getAoEAffectedCells(centerCell, aoeType) {
        var affected = []

        // AREA_POINT - only the center cell
        if (aoeType == AREA_POINT) {
            push(affected, centerCell)
            return affected
        }

        // Always include center cell
        push(affected, centerCell)

        // AREA_CIRCLE_1, AREA_CIRCLE_2, AREA_CIRCLE_3
        if (aoeType == AREA_CIRCLE_1 || aoeType == AREA_CIRCLE_2 || aoeType == AREA_CIRCLE_3) {
            var radius = (aoeType == AREA_CIRCLE_1) ? 1 : ((aoeType == AREA_CIRCLE_2) ? 2 : 3)
            for (var dx = -radius; dx <= radius; dx++) {
                for (var dy = -radius; dy <= radius; dy++) {
                    var dist = abs(dx) + abs(dy)
                    if (dist > 0 && dist <= radius) {
                        var cellId = centerCell + FieldMap.x_offset * dx + FieldMap.y_offset * dy
                        if (cellId >= 0 && cellId < FieldMap.board_cell_count) {
                            push(affected, cellId)
                        }
                    }
                }
            }
        }
        // AREA_PLUS_1, AREA_PLUS_2, AREA_PLUS_3 (cross pattern)
        else if (aoeType == AREA_PLUS_1 || aoeType == AREA_PLUS_2 || aoeType == AREA_PLUS_3) {
            var radius = (aoeType == AREA_PLUS_1) ? 1 : ((aoeType == AREA_PLUS_2) ? 2 : 3)
            // Horizontal and vertical only
            for (var d = 1; d <= radius; d++) {
                var cells = [
                    centerCell + FieldMap.x_offset * d,  // right
                    centerCell - FieldMap.x_offset * d,  // left
                    centerCell + FieldMap.y_offset * d,  // down
                    centerCell - FieldMap.y_offset * d   // up
                ]
                for (var c in cells) {
                    if (c >= 0 && c < FieldMap.board_cell_count) push(affected, c)
                }
            }
        }
        // AREA_X_1, AREA_X_2, AREA_X_3 (diagonal X pattern)
        else if (aoeType == AREA_X_1 || aoeType == AREA_X_2 || aoeType == AREA_X_3) {
            var radius = (aoeType == AREA_X_1) ? 1 : ((aoeType == AREA_X_2) ? 2 : 3)
            // Diagonals only
            for (var d = 1; d <= radius; d++) {
                var cells = [
                    centerCell + FieldMap.up_right_offset * d,
                    centerCell + FieldMap.down_right_offset * d,
                    centerCell + FieldMap.down_left_offset * d,
                    centerCell + FieldMap.up_left_offset * d
                ]
                for (var c in cells) {
                    if (c >= 0 && c < FieldMap.board_cell_count) push(affected, c)
                }
            }
        }
        // AREA_SQUARE_1, AREA_SQUARE_2
        else if (aoeType == AREA_SQUARE_1 || aoeType == AREA_SQUARE_2) {
            var radius = (aoeType == AREA_SQUARE_1) ? 1 : 2
            for (var dx = -radius; dx <= radius; dx++) {
                for (var dy = -radius; dy <= radius; dy++) {
                    if (dx == 0 && dy == 0) continue // already added center
                    var cellId = centerCell + FieldMap.x_offset * dx + FieldMap.y_offset * dy
                    if (cellId >= 0 && cellId < FieldMap.board_cell_count) {
                        push(affected, cellId)
                    }
                }
            }
        }
        // AREA_LASER_LINE - handled differently (linear along shot path, not radial)
        // For now, just return center cell - laser AoE needs special handling in weapon usage
        else if (aoeType == AREA_LASER_LINE) {
            // Laser AoE affects cells along the line of fire, not radially around target
            // This requires knowing the shooting direction, so we'll handle it during actual shot
            // For damage calculation purposes, treat as single target
        }

        return affected
    }

    buildSingleItemHitMap(localMap, oppCell, item, isWeapon) {
        if (!this.isDamageItem(item)) {
            return localMap
        }
        var minR = item._minRange
        var maxR = item._maxRange
        var launchType = item._launchType
        var aoeType = item._aoeType
        var weapon = isWeapon ? item : null
        var chip = isWeapon ? null : item

        if (launchType == LAUNCH_TYPE_CIRCLE) {
            return this.getCircleHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        } else if (launchType == LAUNCH_TYPE_STAR) {
            return this.getStarHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        } else if (launchType == LAUNCH_TYPE_LINE) {
            return this.getLineHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        } else if (launchType == LAUNCH_TYPE_DIAGONAL) {
            return this.getDiagonalHits(localMap, oppCell, minR, maxR, aoeType, weapon, chip)
        }
        return localMap
    }

    markLocalHits(localMap, isWeapon) {
        if (isWeapon) {
            for (var c in localMap) {
                if (c._highestDamageWeapon != -1 && mapContainsKey(this.wColors, c._highestDamageWeapon._id)) {
                    // Weapons: keep colored cell (layer 2). Remove numeric damage text per new spec.
                    mark(c._id, this.wColors[c._highestDamageWeapon._id].getIntColor(), 2)
                }
            }
        } else {
            for (var cc in localMap) {
                if (cc._highestDamageChip != -1 && mapContainsKey(this.cColors, cc._highestDamageChip._id)) {
                    // Chips: no colored fill now; instead place code text: C_{first2letters} in darker tone (layer 1)
                    var chipId = cc._highestDamageChip._id
                    var chipName = getChipName(chipId)
                    var shortName = chipName
                    // Attempt to slice first 2 letters (LeekScript substring(begin, end) semantics assumed)
                    // Fallback: if substring fails (returns null) we keep full name.
                    var temp = substring(chipName, 0, 2)
                    if (temp != null) shortName = temp
                    // Build code
                    var code = "C_" + shortName
                    // Darker color derived from base chip color
                    var baseCol = this.cColors[chipId]
                    var dr = max(0, baseCol._r - 60)
                    var dg = max(0, baseCol._g - 60)
                    var db = max(0, baseCol._b - 60)
                    var darkInt = getColor(dr, dg, db)
                    markText(cc._id, code, darkInt, 1)
                }
            }
        }
    }

    buildHitMap(oppCell) {
        clearMarks()
        mapClear(this.damageMap)
    var playerPos = player._cellPos // keep for potential distance-based annotations (no pruning)

        // Weapons - integrate directly into global damageMap to retain combined lists
        this.integrateEquippedItemsIntoDamageMap(oppCell)
        // After integration, optionally mark (re-using existing damageMap entries)
        this.markLocalHits(this.damageMap, true)
        this.markLocalHits(this.damageMap, false)
        // Summary diagnostics: cells with chips vs weapon-only
        var chipCells = []
        var weaponOnlyCells = []
        for (var dmCell in this.damageMap) {
            if (count(dmCell._chipsList) > 0) push(chipCells, dmCell._id)
            else if (count(dmCell._weaponsList) > 0) push(weaponOnlyCells, dmCell._id)
        }
        debug("[HITMAP][SUMMARY] chipCells=" + chipCells + " weaponOnlyCellsSample=" + (count(weaponOnlyCells) > 0 ? weaponOnlyCells : []))
        return this.damageMap
    }

    // Helper: integrate all equipped weapons and chips maintaining original debug output ordering
    integrateEquippedItemsIntoDamageMap(oppCell) {
        // Weapons
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            var localWeaponMap = [:]
            localWeaponMap = this.buildSingleItemHitMap(localWeaponMap, oppCell, wObj, true)
            var listIDs = []
            for (var cellRef in localWeaponMap) {
                if (cellRef._isObstacle) continue
                // cellRef._id = shooting position, oppCell = target (AoE center)
                this.updateHitCells(this.damageMap, cellRef._id, wObj, null, oppCell)
                push(listIDs, cellRef._id)
            }
            debug("[HITMAP][WEAPON] " + getWeaponName(wObj._id) + " shooterCells=" + listIDs)
        }
        // Chips
        for (var cid in mapKeys(arsenal.playerEquippedChips)) {
            var chipObj = arsenal.playerEquippedChips[cid]
            var localChipMap = [:]
            localChipMap = this.buildSingleItemHitMap(localChipMap, oppCell, chipObj, false)
            var listCID = []
            for (var cellRef2 in localChipMap) {
                if (cellRef2._isObstacle) continue
                var bdDbg = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, chipObj._id) // retained (was previously assigned)
                // cellRef2._id = shooting position, oppCell = target (AoE center)
                this.updateHitCells(this.damageMap, cellRef2._id, null, chipObj, oppCell)
                push(listCID, cellRef2._id)
            }
            debug("[HITMAP][CHIP] " + getChipName(chipObj._id) + " shooterCells=" + listCID)
        }
    }

    getCellID(x, y) {
        return FieldMap.base_cell + FieldMap.x_offset * x + FieldMap.y_offset * y
    }

    getPlayerPos() {
        return player._cellPos
    }

    getAlliesSubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Player) && key != getEntity()
        })
    }

    getEnemySubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Enemy)
        })
    }

    getChestSubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Chest)
        })
    }

    getClosestEnemy() {
        var playerPos = player._cellPos
        var closestEnemy = null
        var closestDist = 999

        var enemies = this.getEnemySubMap()
        for (var e in enemies) {
            // Skip dead enemies (Battle Royale fix)
            if (isDead(e._id)) continue

            var dist = getCellDistance(playerPos, e._cellPos)

            if (dist < closestDist) {
                closestDist = dist
                closestEnemy = e
            }
        }
        return closestEnemy
    }

    // Select optimal target based on tactical criteria
    // criteria: optional map {prioritizeLowest: "hp"|"distance", bonusForDebuffed: bool, penalizeBuffed: bool}
    selectOptimalTarget(criteria = null) {
        var enemyMap = this.getEnemySubMap()
        var enemies = mapValues(enemyMap)  // Convert map to array
        if (count(enemies) == 0) return null
        if (count(enemies) == 1) return enemies[0]

        // Default criteria
        var priorityMode = criteria != null && mapContainsKey(criteria, 'prioritizeLowest') ? criteria['prioritizeLowest'] : "hp"
        var penalizeBuffed = criteria != null && mapContainsKey(criteria, 'penalizeBuffed') ? criteria['penalizeBuffed'] : false
        var bonusForDebuffed = criteria != null && mapContainsKey(criteria, 'bonusForDebuffed') ? criteria['bonusForDebuffed'] : false

        var bestTarget = null
        var bestScore = -99999
        var playerPos = player._cellPos

        for (var e in enemies) {
            if (isDead(e._id)) continue

            var score = 0
            var dist = getCellDistance(playerPos, e._cellPos)
            if (dist == null) continue

            // Debug: Log entity type for bulb detection verification
            var entityType = getType(e._id)
            debug("[TARGET-SELECT] Evaluating enemy ID=" + e._id + " Type=" + entityType + " Dist=" + dist)

            // HP priority: favor low HP targets (easier kills)
            var enemyHP = getLife(e._id)
            var enemyMaxHP = getTotalLife(e._id)
            var hpPercent = (enemyHP * 100) / enemyMaxHP

            if (priorityMode == "hp") {
                // Lower HP = higher score (100 - hpPercent)
                score += (100 - hpPercent) * 2  // Weight: 0-200 points
                // Distance penalty (closer = better)
                score -= dist * 5  // -5 per cell distance
            } else {
                // Distance priority
                score -= dist * 10
                // HP bonus (still prefer low HP)
                score += (100 - hpPercent)
            }

            // BULB PRIORITY: Distance-conditional bonus to prevent swarming
            if (entityType == ENTITY_BULB) {
                if (dist <= 6) {
                    score += 200  // Close bulb: very high priority (clear before swarming)
                    debug("[TARGET-BULB] Close bulb detected (dist=" + dist + "), adding +200 priority")
                } else if (dist <= 10) {
                    score += 100  // Medium range bulb: moderate priority
                    debug("[TARGET-BULB] Medium-range bulb detected (dist=" + dist + "), adding +100 priority")
                } else {
                    score += 30   // Far bulb: slight priority (don't chase if enemies nearby)
                    debug("[TARGET-BULB] Far bulb detected (dist=" + dist + "), adding +30 priority")
                }
            }

            // Bonus for debuffed enemies (POISON, SHACKLE_TP, etc.)
            if (bonusForDebuffed) {
                var effects = getEffects(e._id)
                if (effects != null) {
                    for (var eff in effects) {
                        if (eff[0] == EFFECT_POISON) score += 30  // Poisoned = priority
                        if (eff[0] == EFFECT_SHACKLE_TP) score += 20  // Low TP = vulnerable
                        if (eff[0] == EFFECT_SHACKLE_MP) score += 15  // Low mobility
                    }
                }
            }

            // Penalty for buffed enemies (BUFF_STRENGTH, shields, etc.)
            if (penalizeBuffed) {
                if (e._absShield > 50 || e._relShield > 20) score -= 25  // Heavily shielded
                var effsBuff = getEffects(e._id)
                if (effsBuff != null) {
                    for (var effB in effsBuff) {
                        if (effB[0] == EFFECT_BUFF_STRENGTH) score -= 20  // High damage threat
                        if (effB[0] == EFFECT_DAMAGE_RETURN) score -= 15  // Damage return = risky
                    }
                }
            }

            if (score > bestScore) {
                bestScore = score
                bestTarget = e
            }
        }

        if (bestTarget != null) {
            debug("[TARGET-PRIORITY] Selected enemy " + bestTarget._id + " (score=" + floor(bestScore) + " HP=" + floor((getLife(bestTarget._id) * 100) / getTotalLife(bestTarget._id)) + "%)")
        }

        return bestTarget
    }

    getClosestChest() {
        var playerPos = player._cellPos
        var closestChest = null
        var closestDist = 999

        var chests = this.getChestSubMap()
        for (var c in chests) {
            // Skip dead chests
            if (isDead(c._id)) continue

            var dist = getCellDistance(playerPos, c._cellPos)

            if (dist < closestDist) {
                closestDist = dist
                closestChest = c
            }
        }
        return closestChest
    }

    getClosestHighestDmgHitCell() {
        var playerPos = player._cellPos
        var closestCell = -1
        var closestDist = 999
        var highestDmg = -1

        for (var c in this.damageMap) {
            var dist = getPathLength(playerPos, c._id)

            // No path to cell
            if (dist == null) {
                continue
            }

            if (c._weaponDamage > highestDmg) {
                highestDmg = c._weaponDamage
                closestDist = dist
                closestCell = c
            }
            else if (c._weaponDamage == highestDmg && dist < closestDist) {
                closestDist = dist
                closestCell = c
            }
        }

        // if cell is unreachable this turn, check if we can reach another cell
        if (closestCell != -1 && closestDist > player._currMp) {
            var potentialCell = this.getClosestHitCell()
            var dist = getPathLength(playerPos, potentialCell._id)


            if (potentialCell != -1 && dist <= player._currMp) {
                closestCell = potentialCell
            }
        }

        return closestCell
    }

    getClosestHitCellForWeapon(weapon) {
        var playerPos = player._cellPos
        var closestCell = -1
        var closestDist = 999

        for (var c in this.damageMap) {
            if (c._highestDamageWeapon == -1) {
                continue
            }

            if (c._highestDamageWeapon._id != weapon._id) {
                continue
            }

            var dist = getPathLength(playerPos, c._id)

            if (dist == null) {
                debug("No path to cell " + c._id)
                continue
            }

            if (dist < closestDist && dist <= player._currMp) {
                closestDist = dist
                closestCell = c
            }
        }
        return closestCell
    }

    getClosestHitCell() {
        var playerPos = this.getPlayerPos()
        var closestCell = -1
        var closestDist = 999

        for (var c in this.damageMap) {
            var dist = getPathLength(playerPos, c._id)

            if (dist == null) {
                debug("No path to cell " + c._id)
                continue
            }

            if (dist < closestDist) {
                closestDist = dist
                closestCell = c
            }
        }
        return closestCell
    }

    getBestWeaponOrChipCell() {
        var best = -1
        var bestDmg = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in this.damageMap) {
            var dmg = c._totalDamage
            var dist = getPathLength(playerPos, c._id)
            if (dist == null) continue  // Skip unreachable cells
            if (dmg > bestDmg || (dmg == bestDmg && dist < bestDist)) {
                bestDmg = dmg
                best = c
                bestDist = dist
            }
        }
        return best
    }

    // New: provide a weighted best cell factoring in preference for DoT (poison) vs direct damage
    // dotWeight: how many times more valuable total DoT is relative to the same amount of direct damage
    // directWeight: weight multiplier for immediate damage (default 1)
    getBestWeightedDamageCell(dotWeight, directWeight) {
        var best = -1
        var bestScore = -1
        for (var c in this.damageMap) {
            var score = c._directDamage * directWeight + c._dotDamage * dotWeight
            if (score > bestScore) {
                bestScore = score
                best = c
            }
        }
        return best
    }

    // New: return array of cells where a specific chip (poison) or weapon is the highest damage source
    getAllCellsForItem(item, isWeapon) {
        var result = []
        for (var c in this.damageMap) {
            if (isWeapon) {
                if (c._highestDamageWeapon != -1 && c._highestDamageWeapon._id == item._id) {
                    push(result, c)
                }
            } else {
                if (c._highestDamageChip != -1 && c._highestDamageChip._id == item._id) {
                    push(result, c)
                }
            }
        }
        return result
    }

    getLineHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var curCell = cell
        for (var dir = 0; dir < 4; dir++) {
            for (var dist = minR; dist <= maxR; dist++) {
                if (dir == 0) {
                    curCell = cell - y_offset * dist
                } else if (dir == 1) {
                    curCell = cell + x_offset * dist
                } else if (dir == 2) {
                    curCell = cell + y_offset * dist
                } else if (dir == 3) {
                    curCell = cell - x_offset * dist
                }
                // Verify actual game distance matches expected range
                var actualDist = getCellDistance(cell, curCell)
                if (actualDist == null || actualDist < minR || actualDist > maxR) continue

                var _hasLOS = lineOfSight(cell, curCell)
                        if (_hasLOS && curCell >= 0 && curCell < FieldMap.board_cell_count) {
                    // curCell = shooting position, cell = target (AoE center)
                    this.updateHitCells(hitCells, curCell, weapon, chip, cell)
                }
            }
        }
        return hitCells
    }

    getDiagonalHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var curCell = cell
        for (var dir = 0; dir < 4; dir++) {
            for (var dist = minR; dist <= maxR; dist++) {
                if (dir == 0) {
                    curCell = cell + up_right_offset * dist
                } else if (dir == 1) {
                    curCell = cell + down_right_offset * dist
                } else if (dir == 2) {
                    curCell = cell + down_left_offset * dist
                } else if (dir == 3) {
                    curCell = cell + up_left_offset * dist
                }
                // Verify actual game distance matches expected range
                var actualDist = getCellDistance(cell, curCell)
                if (actualDist == null || actualDist < minR || actualDist > maxR) continue

                var _hasLOS = lineOfSight(cell, curCell)
                        if (_hasLOS && curCell >= 0 && curCell < FieldMap.board_cell_count) {
                    // curCell = shooting position, cell = target (AoE center)
                    this.updateHitCells(hitCells, curCell, weapon, chip, cell)
                }
            }
        }
        return hitCells
    }

    getStarHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        var lineMap = [:]
        lineMap = this.getLineHits(lineMap, cell, minR, maxR, aoeType, weapon, chip)
        var diagMap = [:]
        diagMap = this.getDiagonalHits(diagMap, cell, minR, maxR, aoeType, weapon, chip)
        var merged = mapMerge(lineMap, diagMap)
        return mapMerge(hitCells, merged)
    }

    getCircleHits(hitCells, cell, minR, maxR, aoeType, weapon=null, chip=null) {
        for (var dx = -maxR; dx <= maxR; dx++) {
            for (var dy = -maxR; dy <= maxR; dy++) {
                var dist = abs(dx) + abs(dy)
                if (dist >= minR && dist <= maxR) {
                    var curCell = cell + FieldMap.x_offset * dx + FieldMap.y_offset * dy
                    var _hasLOS = lineOfSight(cell, curCell)
                            if (_hasLOS && curCell >= 0 && curCell < FieldMap.board_cell_count) {
                        // curCell = shooting position, cell = target (AoE center)
                        this.updateHitCells(hitCells, curCell, weapon, chip, cell)
                    }
                }
            }
        }
        return hitCells
    }

    // Updated to support AoE damage calculations
    // curCell: the cell we're shooting FROM
    // targetCell: the cell we're aiming AT (center of AoE impact, typically oppCell)
    // Note: With AoE, damage stored represents the total potential damage to primary target at targetCell
    updateHitCells(hitCells, curCell, weapon=null, chip=null, targetCell=-1) {
        if (weapon == null && chip == null) {
            return hitCells
        }

        if (weapon != null) {
            // For AoE calculations: if targetCell provided, use it as center; otherwise assume single-target (no falloff)
            var breakdownW = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, weapon._id, targetCell, targetCell)
            var scaledDamage = breakdownW['total']
            scaledDamage *= weapon._maxUse // assume we can hit with all uses
            if (mapContainsKey(hitCells, curCell)) {
                if (hitCells[curCell]._weaponDamage < scaledDamage) {
                    hitCells[curCell]._weaponDamage = scaledDamage
                    hitCells[curCell]._highestDamageWeapon = weapon
                    // Replace direct/dot components for weapon path (stack each use)
                    hitCells[curCell]._directDamage = breakdownW['direct'] * weapon._maxUse
                    hitCells[curCell]._dotDamage += breakdownW['dot'] * weapon._maxUse
                }
                // record presence of weapon even if not highest damage
                var already = false
                for (var wIdx = 0; wIdx < count(hitCells[curCell]._weaponsList); wIdx++) {
                    if (hitCells[curCell]._weaponsList[wIdx]._id == weapon._id) { already = true; break }
                }
                if (!already) push(hitCells[curCell]._weaponsList, weapon)
            }
            else {
                var newCell = new Cell(curCell, false, getEntityOnCell(curCell), scaledDamage, 0, true, weapon, -1)
                newCell._directDamage = breakdownW['direct'] * weapon._maxUse
                newCell._dotDamage = breakdownW['dot'] * weapon._maxUse
                push(newCell._weaponsList, weapon)
                mapPut(hitCells, curCell, newCell)
            }
        }
        else if (chip != null) {
            // For AoE calculations: if targetCell provided, use it as center; otherwise assume single-target
            var breakdownC = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, chip._id, targetCell, targetCell)
            var scaledDamage = breakdownC['total']
            scaledDamage *= chip._maxUse // assume we can hit with all uses
            // Removed verbose integration debug to avoid log spam.
            if (mapContainsKey(hitCells, curCell)) {
                // Always accumulate stacking potential for poison-capable chips
                hitCells[curCell]._directDamage += breakdownC['direct'] * chip._maxUse
                hitCells[curCell]._dotDamage += breakdownC['dot'] * chip._maxUse
                if (hitCells[curCell]._chipDamage < scaledDamage) {
                    hitCells[curCell]._chipDamage = scaledDamage
                    hitCells[curCell]._highestDamageChip = chip
                }
                var alreadyC = false
                for (var cIdx = 0; cIdx < count(hitCells[curCell]._chipsList); cIdx++) {
                    if (hitCells[curCell]._chipsList[cIdx]._id == chip._id) { alreadyC = true; break }
                }
                if (!alreadyC) push(hitCells[curCell]._chipsList, chip)
            } else {
                var nc = new Cell(curCell, false, getEntityOnCell(curCell), 0, scaledDamage, true, -1, chip)
                nc._directDamage = breakdownC['direct'] * chip._maxUse
                nc._dotDamage = breakdownC['dot'] * chip._maxUse
                push(nc._chipsList, chip)
                // Store the chip object (not just its id) so later accesses to _highestDamageChip._id are valid
                mapPut(hitCells, curCell, nc)
            }
        }
        // Recompute aggregate
        if (mapContainsKey(hitCells, curCell)) {
            var cellRef = hitCells[curCell]
            cellRef._totalDamage = cellRef._weaponDamage + cellRef._chipDamage
            if (cellRef._weaponDamage >= cellRef._chipDamage && cellRef._weaponDamage > 0) cellRef._bestType = 0
            else if (cellRef._chipDamage > cellRef._weaponDamage) cellRef._bestType = 1
        }
        return hitCells
    }

    // Build or reuse cached enemy accessible cells for this turn.
    getEnemyAccess() {
        var curTurn = getTurn()
        var enemiesMap = this.getEnemySubMap()
        var enemyIdsNow = mapKeys(enemiesMap)
        // Rebuild conditions: turn changed OR enemy count changed OR any id mismatch
        var needRebuild = (curTurn != this._enemyAccessCacheTurn)
        if (!needRebuild && count(enemyIdsNow) != count(this._enemyAccessCacheIds)) needRebuild = true
        if (!needRebuild) {
            for (var i = 0; i < count(enemyIdsNow); i++) {
                var found = false
                for (var j = 0; j < count(this._enemyAccessCacheIds); j++) { if (enemyIdsNow[i] == this._enemyAccessCacheIds[j]) { found = true; break } }
                if (!found) { needRebuild = true; break }
            }
        }
        if (needRebuild) {
            this._enemyAccessCache = []
            this._enemyAccessCacheIds = []
            for (var ei = 0; ei < count(enemyIdsNow); ei++) {
                var eid = enemyIdsNow[ei]
                var enemyObj = enemiesMap[eid]
                if (enemyObj == null) continue
                var eAcc = this.getAccessibleCells(enemyObj)
                if (indexOf(eAcc, enemyObj._cellPos) == -1) push(eAcc, enemyObj._cellPos)
                push(this._enemyAccessCache, ['enemy': enemyObj, 'cells': eAcc])
                push(this._enemyAccessCacheIds, eid)
            }
            this._enemyAccessCacheTurn = curTurn
            debug("[HNS][CACHE] Rebuilt enemy access cache size=" + count(this._enemyAccessCache))
        }
        return this._enemyAccessCache
    }

    // ---- Hide & Seek Support ----
    // Compute all cells reachable this turn for a given entity (within current MP, non-obstacle, path exists)
    getAccessibleCells(entity) {
        var acc = []
        if (entity == null) return acc
        var mp = entity._currMp
        var origin = entity._cellPos
        // Iterate over board (613 cells) â€“ acceptable cost; early continue on obstacles
        for (var cid = 0; cid < FieldMap.board_cell_count; cid++) {
            if (isObstacle(cid)) continue
            // Quick distance lower bound: if Manhattan-like distance already > mp, skip (approx via getCellDistance)
            var approx = getCellDistance(origin, cid)
            if (approx == null || approx > mp) continue
            var len = getPathLength(origin, cid)
            if (len == null) continue
            if (len <= mp) push(acc, cid)
        }
        return acc
    }

    // Evaluate best hiding cell: a cell is "safe" if NO enemy-accessible cell has line of sight to it.
    // We return either a perfectly safe cell (danger=0) maximizing distance to nearest enemy, or if none safe,
    // the cell with minimal danger (fewest LOS exposures) and then greatest distance.
    findHideAndSeekCell() {
        var enemyAccess = this.getEnemyAccess()
        if (count(enemyAccess) == 0) return null
        var playerAccessible = this.getAccessibleCells(player)
        // Always include current position even if MP=0 (already in list normally)
        if (indexOf(playerAccessible, player._cellPos) == -1) push(playerAccessible, player._cellPos)

        // enemyAccess already built / cached

        var bestCell = -1
        var bestDanger = 99999
        var bestDist = -1
        var playerPos = player._cellPos

        for (var i = 0; i < count(playerAccessible); i++) {
            var cand = playerAccessible[i]
            var danger = 0
            var earlyStop = false
            // For distance metric: distance to closest enemy origin cell (after movement they could be elsewhere but this is heuristic)
            var closestEnemyDist = 999
            for (var ea = 0; ea < count(enemyAccess); ea++) {
                var enemyRef = enemyAccess[ea]['enemy']
                if (enemyRef == null) continue

                // Calculate threat weight for this enemy (based on stats and HP)
                var enemyHP = getLife(enemyRef._id)
                var enemyMaxHP = getTotalLife(enemyRef._id)
                var enemyHPPercent = (enemyHP * 100) / enemyMaxHP
                var enemyStrength = getStrength(enemyRef._id)
                var enemyMagic = getMagic(enemyRef._id)

                // Threat calculation: higher stats = more dangerous, low HP = less dangerous
                var baseThreat = (enemyStrength + enemyMagic) / 200.0  // Normalize to ~1.0
                var hpMultiplier = enemyHPPercent / 100.0  // Low HP = less threat
                var threatWeight = max(0.1, baseThreat * hpMultiplier)  // Minimum 0.1 to avoid zero weight

                var eOrigDist = getCellDistance(cand, enemyRef._cellPos)
                if (eOrigDist != null && eOrigDist < closestEnemyDist) closestEnemyDist = eOrigDist
                var cellsArr = enemyAccess[ea]['cells']
                for (var ec = 0; ec < count(cellsArr); ec++) {
                    var eCell = cellsArr[ec]
                    if (lineOfSight(eCell, cand)) {
                        danger += threatWeight  // Weighted danger instead of +1
                        if (danger > bestDanger && bestDanger == 0) { earlyStop = true; break }
                    }
                }
                if (earlyStop) break
            }
            if (closestEnemyDist == 999) closestEnemyDist = 0 // fallback

            // Selection logic:
            // 1. Prefer lower danger
            // 2. If equal danger, prefer greater closestEnemyDist
            if (danger < bestDanger || (danger == bestDanger && closestEnemyDist > bestDist)) {
                bestDanger = danger
                bestCell = cand
                bestDist = closestEnemyDist
                // Perfect safe cell with maximal possible distance heuristic early cut: if danger == 0 and bestDist is near MP+enemy MP upper bound we still continue for potentially further safe cell.
            }
        }

        if (bestCell == -1) return null
        debug("[HNS] bestCell=" + bestCell + " danger=" + bestDanger + " dist=" + bestDist + " playerPos=" + playerPos)
        // Mark chosen cell for visualization if different from current
        if (bestCell != playerPos) mark(bestCell, getColor(120, 200, 255), 3)
        return ['cell': bestCell, 'danger': bestDanger, 'safe': (bestDanger == 0)]
    }

    // Compute danger (LOS exposures) for a single cell, given precomputed enemy access arrays
    private computeDangerForCell(cellId, enemyAccess) {
        var danger = 0
        for (var ea = 0; ea < count(enemyAccess); ea++) {
            var cellsArr = enemyAccess[ea]['cells']
            for (var ec = 0; ec < count(cellsArr); ec++) {
                if (lineOfSight(cellsArr[ec], cellId)) { danger += 1 }
            }
        }
        return danger
    }

    // Approach-oriented Hide & Seek: choose an accessible cell that gets closer (or maintains distance if already in range)
    // while minimizing danger, and preferably allows an attack (weapon or chip) this turn.
    // Returns map: ['cell': Cell, 'danger': int, 'canAttack': bool, 'dist': int]
    findApproachHideAndSeekCell(target) {
        if (target == null) return null
        var enemyAccess = this.getEnemyAccess()
        if (count(enemyAccess) == 0) return null
        var playerAccessible = this.getAccessibleCells(player)
        if (indexOf(playerAccessible, player._cellPos) == -1) push(playerAccessible, player._cellPos)
        // enemyAccess already cached

        var bestCell = -1
        var bestDanger = 99999
        var bestDist = 99999
        var bestCanAttack = false
        var targetPos = target._cellPos
        var currentDist = getCellDistance(player._cellPos, targetPos)

        for (var i = 0; i < count(playerAccessible); i++) {
            var cand = playerAccessible[i]
            // Restrict to cells we can path to (sanity) and within MP already enforced by getAccessibleCells
            // Evaluate distance to target
            var distTarget = getCellDistance(cand, targetPos)
            if (distTarget == null) continue
            var canAttack = false
            // Only consider attack viability if this cell is in damageMap (already computed hit cells this turn)
            if (mapContainsKey(this.damageMap, cand)) {
                var cellRef = this.damageMap[cand]
                // Attack possible if any highest damage weapon or chip is defined and LOS still valid
                if (cellRef._highestDamageWeapon != -1) canAttack = true
                else if (cellRef._highestDamageChip != -1) canAttack = true
            }
            // Skip cells that increase distance unless they allow an attack (maintain approach bias)
            if (!canAttack && distTarget > currentDist) continue
            var danger = this.computeDangerForCell(cand, enemyAccess)
            // Ordering:
            // 1. Prefer cells that can attack (canAttack true beats false)
            // 2. Lower danger
            // 3. Lower distance to target
            // 4. If tie, prefer improving (distTarget < currentDist)
            if (bestCell == -1) {
                bestCell = cand; bestDanger = danger; bestDist = distTarget; bestCanAttack = canAttack; continue
            }
            if (canAttack && !bestCanAttack) {
                bestCell = cand; bestDanger = danger; bestDist = distTarget; bestCanAttack = true; continue
            }
            if (canAttack == bestCanAttack) {
                if (danger < bestDanger || (danger == bestDanger && distTarget < bestDist) || (danger == bestDanger && distTarget == bestDist && distTarget < currentDist && bestDist >= currentDist)) {
                    bestCell = cand; bestDanger = danger; bestDist = distTarget; bestCanAttack = canAttack
                }
            }
        }
        if (bestCell == -1) return null
        if (bestCell != player._cellPos) mark(bestCell, getColor(255, 200, 120), 3)
        debug("[HNS-APPROACH] bestCell=" + bestCell + " canAttack=" + bestCanAttack + " danger=" + bestDanger + " dist=" + bestDist + " currentDist=" + currentDist)
        return ['cell': bestCell, 'danger': bestDanger, 'canAttack': bestCanAttack, 'dist': bestDist]
    }

    // Find optimal teleport cell for OTKO (One-Turn Kill Opportunity)
    // Returns: ['cell': cellID, 'damage': projectedDamage, 'canKill': boolean]
    findOptimalTeleportCell(target) {
        if (target == null) return null

        var playerPos = player._cellPos
        var bestCell = -1
        var bestDamage = -1
        var targetHP = target._currHealth

        // Build candidate cells: use damage map cells (already calculated as valid attack positions)
        // This is much faster than iterating all 613 board cells
        var candidateCells = []

        // Add all cells from damage map (these are known attack positions)
        for (var dmCell in this.damageMap) {
            push(candidateCells, dmCell._id)
        }

        // If damage map is empty or very small, fall back to circular search around target
        if (count(candidateCells) < 10) {
            debug("[OTKO-TELEPORT] Damage map has few cells (" + count(candidateCells) + "), adding proximity search")
            var searchRadius = 8
            for (var dx = -searchRadius; dx <= searchRadius; dx++) {
                for (var dy = -searchRadius; dy <= searchRadius; dy++) {
                    var dist = abs(dx) + abs(dy)
                    if (dist < 1 || dist > searchRadius) continue
                    var cellId = target._cellPos + FieldMap.x_offset * dx + FieldMap.y_offset * dy
                    if (cellId >= 0 && cellId < FieldMap.board_cell_count && !isObstacle(cellId) && !isEntity(cellId)) {
                        push(candidateCells, cellId)
                    }
                }
            }
        }

        // Now evaluate each candidate cell
        for (var idx = 0; idx < count(candidateCells); idx++) {
            var cellId = candidateCells[idx]

            // Skip if cell is obstacle or occupied
            if (isObstacle(cellId)) continue
            if (isEntity(cellId)) continue

            // Check if within teleport range (1-12 from player position)
            var distFromPlayer = getCellDistance(playerPos, cellId)
            if (distFromPlayer == null || distFromPlayer < 1 || distFromPlayer > 12) continue

            // Calculate total shield-adjusted damage from this cell
            var totalDamage = 0
            var playerTP = player._currTp - 9  // Reserve 9 TP for teleport

            // Check all equipped weapons
            for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
                var wObj = arsenal.playerEquippedWeapons[wid]
                if (wObj == null) continue

                // Check if weapon can hit target from this cell
                var distToTarget = getCellDistance(cellId, target._cellPos)
                if (distToTarget == null) continue
                if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
                if (!lineOfSight(cellId, target._cellPos)) continue

                // Calculate shield-adjusted damage
                var weaponDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)

                // Account for TP cost and max uses
                var tpBudget = playerTP
                if (getWeapon() != wid) tpBudget -= 1  // Weapon swap cost
                var uses = min(wObj._maxUse, floor(tpBudget / wObj._cost))
                totalDamage += weaponDmg * uses
            }

            // Check all damage chips (if TP remains)
            if (playerTP > 0) {
                for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                    var chipObj = arsenal.playerEquippedChips[cid]
                    if (chipObj == null) continue
                    if (cid == CHIP_TELEPORTATION) continue  // Already accounted for

                    // Filter attack chips (damage or poison effects)
                    if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                    // Check if chip can hit target from this cell
                    var distChip = getCellDistance(cellId, target._cellPos)
                    if (distChip == null) continue
                    if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                    if (!lineOfSight(cellId, target._cellPos)) continue

                    var chipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                    var tpRemain = playerTP - totalDamage  // Simplified: use remaining TP estimate
                    if (tpRemain < chipObj._cost) continue
                    var usesChip = min(chipObj._maxUse, floor(tpRemain / chipObj._cost))
                    totalDamage += chipDmg * usesChip
                }
            }

            // Update best cell if this one deals more damage
            if (totalDamage > bestDamage) {
                bestDamage = totalDamage
                bestCell = cellId
            }
        }

        if (bestCell == -1) return null

        var canKill = (bestDamage >= targetHP)
        debug("[OTKO-TELEPORT] bestCell=" + bestCell + " projectedDamage=" + bestDamage + " targetHP=" + targetHP + " canKill=" + canKill)

        return ['cell': bestCell, 'damage': bestDamage, 'canKill': canKill]
    }
}