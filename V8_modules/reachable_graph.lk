// Unified Reachable Graph - Phase 1 Optimization
// Precomputes reachability data once per turn, shared by all consumers

// Global adjacency map (initialized once on turn 1)
global GLOBAL_NEIGHBORS = null
global ReachableGraph = null

// Initialize adjacency map (run once on turn 1)
function initializeAdjacency() {
    if (GLOBAL_NEIGHBORS != null) return null

    GLOBAL_NEIGHBORS = []

    for (var cell = 0; cell < 613; cell++) {
        var neighbors = []

        // Hexagonal grid neighbors
        var candidates = [
            cell - 18,  // NW
            cell - 17,  // NE
            cell - 1,   // W
            cell + 1,   // E
            cell + 17,  // SW
            cell + 18   // SE
        ]

        for (var n in candidates) {
            if (n >= 0 && n < 613 && !isObstacle(n)) {
                var dist = getCellDistance(cell, n)
                if (dist == 1) {
                    push(neighbors, n)
                }
            }
        }

        push(GLOBAL_NEIGHBORS, neighbors)
    }

    debug("[ADJACENCY] Initialized " + count(GLOBAL_NEIGHBORS) + " cells")
    return null
}

// Build reachable graph with BFS (flat arrays for parser safety)
function buildReachableGraph(startCell, maxMP, playerObj, targetObj, arsenalObj) {
    startOp()

    // Use map instead of array for mpCost (LeekScript doesn't support direct array indexing)
    var mpCost = [:]

    // BFS queue (head-pointer to avoid expensive remove)
    var queue = [startCell]
    var head = 0
    mpCost[startCell] = 0

    while (head < count(queue)) {
        // Safety valve (raised to 12M for deeper search)
        if (getOperations() > 12000000) {
            debug("[REACHABLE-BFS] Safety valve triggered at 12M ops")
            break
        }

        var current = queue[head]
        head = head + 1

        var currentCost = mpCost[current]
        if (currentCost >= maxMP) continue

        // Use precomputed neighbors
        var neighbors = GLOBAL_NEIGHBORS[current]
        for (var neighbor in neighbors) {
            if (!mapContainsKey(mpCost, neighbor)) {
                mpCost[neighbor] = currentCost + 1
                push(queue, neighbor)
            }
        }
    }

    var bfsOps = stopOp("BFS Pathfinding")

    // Enrich with damage/threat data
    startOp()
    ReachableGraph = enrichReachableGraph(mpCost, playerObj, targetObj, arsenalObj)
    var enrichOps = stopOp("Graph Enrichment")

    var cellCount = count(mapKeys(ReachableGraph))
    debug("[REACHABLE-GRAPH] Built: " + cellCount + " cells, BFS=" + bfsOps + " ops, enrich=" + enrichOps + " ops")

    return ReachableGraph
}

// Enrich graph with threat data (simplified - no damage calculation)
function enrichReachableGraph(mpCost, playerObj, targetObj, arsenalObj) {
    var graph = [:]

    // Iterate only over reachable cells (keys in mpCost map)
    for (var cellId in mapKeys(mpCost)) {
        // Store simple data structure
        graph[cellId] = [
            'mp': mpCost[cellId],
            'threat': 0  // Will be set by field map
        ]
    }

    return graph
}

// O(1) lookup helpers
function getGraphMPCost(cellId) {
    if (ReachableGraph == null) return 999
    if (!mapContainsKey(ReachableGraph, cellId)) return 999
    return ReachableGraph[cellId]['mp']
}

function getGraphThreat(cellId) {
    if (ReachableGraph == null) return 0
    if (!mapContainsKey(ReachableGraph, cellId)) return 0
    return ReachableGraph[cellId]['threat']
}

function isGraphReachableCell(cellId) {
    if (ReachableGraph == null) return false
    return mapContainsKey(ReachableGraph, cellId)
}

function getReachableCells() {
    if (ReachableGraph == null) return []
    return mapKeys(ReachableGraph)
}

function updateGraphThreat(cellId, threat) {
    if (ReachableGraph == null) return null
    if (!mapContainsKey(ReachableGraph, cellId)) return null
    ReachableGraph[cellId]['threat'] = threat
    return null
}
