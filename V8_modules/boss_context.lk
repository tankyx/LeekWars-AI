// Boss Context — Pure-data module for Fennel King boss fight
// Provides globals and functions for the scenario engine to use during boss fights.
// No strategy class — all logic flows through UnifiedStrategy + scenario engine.
// NOTE: Crystal/graal objects are maps — use bracket notation (obj['key']), not dot notation.

global _bossPhase = null           // "PUZZLE" | "COMBAT" | null
global _graalEntity = null         // ['id', 'cell', 'x', 'y'] (internal map — use _graal* globals cross-file)
global _crystalMap = [:]           // eid -> ['id', 'color', 'goalAxis', 'cell', 'x', 'y', 'solved']
global _myAssignedCrystal = null   // crystal map from _crystalMap (internal — use _myCrystal* globals cross-file)
global _bossTargetEID = null // Persistent: crystal entity ID (survives re-assignment)
global _usedInversion = false
global _isBossFight = false

// Scalar globals for cross-file access (LeekScript bracket notation on maps
// doesn't work across compilation units — "Field unknown in class" error)
global _graalCell = -1
global _graalX = 0
global _graalY = 0
global _myCrystalCell = -1
global _myCrystalX = 0
global _myCrystalY = 0
global _myCrystalColor = null
global _myCrystalGoalAxis = null
global _myCrystalSolved = false

// Detect boss fight by scanning for graal entity
function detectBossFight() {
    var entities = getAliveEnemies()
    for (var eid in entities) {
        var entityType = getName(eid)
        if (entityType == "graal") {
            return true
        }
    }
    return false
}

// Called once from init()
function initBossContext() {
    _isBossFight = true
    updateBossContext()
}

// Called every turn from main()
function updateBossContext() {
    if (!_isBossFight) return

    _graalEntity = null
    _graalCell = -1
    _graalX = 0
    _graalY = 0
    _crystalMap = [:]

    // Use getAliveEnemies() + getAliveAllies() to find boss entities reliably
    // (isEntity(cellId) scan doesn't work for all boss entity types)
    var allEntities = []
    var enemies = getAliveEnemies()
    for (var eid in enemies) {
        push(allEntities, eid)
    }
    var allies = getAliveAllies()
    for (var aid in allies) {
        push(allEntities, aid)
    }

    for (var eid in allEntities) {
        var entityType = getName(eid)
        var cellId = getCell(eid)

        debugInfo("[BOSS] Entity " + eid + " name=" + entityType + " cell=" + cellId)

        if (entityType == "graal") {
            _graalEntity = [
                'id': eid,
                'cell': cellId,
                'x': getCellX(cellId),
                'y': getCellY(cellId)
            ]
            _graalCell = cellId
            _graalX = getCellX(cellId)
            _graalY = getCellY(cellId)
        }
        else if (entityType == "red_crystal" || entityType == "blue_crystal" ||
                 entityType == "yellow_crystal" || entityType == "green_crystal") {
            var color = substring(entityType, 0, indexOf(entityType, "_"))
            var goalAxis = getGoalAxis(color)

            _crystalMap[eid] = [
                'id': eid,
                'color': color,
                'goalAxis': goalAxis,
                'cell': cellId,
                'x': getCellX(cellId),
                'y': getCellY(cellId),
                'solved': false
            ]
        }
    }

    // Set phase
    if (_graalEntity != null) {
        _bossPhase = "PUZZLE"
    } else {
        _bossPhase = "COMBAT"
    }

    // Assign crystals to allies
    assignCrystalByProximity()
}

function getBossPhase() {
    return _bossPhase
}

// =========================================================================
// === Crystal Assignment ===
// =========================================================================

function syncCrystalScalars(crystal) {
    _myCrystalCell = crystal['cell']
    _myCrystalX = crystal['x']
    _myCrystalY = crystal['y']
    _myCrystalColor = crystal['color']
    _myCrystalGoalAxis = crystal['goalAxis']
    _myCrystalSolved = crystal['solved']
}

function clearCrystalScalars() {
    _myCrystalCell = -1
    _myCrystalX = 0
    _myCrystalY = 0
    _myCrystalColor = null
    _myCrystalGoalAxis = null
    _myCrystalSolved = false
}

function assignCrystalByProximity() {
    // Deterministic assignment: sorted allies → sorted unsolved crystals by index.
    // Each leek runs this independently, but since both lists are sorted by entity ID
    // and the mapping is position-independent, all leeks compute the same result.
    // (Old proximity-based algorithm was non-deterministic because ally positions
    // change mid-turn as each leek moves before the next one runs.)
    var myID = getEntity()
    var allAllies = []
    push(allAllies, myID)
    var allies = getAliveAllies()
    for (var aid in allies) {
        push(allAllies, aid)
    }
    sort(allAllies)

    // Collect unsolved crystal EIDs — skip crystals already on correct axis with LoS to graal
    var unsolvedEIDs = []
    for (var eid in mapKeys(_crystalMap)) {
        var cData = _crystalMap[eid]
        var cAxis = cData['goalAxis']
        var cCell = cData['cell']
        var cx = cData['x']
        var cy = cData['y']
        // Solved = on correct cardinal axis + line of sight to graal
        var onAxis = false
        if (cAxis == "north") onAxis = (cx == _graalX && cy < _graalY)
        else if (cAxis == "south") onAxis = (cx == _graalX && cy > _graalY)
        else if (cAxis == "east") onAxis = (cy == _graalY && cx > _graalX)
        else if (cAxis == "west") onAxis = (cy == _graalY && cx < _graalX)
        if (onAxis && lineOfSight(cCell, _graalCell)) continue  // solved, skip
        push(unsolvedEIDs, eid)
    }
    sort(unsolvedEIDs)

    // Find my index in the sorted ally list
    var myIndex = -1
    for (var i = 0; i < count(allAllies); i++) {
        if (allAllies[i] == myID) {
            myIndex = i
            break
        }
    }

    // Map: ally[myIndex] → crystal[myIndex]
    _myAssignedCrystal = null
    _bossTargetEID = null
    if (myIndex >= 0 && myIndex < count(unsolvedEIDs)) {
        var ceid = unsolvedEIDs[myIndex]
        _myAssignedCrystal = _crystalMap[ceid]
        _bossTargetEID = ceid
        syncCrystalScalars(_crystalMap[ceid])
    } else if (count(unsolvedEIDs) > 0 && myIndex == count(unsolvedEIDs)) {
        // Exactly 1 helper per crystal group — only the next leek by index helps.
        // More than 1 helper causes crowding and deadlock (all block each other's diagonals).
        var myCell = getCell()
        var bestDist = 999
        var bestCEID = null
        for (var ceid in unsolvedEIDs) {
            var cData = _crystalMap[ceid]
            var d = getCellDistance(myCell, cData['cell'])
            if (d < bestDist) {
                bestDist = d
                bestCEID = ceid
            }
        }
        if (bestCEID != null) {
            _myAssignedCrystal = _crystalMap[bestCEID]
            _bossTargetEID = bestCEID
            syncCrystalScalars(_crystalMap[bestCEID])
        } else {
            clearCrystalScalars()
        }
    } else {
        clearCrystalScalars()
    }
}

// =========================================================================
// === Geometry Functions ===
// =========================================================================

function getGoalAxis(color) {
    if (color == "red") return "south"
    if (color == "blue") return "east"
    if (color == "yellow") return "west"
    if (color == "green") return "north"
    return "unknown"
}

function isOnGoalAxis(crystal) {
    if (_graalCell == -1) return false

    var axis = crystal['goalAxis']
    var cx = crystal['x']
    var cy = crystal['y']
    var gx = _graalX
    var gy = _graalY

    if (axis == "north") {
        return cx == gx && cy < gy
    } else if (axis == "south") {
        return cx == gx && cy > gy
    } else if (axis == "east") {
        return cy == gy && cx > gx
    } else if (axis == "west") {
        return cy == gy && cx < gx
    }

    return false
}

function hasLOSToGraal(crystal) {
    if (_graalCell == -1) return false
    return lineOfSight(crystal['cell'], _graalCell)
}

function isCrystalSolved(crystal) {
    return isOnGoalAxis(crystal) && hasLOSToGraal(crystal)
}

// getDistanceToAxis: uses scalar globals only (safe cross-file)
function getDistanceToAxis(ignoredCrystal) {
    if (_graalCell == -1) return 999

    var axis = _myCrystalGoalAxis
    var cx = _myCrystalX
    var cy = _myCrystalY
    var gx = _graalX
    var gy = _graalY

    if (axis == "north" || axis == "south") {
        return abs(cx - gx)
    } else {
        return abs(cy - gy)
    }
}

// getDirectionToSlide: uses scalar globals only (safe cross-file)
function getDirectionToSlide(ignoredCrystal) {
    if (_graalCell == -1) return null

    var axis = _myCrystalGoalAxis
    var cx = _myCrystalX
    var cy = _myCrystalY
    var gx = _graalX
    var gy = _graalY

    if (axis == "north" || axis == "south") {
        if (cx < gx) return "pull"
        if (cx > gx) return "push"
        if (axis == "north" && cy >= gy) return "push"
        if (axis == "south" && cy <= gy) return "pull"
    } else {
        if (cy < gy) return "pull"
        if (cy > gy) return "push"
        if (axis == "east" && cx <= gx) return "pull"
        if (axis == "west" && cx >= gx) return "push"
    }

    return null
}

function getTargetAxisCell(ignoredCrystal) {
    if (_graalCell == -1) return -1

    var axis = _myCrystalGoalAxis
    var gx = _graalX
    var gy = _graalY

    var tx = gx
    var ty = gy
    if (axis == "south") ty = gy + 1
    else if (axis == "north") ty = gy - 1
    else if (axis == "east") tx = gx + 1
    else if (axis == "west") tx = gx - 1

    var cell = getCellFromXY(tx, ty)
    if (cell != null && !isObstacle(cell)) return cell

    for (var d = 2; d <= 8; d++) {
        var sx = gx
        var sy = gy
        if (axis == "south") sy = gy + d
        else if (axis == "north") sy = gy - d
        else if (axis == "east") sx = gx + d
        else if (axis == "west") sx = gx - d

        var scanCell = getCellFromXY(sx, sy)
        if (scanCell != null && !isObstacle(scanCell) && lineOfSight(scanCell, _graalCell)) {
            return scanCell
        }
    }

    return -1
}

// =========================================================================
// === Crystal Movement Simulation Helpers ===
// =========================================================================

function computePullDirection(cx, cy, playerCell) {
    var px = getCellX(playerCell)
    var py = getCellY(playerCell)

    var dx = 0
    var dy = 0
    if (px < cx) dx = -1
    else if (px > cx) dx = 1
    if (py < cy) dy = -1
    else if (py > cy) dy = 1

    return [dx, dy]
}

function computePushDirection(cx, cy, playerCell) {
    var px = getCellX(playerCell)
    var py = getCellY(playerCell)

    var dx = 0
    var dy = 0
    if (px < cx) dx = 1
    else if (px > cx) dx = -1
    if (py < cy) dy = 1
    else if (py > cy) dy = -1

    return [dx, dy]
}

function computeAxisDist(cx, cy, gx, gy, goalAxis) {
    if (goalAxis == "north" || goalAxis == "south") {
        return abs(cx - gx)
    } else {
        return abs(cy - gy)
    }
}

function checkOnAxis(cx, cy, gx, gy, goalAxis) {
    if (goalAxis == "north") return cx == gx && cy < gy
    if (goalAxis == "south") return cx == gx && cy > gy
    if (goalAxis == "east") return cy == gy && cx > gx
    if (goalAxis == "west") return cy == gy && cx < gx
    return false
}

// =========================================================================
// === Crystal Destination & Stand Position ===
// =========================================================================

// Compute the FINAL destination: the cell adjacent to the graal in the crystal's cardinal direction
function computeCrystalFinalDest() {
    var axis = _myCrystalGoalAxis
    var gx = _graalX
    var gy = _graalY
    if (axis == "north") return getCellFromXY(gx, gy - 1)
    if (axis == "south") return getCellFromXY(gx, gy + 1)
    if (axis == "east") return getCellFromXY(gx + 1, gy)
    if (axis == "west") return getCellFromXY(gx - 1, gy)
    return null
}

// Compute the axis-aligned intermediate destination (same X for N/S, same Y for E/W)
function computeCrystalAxisDest() {
    var axis = _myCrystalGoalAxis
    if (axis == "north" || axis == "south") {
        return getCellFromXY(_graalX, _myCrystalY)  // align X to graal
    } else {
        return getCellFromXY(_myCrystalX, _graalY)  // align Y to graal
    }
}

// Check if crystal is on the graal's axis AND correct side (N/S/E/W)
function isCrystalOnAxis() {
    var axis = _myCrystalGoalAxis
    if (axis == "north") return _myCrystalX == _graalX && _myCrystalY < _graalY
    if (axis == "south") return _myCrystalX == _graalX && _myCrystalY > _graalY
    if (axis == "east") return _myCrystalY == _graalY && _myCrystalX > _graalX
    if (axis == "west") return _myCrystalY == _graalY && _myCrystalX < _graalX
    return false
}

// Check if path from crystal to destination is clear of obstacles/entities
function isPathClear(fromX, fromY, toX, toY) {
    var dx = (toX > fromX) ? 1 : (toX < fromX) ? -1 : 0
    var dy = (toY > fromY) ? 1 : (toY < fromY) ? -1 : 0
    var x = fromX + dx
    var y = fromY + dy
    while (x != toX || y != toY) {
        var cell = getCellFromXY(x, y)
        if (cell == null || isObstacle(cell)) return false
        if (isEntity(cell)) return false
        x += dx
        y += dy
    }
    // Check destination cell itself
    var destC = getCellFromXY(toX, toY)
    if (destC == null || isObstacle(destC)) return false
    return true
}

// Backward-compatible wrapper for scenario_combos.lk
// Uses scalar globals only (safe cross-file). Not limited by MP — returns target to path toward.
function findIdealSlideCell(ignoredCrystal, direction, playerCell) {
    if (_myCrystalCell == -1 || _graalCell == -1) return -1

    var axis = _myCrystalGoalAxis
    var cx = _myCrystalX
    var cy = _myCrystalY
    var moveAxis = (axis == "north" || axis == "south") ? "x" : "y"
    var delta = (moveAxis == "x") ? (_graalX - cx) : (_graalY - cy)
    var absDelta = abs(delta)
    var sign = (delta > 0) ? 1 : -1

    if (direction == "pull") {
        // GRAPPLE: stand beyond destination (further from crystal)
        var destX = (moveAxis == "x") ? _graalX : cx
        var destY = (moveAxis == "y") ? _graalY : cy
        var maxD = 8 - absDelta
        for (var d = 1; d <= maxD; d++) {
            var tx = destX
            var ty = destY
            if (moveAxis == "x") {
                tx = destX + sign * d
            } else {
                ty = destY + sign * d
            }
            var cell = getCellFromXY(tx, ty)
            if (cell == null) continue
            if (isObstacle(cell)) continue
            if (cell != playerCell && isEntity(cell)) continue
            return cell
        }
    } else {
        // BOXING_GLOVE: stand on opposite side of crystal from destination
        for (var d = 2; d <= 8; d++) {
            var tx = cx
            var ty = cy
            if (moveAxis == "x") {
                tx = cx - sign * d
            } else {
                ty = cy - sign * d
            }
            var cell = getCellFromXY(tx, ty)
            if (cell == null) continue
            if (isObstacle(cell)) continue
            if (cell != playerCell && isEntity(cell)) continue
            return cell
        }
    }
    return -1
}

// =========================================================================
// === Combat Phase Target Selection ===
// =========================================================================

// COMBAT phase priority: fennel_king > fennel_knight > fennel_scribe > fennel_squire
function selectCombatTarget(fieldMapObj) {
    var enemies = getAliveEnemies()
    if (count(enemies) == 0) return null

    var priority = ["fennel_king", "fennel_knight", "fennel_scribe", "fennel_squire"]

    for (var pName in priority) {
        for (var eid in enemies) {
            if (getName(eid) == pName) {
                var enemySub = fieldMapObj.getEnemySubMap()
                if (mapContainsKey(enemySub, eid)) {
                    return enemySub[eid]
                }
            }
        }
    }

    // Fallback: lowest-HP enemy
    var bestTarget = null
    var bestHP = 999999
    for (var eid in enemies) {
        var hp = getLife(eid)
        if (hp < bestHP) {
            bestHP = hp
            bestTarget = eid
        }
    }

    if (bestTarget != null) {
        var enemySub = fieldMapObj.getEnemySubMap()
        if (mapContainsKey(enemySub, bestTarget)) {
            return enemySub[bestTarget]
        }
    }

    return null
}

function isCrystalEntity(eid) {
    return mapContainsKey(_crystalMap, eid)
}

// Diagnostic — say() only works from included files, not main.lk
function bossDiag(myCell) {
    say("B1 PH=" + _bossPhase + " CC=" + _myCrystalCell + " EID=" + _bossTargetEID + " me=" + myCell + " cr=" + count(mapKeys(_crystalMap)))
}

// Check if any entity blocks the line between two cells (for LINE chips like GRAPPLE)
function hasEntityBlockingLine(fromCell, toCell) {
    var dTotal = getCellDistance(fromCell, toCell)
    if (dTotal == null || dTotal <= 1) return false

    // Check all enemies (crystals, graal, other boss entities)
    var enemies = getAliveEnemies()
    for (var eid in enemies) {
        if (eid == _bossTargetEID) continue  // Skip the target crystal itself
        var eCell = getCell(eid)
        if (eCell == fromCell || eCell == toCell) continue
        if (isOnSameLine(fromCell, eCell) && isOnSameLine(eCell, toCell)) {
            var d1 = getCellDistance(fromCell, eCell)
            var d2 = getCellDistance(eCell, toCell)
            if (d1 + d2 == dTotal) return true
        }
    }

    // Check allies (our own leeks also block the line)
    var allies = getAliveAllies()
    for (var aid in allies) {
        var aCell = getCell(aid)
        if (aCell == fromCell || aCell == toCell) continue
        if (isOnSameLine(fromCell, aCell) && isOnSameLine(aCell, toCell)) {
            var d1 = getCellDistance(fromCell, aCell)
            var d2 = getCellDistance(aCell, toCell)
            if (d1 + d2 == dTotal) return true
        }
    }

    return false
}

// =========================================================================
// === Greedy Crystal Movement Engine ===
// =========================================================================
//
// Diamond grid diagonal directions have CONSTANT step sizes:
//   +18 (SE): X+1, Y unchanged
//   -18 (NW): X-1, Y unchanged
//   +17 (SW): Y+1, X unchanged
//   -17 (NE): Y-1, X unchanged
//
// LINE chips (GRAPPLE/BOXING_GLOVE) only work along these diagonals.
// Stand positions MUST be found by walking along diagonals from the crystal,
// NOT by offsetting getCellFromXY coordinates (which may land off-diagonal).
//
// GRAPPLE: caster beyond target, target between caster and entity. Entity pulled to target.
// BOXING_GLOVE: entity between caster and target. Entity pushed to target. Min range 2.

// Take one diagonal step, validating against grid-edge wrapping.
// The diamond grid alternates 18/17-cell rows; raw arithmetic can wrap
// from the right edge to the left edge (or vice versa). We detect this
// by verifying the stepped cell is actually adjacent (distance 1).
function diagNext(cell, step) {
    var next = cell + step
    if (next < 0 || next > 612) return -1
    if (getCellDistance(cell, next) != 1) return -1  // wrapped around grid edge
    return next
}

// Walk along a diagonal from startCell. Returns cell after numSteps, or -1 if blocked/wrapped.
function walkDiag(startCell, step, numSteps) {
    var cell = startCell
    for (var i = 0; i < numSteps; i++) {
        cell = diagNext(cell, step)
        if (cell == -1) return -1
    }
    return cell
}

// Find BOXING_GLOVE stand: walk from crystal in OPPOSITE direction of move.
// Returns cell at distance 2-8 from crystal on the diagonal, or -1.
// Prefers myCell if it's a valid stand (avoids wasting MP on repositioning).
function findBoxStand(crystalCell, step, myCell) {
    var pos = crystalCell
    var firstStand = -1
    var myCellValid = false
    for (var k = 1; k <= 8; k++) {
        var next = diagNext(pos, -step)  // opposite direction
        if (next == -1) break  // out of bounds or wrapped
        pos = next
        if (isObstacle(pos)) break
        if (pos != myCell && isEntity(pos)) break
        if (k >= 2) {
            if (firstStand == -1) firstStand = pos
            if (pos == myCell) { myCellValid = true; break }
        }
    }
    if (myCellValid) return myCell
    return firstStand
}

// Find GRAPPLE stand: walk from targetCell in SAME direction as move (beyond target).
// Crystal must be within range 1-8 from stand.
// Prefers myCell if it's a valid stand (avoids wasting MP on repositioning).
function findGrapStand(targetCell, step, crystalSteps, myCell) {
    var pos = targetCell
    var firstStand = -1
    var myCellValid = false
    for (var j = 1; j <= 8 - crystalSteps; j++) {
        var next = diagNext(pos, step)  // beyond target
        if (next == -1) break  // out of bounds or wrapped
        pos = next
        if (isObstacle(pos)) break
        if (pos != myCell && isEntity(pos)) break
        if (firstStand == -1) firstStand = pos
        if (pos == myCell) { myCellValid = true; break }
    }
    if (myCellValid) return myCell
    return firstStand
}

// Find the best chip move for a crystal. Evaluates all 4 diagonal directions,
// picks the move that maximizes Manhattan distance reduction.
// excludeStep: if nonzero, skip that direction (prevents oscillation).
// Returns null if no viable move, else ['stand', 'chip', 'target', 'score', 'step'].
function findBestChipMove(crystalCell, finalDest, myCell, grapUsed, boxUsed, excludeStep) {
    var crystalX = getCellX(crystalCell)
    var crystalY = getCellY(crystalCell)
    var fx = getCellX(finalDest)
    var fy = getCellY(finalDest)
    var dx = fx - crystalX
    var dy = fy - crystalY
    var curManhattan = abs(dx) + abs(dy)

    var steps = [18, -18, 17, -17]
    var sdxs = [1, -1, 0, 0]
    var sdys = [0, 0, 1, -1]

    var bestScore = -999
    var bestStand = -1
    var bestChip = null
    var bestTarget = -1
    var bestNavDist = 999
    var bestStep = 0

    for (var si = 0; si < 4; si++) {
        var step = steps[si]
        var sdx = sdxs[si]
        var sdy = sdys[si]

        // Skip excluded direction (prevents oscillation — don't fire opposite to locked direction)
        if (excludeStep != 0 && step == excludeStep) continue

        // Walk along this diagonal from crystal — find max clear distance
        var maxClear = 0
        var pos = crystalCell
        for (var d = 1; d <= 8; d++) {
            var next = diagNext(pos, step)
            if (next == -1) break  // out of bounds or wrapped
            pos = next
            if (isObstacle(pos)) break
            if (pos == _graalCell) break
            if (pos != finalDest && isEntity(pos)) break
            maxClear = d
        }
        if (maxClear == 0) continue

        // Find optimal move distance (most improvement in Manhattan distance)
        var bestD = 0
        var bestImprove = -999
        for (var d = 1; d <= maxClear; d++) {
            var newManhattan = abs(dx - sdx * d) + abs(dy - sdy * d)
            var improve = curManhattan - newManhattan
            if (improve > bestImprove) {
                bestImprove = improve
                bestD = d
            }
        }
        if (bestD == 0 || bestImprove <= 0) continue

        // Prevent pushing crystal to wrong side of graal (dead-end trap):
        // If the move lands on graal's axis line on the wrong side, the graal
        // blocks further movement toward the correct side. Clamp distance.
        var newCX = crystalX + sdx * bestD
        var newCY = crystalY + sdy * bestD
        var goalAxis = _myCrystalGoalAxis
        var trapped = false
        if (goalAxis == "north" && newCX == _graalX && newCY >= _graalY) trapped = true
        if (goalAxis == "south" && newCX == _graalX && newCY <= _graalY) trapped = true
        if (goalAxis == "east" && newCY == _graalY && newCX <= _graalX) trapped = true
        if (goalAxis == "west" && newCY == _graalY && newCX >= _graalX) trapped = true
        if (trapped) {
            bestD = bestD - 1
            if (bestD <= 0) continue
            bestImprove = curManhattan - (abs(dx - sdx * bestD) + abs(dy - sdy * bestD))
            if (bestImprove <= 0) continue
            newCX = crystalX + sdx * bestD
            newCY = crystalY + sdy * bestD
        }

        var targetCell = crystalCell + step * bestD

        // Try BOXING_GLOVE (stand behind crystal, push toward target)
        if (boxUsed < 4) {
            var boxStand = findBoxStand(crystalCell, step, myCell)
            if (boxStand != -1) {
                var dBox = getCellDistance(myCell, boxStand)
                if (bestImprove > bestScore || (bestImprove == bestScore && dBox < bestNavDist)) {
                    bestScore = bestImprove
                    bestStand = boxStand
                    bestChip = CHIP_BOXING_GLOVE
                    bestTarget = targetCell
                    bestNavDist = dBox
                    bestStep = step
                }
            }
        }

        // Try GRAPPLE (stand beyond target, pull crystal to target)
        if (grapUsed < 4) {
            var grapStand = findGrapStand(targetCell, step, bestD, myCell)
            if (grapStand != -1) {
                var dGrap = getCellDistance(myCell, grapStand)
                if (bestImprove > bestScore || (bestImprove == bestScore && dGrap < bestNavDist)) {
                    bestScore = bestImprove
                    bestStand = grapStand
                    bestChip = CHIP_GRAPPLE
                    bestTarget = targetCell
                    bestNavDist = dGrap
                    bestStep = step
                }
            }
        }
    }

    if (bestStand == -1) return null
    return ['stand': bestStand, 'chip': bestChip, 'target': bestTarget, 'score': bestScore, 'step': bestStep]
}

// BFS flood-fill from graal to get all enclave cells (blocking bottleneck 374/391).
function getEnclaveCells() {
    var visited = [:]
    var queue = [_graalCell]
    visited[_graalCell] = true
    visited[374] = true
    visited[391] = true
    var idx = 0
    while (idx < count(queue)) {
        var cell = queue[idx]
        idx++
        var steps = [17, -17, 18, -18]
        for (var s in steps) {
            var next = cell + s
            if (next < 0 || next > 612) continue
            if (mapContainsKey(visited, next)) continue
            if (getCellDistance(cell, next) != 1) continue
            if (isObstacle(next)) continue
            visited[next] = true
            push(queue, next)
        }
    }
    return queue
}

// Find nearest enclave cell to walk toward (no range limit).
function findNearestEnclaveCell(myCell) {
    var enclave = getEnclaveCells()
    var bestCell = -1
    var bestDist = 999
    for (var cell in enclave) {
        var d = getCellDistance(myCell, cell)
        if (d < bestDist) {
            bestDist = d
            bestCell = cell
        }
    }
    return bestCell
}

// Find an open cell INSIDE the enclave to teleport to.
// Picks cell closest to our crystal within teleport range (1-12) of us.
function findTeleportTarget(crystalCell, myCell) {
    var queue = getEnclaveCells()

    // Find enclave cell closest to crystal within teleport range
    var bestCell = -1
    var bestDist = 999
    for (var cell in queue) {
        if (isEntity(cell)) continue
        var dFromMe = getCellDistance(myCell, cell)
        if (dFromMe < 1 || dFromMe > 12) continue
        var dFromCrystal = getCellDistance(crystalCell, cell)
        if (dFromCrystal < bestDist) {
            bestDist = dFromCrystal
            bestCell = cell
        }
    }
    return bestCell
}

// Execute PUZZLE actions — multi-chip greedy crystal movement.
//
// Turn sequence:
// 1. Teleport into crystal enclave if too far to walk (CHIP_TELEPORTATION, 9 TP)
// 2. Buff MP with Leather Boots if available (3 TP)
// 3. Fire up to 8 chips (4 GRAPPLE + 4 BOXING_GLOVE) in a loop
function logMapLayout() {
    var obstacles = getObstacles()
    var obsSet = [:]
    for (var o in obstacles) {
        obsSet[o] = true
    }
    var cellId = 0
    for (var row = 0; row < 35; row++) {
        var rowSize = (row % 2 == 0) ? 18 : 17
        var line = ""
        if (row % 2 != 0) line += "   "  // indent odd rows (17 cells)
        for (var col = 0; col < rowSize; col++) {
            if (mapContainsKey(obsSet, cellId)) {
                line += "  X  "
            } else {
                if (cellId < 10) line += "  " + cellId + "  "
                else if (cellId < 100) line += " " + cellId + "  "
                else line += " " + cellId + " "
            }
            cellId++
        }
        debug(line)
    }
}

function executePuzzleTurn() {
    // Turn 1 map dump — only first leek logs to avoid spam
    if (getTurn() == 1) {
        var allA = []
        push(allA, getEntity())
        var als = getAliveAllies()
        for (var a in als) push(allA, a)
        sort(allA)
        if (allA[0] == getEntity()) logMapLayout()
    }

    if (_myCrystalCell == -1 || _bossTargetEID == null) {
        say("PZ: no crystal")
        return false
    }

    // Use adjacent cell as pathfinding target (ensures correct side of graal),
    // but the "done" check below uses axis+LoS so we stop early once aligned.
    var finalDest = computeCrystalFinalDest()
    if (finalDest == null) {
        say("PZ: no dest")
        moveTowardCell(_myCrystalCell)
        return true
    }
    // Check if already solved: on correct axis + LoS to graal
    if (isCrystalOnAxis() && lineOfSight(_myCrystalCell, _graalCell)) {
        say("PZ DONE c=" + _bossTargetEID)
        _bossTargetEID = null
        return true
    }

    var myCell = getCell()
    var myID = getEntity()

    // === Phase 0: Teleport into crystal enclave (always, boss PUZZLE) ===
    // Crystals are behind walls — getCellDistance ignores walls, so distance
    // checks are misleading. Always teleport when available to reach the enclave ASAP.
    var crystalCell0 = getCell(_bossTargetEID)
    if (crystalCell0 != null && crystalCell0 >= 0) {
        var tpCd = getCooldown(CHIP_TELEPORTATION, myID)
        if (tpCd != null && tpCd == 0 && getTP() >= 12) {
            var tpDone = false
            // Strategy 1: teleport directly to optimal chip-firing stand
            var preMove = findBestChipMove(crystalCell0, finalDest, myCell, 0, 0, 0)
            if (preMove != null) {
                var preStand = preMove['stand']
                var dToStand = getCellDistance(myCell, preStand)
                if (dToStand >= 1 && dToStand <= 12) {
                    if (useChipOnCell(CHIP_TELEPORTATION, preStand) == 1) {
                        myCell = getCell()
                        tpDone = true
                    }
                }
            }
            // Strategy 2: teleport to any enclave cell near crystal
            if (!tpDone) {
                var tpTarget = findTeleportTarget(crystalCell0, myCell)
                if (tpTarget != -1) {
                    if (useChipOnCell(CHIP_TELEPORTATION, tpTarget) == 1) {
                        myCell = getCell()
                        tpDone = true
                    }
                }
            }
            // Strategy 3: out of range — walk toward nearest enclave cell, then retry
            if (!tpDone) {
                var nearest = findNearestEnclaveCell(myCell)
                if (nearest != -1) {
                    moveTowardCell(nearest)
                    myCell = getCell()
                    // Retry teleport from closer position
                    var tpTarget2 = findTeleportTarget(crystalCell0, myCell)
                    if (tpTarget2 != -1) {
                        if (useChipOnCell(CHIP_TELEPORTATION, tpTarget2) == 1) {
                            myCell = getCell()
                        }
                    }
                }
                return true  // consumed the turn walking toward enclave
            }
        } else if (tpCd != null && tpCd > 0) {
            // Teleport on cooldown — only wait if far from crystal (outside enclave).
            // If already near crystal (inside enclave), fall through to chip loop.
            var dToCrystal = getCellDistance(myCell, crystalCell0)
            if (dToCrystal > 10) { return true; }
            // Otherwise fall through to Phase 1 + Phase 2
        }
    }

    // === Phase 1: Buff MP with Leather Boots (+2 MP for 2 turns, 3 TP) ===
    var bootsCd = getCooldown(CHIP_LEATHER_BOOTS, myID)
    if (bootsCd != null && bootsCd == 0 && getTP() >= 6) {
        useChip(CHIP_LEATHER_BOOTS, myID)
    }

    // === Phase 2: Multi-chip loop ===
    var grapUsed = 0
    var boxUsed = 0
    var chipsFired = 0
    var lockedStep = 0  // after first fire, exclude opposite direction to prevent oscillation

    while (chipsFired < 8) {
        // Refresh crystal position after each move
        var crystalCell = getCell(_bossTargetEID)
        if (crystalCell == null || crystalCell < 0) break

        // Check if done: on correct axis + LoS to graal
        var crX = getCellX(crystalCell)
        var crY = getCellY(crystalCell)
        var onAx = false
        var ax = _myCrystalGoalAxis
        if (ax == "north") onAx = (crX == _graalX && crY < _graalY)
        else if (ax == "south") onAx = (crX == _graalX && crY > _graalY)
        else if (ax == "east") onAx = (crY == _graalY && crX > _graalX)
        else if (ax == "west") onAx = (crY == _graalY && crX < _graalX)
        if (onAx && lineOfSight(crystalCell, _graalCell)) break

        // Check TP (both chips cost 3)
        if (getTP() < 3) break

        myCell = getCell()

        // Find best move (exclude opposite of locked direction to prevent oscillation)
        var move = findBestChipMove(crystalCell, finalDest, myCell, grapUsed, boxUsed, lockedStep)
        if (move == null) break

        var stand = move['stand']
        var chip = move['chip']
        var target = move['target']

        // Navigate to stand (may use MP)
        if (myCell != stand) {
            if (getMP() == 0) break  // no MP to navigate
            var prevCell = myCell
            moveTowardCell(stand)
            myCell = getCell()
            if (myCell == prevCell) break  // blocked, no progress possible
            if (myCell != stand) continue  // partial progress, re-evaluate next iteration
        }

        // Fire chip
        var r = useChipOnCell(chip, target)
        if (r != 1) break  // failed

        chipsFired++
        if (chip == CHIP_GRAPPLE) grapUsed++
        else boxUsed++

        // Lock direction: exclude opposite step to prevent push-then-pull oscillation
        if (lockedStep == 0) {
            var firedStep = move['step']
            lockedStep = -firedStep  // exclude the OPPOSITE direction
        }
    }

    // Diagnostic (1 say per turn from this function)
    var crCell = getCell(_bossTargetEID)
    var solved = false
    if (crCell != null && crCell >= 0) {
        var scX = getCellX(crCell)
        var scY = getCellY(crCell)
        var scAx = _myCrystalGoalAxis
        if (scAx == "north") solved = (scX == _graalX && scY < _graalY)
        else if (scAx == "south") solved = (scX == _graalX && scY > _graalY)
        else if (scAx == "east") solved = (scY == _graalY && scX > _graalX)
        else if (scAx == "west") solved = (scY == _graalY && scX < _graalX)
        if (solved) solved = lineOfSight(crCell, _graalCell)
    }
    if (solved) {
        say("PZ DONE c=" + _bossTargetEID + " f=" + chipsFired)
        _bossTargetEID = null
    } else {
        say("PZ f=" + chipsFired + " cr=" + crCell + " dst=" + finalDest)
    }

    // Follow crystal with remaining MP / deadlock self-clearing
    if (chipsFired > 0 && crCell != null && crCell >= 0) {
        moveTowardCell(crCell)
    } else if (chipsFired == 0) {
        // Check if we're adjacent to crystal and blocking its path — step aside
        var crystalNow = getCell(_bossTargetEID)
        if (crystalNow != null && crystalNow >= 0 && getCellDistance(myCell, crystalNow) <= 1) {
            // Move toward destination to clear the crystal's diagonal
            moveTowardCell(finalDest)
        } else {
            moveTowardCell(_myCrystalCell)
        }
    }

    return true
}

// Boss PUZZLE target selection — keeps all crystal map access in boss_context.lk
function getBossPuzzleTarget(fieldMapObj) {
    if (_bossTargetEID == null) return null

    var enemySub = fieldMapObj.getEnemySubMap()
    if (mapContainsKey(enemySub, _bossTargetEID)) {
        return enemySub[_bossTargetEID]
    }
    if (mapContainsKey(fieldMapObj.entities, _bossTargetEID)) {
        return fieldMapObj.entities[_bossTargetEID]
    }
    // Fallback: create minimal Enemy at crystal cell
    if (_myCrystalCell != -1) {
        return new Enemy(_myCrystalCell)
    }
    return null
}
