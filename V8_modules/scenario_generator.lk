/** Scenario Generator - Creates multiple scenario variants for evaluation **/

// Parametric scenario configuration
class ScenarioParams {
    buffStrategy = 0       // 0=none, 1=offensive, 2=defensive, 3=both, 4=build-specific (AGI:dmgReturn, STR:LIBERATION)
    healThreshold = -1     // -1=never, 0.0-1.0=heal if HP% below threshold
    movementFraction = 1.0 // 0.0-1.0 = % of MP to use for movement
    attackFraction = 1.0   // DEPRECATED: Now always uses 100% of remaining TP (maximizes damage output)
    repositioning = "hide" // "hide", "kite", "stand", "otko"

    constructor(buffStrat, healThr, moveFrac, attackFrac, reposition) {
        this.buffStrategy = buffStrat
        this.healThreshold = healThr
        this.movementFraction = moveFrac
        this.attackFraction = attackFrac  // Kept for compatibility, but ignored in attack phase
        this.repositioning = reposition
    }
}

class ScenarioGenerator {
    _arsenal = null
    _player = null
    _target = null
    _fieldMap = null
    _strategy = null

    // Cache for expensive operations (computed once, reused across scenarios)
    _moveCache = [:]     // Cached move actions by MP budget (MAP not array)
    _hideCache = null    // Cached hide action
    _kiteCache = null    // Cached kite action

    // CONFIGURATION: Set to false to disable state-based filtering (generates all scenarios)
    static USE_STATE_BASED_SCENARIOS = true  // Re-enabled state-based scenarios

    constructor(arsenal, player, target, fieldMap, strategy) {
        this._arsenal = arsenal
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
        this._strategy = strategy
        this._moveCache = [:]  // Initialize as map
    }

    // STATE-BASED SCENARIO GENERATION (2-4 scenarios per state)
    // Reduces operations from 1-4M to 200-400K per turn (~75% reduction)
    // Returns array of scenarios (each scenario is an array of actions)
    generateScenarios() {
        var scenarios = []
        var availableTP = getTP()
        var availableMP = getMP()

        // PHASE 1: Determine strategic state (~10-20K ops)
        var state = this.determineStrategicState()
        debug("[STATE] Strategic state: " + state)

        // PHASE 2: Generate scenarios for detected state only
        // ScenarioParams(buffStrategy, healThreshold, movementFraction, attackFraction, repositioning)
        // buffStrategy: 0=none, 1=offensive, 2=defensive, 3=both, 4=build-specific

        if (state == "KILL") {
            // Enemy HP < 40% AND we can OTKO → use OTKO cells for optimal positioning
            debug("[STATE-KILL] Enemy killable - checking OTKO cells for optimal positioning")

            // COMBO SCENARIO 1: Neutrino pre-stack + Teleport OTKO (highest damage)
            var neutrinoOTKO = this.createNeutrinoOTKOScenario(availableTP, availableMP)
            if (neutrinoOTKO != null) {
                debug("[STATE-KILL] Adding Neutrino-OTKO combo scenario")
                push(scenarios, neutrinoOTKO)
            }

            // Check if we have OTKO cells and teleportation available
            var bestOTKO = this._fieldMap.getBestOTKOCell()
            var hasTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)
            var teleportReady = hasTeleport && getCooldown(CHIP_TELEPORTATION, player._id) == 0

            if (bestOTKO != null && teleportReady && availableTP >= 15) {
                // SCENARIO 2: Teleport to OTKO cell + burst (best positioning for kill)
                var distToOTKO = getCellDistance(player._cellPos, bestOTKO._id)
                if (distToOTKO != null && distToOTKO >= 1 && distToOTKO <= 12) {
                    debug("[STATE-KILL] Teleporting to OTKO cell " + bestOTKO._id +
                          " (kill prob=" + floor(bestOTKO._otkoKillProbability * 100) + "%)")
                    push(scenarios, this.createOTKOTeleportScenario(bestOTKO._id, availableTP, availableMP))
                }
            }

            // SCENARIO 3: Burst from current position (fallback if no teleport or OTKO cell)
            push(scenarios, this.createParametricScenario(new ScenarioParams(4, -1, 1.0, 1.0, "otko"), availableTP, availableMP))
            push(scenarios, this.createParametricScenario(new ScenarioParams(0, -1, 1.0, 1.0, "stand"), availableTP, availableMP))

            // BASELINE scenarios (insurance against combo failures)
            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }
        else if (state == "AGGRO") {
            // Both HP > 60%, turn 1-4, OR buffs expired → apply buffs + attack
            debug("[STATE-AGGRO] Early game / buff application phase")

            // COMBO SCENARIO 1: GRAPPLE-HEAVY_SWORD (early aggression)
            var grappleHS = this.createGrappleHeavySwordScenario(availableTP, availableMP)
            if (grappleHS != null) {
                debug("[STATE-AGGRO] Adding GRAPPLE-HEAVY_SWORD combo scenario")
                push(scenarios, grappleHS)
            }

            // COMBO SCENARIO 2: Neutrino stacking (establish vulnerability early)
            var neutrinoStack = this.createNeutrinoStackingScenario(availableTP, availableMP)
            if (neutrinoStack != null) {
                debug("[STATE-AGGRO] Adding Neutrino stacking combo scenario")
                push(scenarios, neutrinoStack)
            }

            // COMBO SCENARIO 3: STEROID → OTKO (check if buff enables kill)
            var steroidOTKO = this.createSteroidOTKOScenario(availableTP, availableMP)
            if (steroidOTKO != null) {
                debug("[STATE-AGGRO] Adding STEROID-OTKO combo scenario")
                push(scenarios, steroidOTKO)
            }

            // COMBO SCENARIO 3B: STEROID → Recheck (two-phase adaptive)
            var steroidRecheck = this.createSteroidRecheckScenario(availableTP, availableMP)
            if (steroidRecheck != null) {
                debug("[STATE-AGGRO] Adding STEROID-Recheck two-phase scenario")
                push(scenarios, steroidRecheck)
            }

            // Standard scenarios
            push(scenarios, this.createParametricScenario(new ScenarioParams(4, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  // Build-specific buff
            push(scenarios, this.createParametricScenario(new ScenarioParams(1, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  // Offensive buff
            push(scenarios, this.createParametricScenario(new ScenarioParams(0, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  // No buff (save TP)

            // PREEMPTIVE SHIELD: Apply defensive buffs early to reduce incoming damage
            // Reduces damage taken → increases effective HP → survive longer
            push(scenarios, this.createParametricScenario(new ScenarioParams(2, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  // Defensive buff (FORTRESS/WALL)

            // BASELINE scenarios (always executable - insurance against combo failures)
            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))  // Move + attack
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))  // Attack from current position
        }
        else if (state == "ATTRITION") {
            // Both HP 40-80%, turn 5+, buffs active → balanced combat
            debug("[STATE-ATTRITION] Ongoing balanced combat")

            // DEFENSIVE ATTRITION: If losing HP race, prioritize heal+attack hybrids
            var playerHP = this._player._currHealth
            var enemyHP = this._target._currHealth
            var losingHPRace = (playerHP < enemyHP)

            if (losingHPRace) {
                debug("[STATE-ATTRITION] Losing HP race (" + playerHP + " < " + enemyHP + ") - adding defensive scenarios")
                // Add heal+attack hybrid scenarios
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.7, 0.7, 0.7, "hide"), availableTP, availableMP))  // Heal + 70% attack
                push(scenarios, this.createParametricScenario(new ScenarioParams(3, 0.5, 0.8, 0.8, "hide"), availableTP, availableMP))  // Mixed buffs + some heal
            }

            // COMBO SCENARIO 1: GRAPPLE-HEAVY_SWORD (pull + burst damage)
            var grappleHS = this.createGrappleHeavySwordScenario(availableTP, availableMP)
            if (grappleHS != null) {
                debug("[STATE-ATTRITION] Adding GRAPPLE-HEAVY_SWORD combo scenario")
                push(scenarios, grappleHS)
            }

            // COMBO SCENARIO 2: Neutrino stacking (if not already maxed)
            var neutrinoStack = this.createNeutrinoStackingScenario(availableTP, availableMP)
            if (neutrinoStack != null) {
                debug("[STATE-ATTRITION] Adding Neutrino stacking combo scenario")
                push(scenarios, neutrinoStack)
            }

            // COMBO SCENARIO 3: STEROID → OTKO (check if enemy weakened enough)
            var steroidOTKO = this.createSteroidOTKOScenario(availableTP, availableMP)
            if (steroidOTKO != null) {
                debug("[STATE-ATTRITION] Adding STEROID-OTKO combo scenario")
                push(scenarios, steroidOTKO)
            }

            // CHECKPOINT SCENARIO 1: Neutrino → Recheck (adaptive vulnerability stacking)
            var neutrinoRecheck = this.createNeutrinoRecheckScenario(availableTP, availableMP)
            if (neutrinoRecheck != null) {
                debug("[STATE-ATTRITION] Adding Neutrino-Recheck checkpoint scenario")
                push(scenarios, neutrinoRecheck)
            }

            // CHECKPOINT SCENARIO 2: GRAPPLE-HS → Recheck (adaptive pull combo)
            var grappleHSRecheck = this.createGrappleHSRecheckScenario(availableTP, availableMP)
            if (grappleHSRecheck != null) {
                debug("[STATE-ATTRITION] Adding GRAPPLE-HS-Recheck checkpoint scenario")
                push(scenarios, grappleHSRecheck)
            }

            // Standard scenarios
            push(scenarios, this.createParametricScenario(new ScenarioParams(4, -1, 0.8, 0.8, "hide"), availableTP, availableMP))  // Build-specific + 80%
            push(scenarios, this.createParametricScenario(new ScenarioParams(3, -1, 0.8, 0.8, "hide"), availableTP, availableMP))  // Mixed buffs + 80%
            push(scenarios, this.createParametricScenario(new ScenarioParams(0, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  // Pure damage spam

            // BASELINE scenarios
            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }
        else if (state == "SUSTAIN") {
            // Our HP 30-60%, enemy HP > 40% → heal + conservative (3 scenarios)
            debug("[STATE-SUSTAIN] HP management phase")

            // CHECKPOINT SCENARIO: Heal → Recheck (adaptive healing strategy)
            var healRecheck = this.createHealRecheckScenario(availableTP, availableMP)
            if (healRecheck != null) {
                debug("[STATE-SUSTAIN] Adding Heal-Recheck checkpoint scenario")
                push(scenarios, healRecheck)
            }

            push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.7, 0.6, 0.6, "hide"), availableTP, availableMP))  // Heal + shield + 60%
            push(scenarios, this.createParametricScenario(new ScenarioParams(4, 0.7, 0.6, 0.6, "kite"), availableTP, availableMP))  // Build-specific + heal + kite
            push(scenarios, this.createParametricScenario(new ScenarioParams(3, -1, 0.6, 0.6, "hide"), availableTP, availableMP))  // Mixed buffs + 60%

            // BASELINE scenarios
            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }
        else if (state == "FLEE") {
            // Our HP < 30% → heal + lifesteal strategy
            debug("[STATE-FLEE] Emergency survival mode")

            // DEFENSIVE TELEPORT: Escape to safe cell if available
            // Analysis: Need to reduce damage taken (38% more in losses)
            var hasTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)
            var teleportReady = hasTeleport && getCooldown(CHIP_TELEPORTATION, player._id) == 0

            if (teleportReady) {
                // Check if we're in danger (high threat at current position)
                var currentThreat = this._fieldMap.getThreatAtCell(player._cellPos)
                if (currentThreat > 200) {
                    debug("[STATE-FLEE] High threat detected (" + currentThreat + ") - prioritizing TELEPORT escape")
                    var escapeScenario = this.createTeleportEscapeScenario(availableTP, availableMP)
                    if (escapeScenario != null) {
                        push(scenarios, escapeScenario)
                    }
                }
            }

            // Check if REGENERATION is available (critical for survival strategy)
            var hasRegen = mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)
            var regenAvailable = hasRegen && getCooldown(CHIP_REGENERATION, player._id) == 0

            if (regenAvailable) {
                // REGENERATION available → use it + REMISSION + minimal attack + hide
                debug("[STATE-FLEE] REGENERATION available - defensive healing")
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 1.0, 0.2, 0.2, "hide"), availableTP, availableMP))  // Both heals + hide
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 1.0, 0.3, 0.2, "kite"), availableTP, availableMP))  // Both heals + kite
            } else {
                // REGENERATION on cooldown → REMISSION + spam ENHANCED_LIGHTNINGER (lifesteal healing)
                debug("[STATE-FLEE] REGENERATION on cooldown - lifesteal strategy (ENHANCED_LIGHTNINGER spam)")
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.7, 0.5, 1.0, "kite"), availableTP, availableMP))  // REMISSION + 100% attack (lifesteal)
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.5, 0.3, 1.0, "kite"), availableTP, availableMP))  // Aggressive lifesteal
            }

            // BASELINE scenarios (even in FLEE, need attack options)
            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }

        return scenarios
    }

    // ====================================================================
    // STRATEGIC STATE DETECTION (~10-20K ops)
    // ====================================================================

    // Determine which strategic state we're in based on HP, buffs, turn, OTKO opportunity
    // Returns: "KILL", "AGGRO", "ATTRITION", "SUSTAIN", or "FLEE"
    determineStrategicState() {
        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth

        var playerHPPercent = (playerHP * 100) / playerMaxHP
        var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

        var currentTurn = getTurn()
        var availableTP = getTP()

        // STATE 1: FLEE (our HP < 30%) - highest priority
        if (playerHPPercent < 30) {
            return "FLEE"
        }

        // STATE 2: KILL (enemy HP < 40% AND we can OTKO)
        if (enemyHPPercent < 40) {
            // Check if we have OTKO opportunity
            var estimatedDamage = this.estimateMaxDamageThisTurn(availableTP)
            var killProbability = estimatedDamage / enemyHP

            // LOWERED from 0.85 to 0.75 - more aggressive finisher
            // Analysis: Losses last 1.2 turns longer and take 38% more damage
            // Being too cautious in endgame lets enemy come back
            if (killProbability >= 0.75) {
                return "KILL"
            }
        }

        // STATE 3: SUSTAIN (our HP 30-50%, enemy HP > 40%)
        // NARROWED from 70% to 50% - only heal when HP is actually critical
        // Analysis: Losses spam REMISSION 5.6x more than wins (too reactive)
        // Strategy: Stay aggressive longer, only sustain when HP truly low
        if (playerHPPercent >= 30 && playerHPPercent <= 50 && enemyHPPercent > 40) {
            return "SUSTAIN"
        }

        // STATE 4: AGGRO (early game OR buffs expired)
        // Check if we're in early game (turn 1-4) OR critical buffs expired
        // UPDATED: Changed from > 70% to > 50% to match new SUSTAIN threshold
        // This allows AGGRO state when HP is 50-100% (more aggressive overall)
        var earlyGame = (currentTurn >= 1 && currentTurn <= 4)
        var buffsExpired = this.checkCriticalBuffsExpired()

        if ((earlyGame || buffsExpired) && playerHPPercent > 50 && enemyHPPercent > 60) {
            return "AGGRO"
        }

        // STATE 5: ATTRITION (default - ongoing balanced combat)
        // Both HP 40-80%, turn 5+, buffs active
        return "ATTRITION"
    }

    // Check if critical build-specific buffs have expired and need reapplication
    checkCriticalBuffsExpired() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Strength builds: Check STEROID (most important buff)
        if (str > mag && str > agi) {
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
                var steroidActive = getCooldown(CHIP_STEROID, this._player._id) > 0
                if (!steroidActive) {
                    return true  // STEROID available but not active
                }
            }
        }

        // Agility builds: Check damage return (MIRROR/THORN/BRAMBLE)
        else if (agi > str && agi > mag) {
            var hasReturn = this._player.hasDamageReturn()
            if (!hasReturn) {
                // Check if any damage return chip is available
                var mirrorAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR) &&
                                     getCooldown(CHIP_MIRROR, this._player._id) == 0
                var thornAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN) &&
                                    getCooldown(CHIP_THORN, this._player._id) == 0
                var brambleAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE) &&
                                      getCooldown(CHIP_BRAMBLE, this._player._id) == 0

                if (mirrorAvailable || thornAvailable || brambleAvailable) {
                    return true  // Damage return available but not active
                }
            }
        }

        // Check shield expiration (all builds benefit from shields)
        var hasShield = this._player.hasEffect(EFFECT_RELATIVE_SHIELD)
        if (!hasShield) {
            var fortressAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_FORTRESS) &&
                                   getCooldown(CHIP_FORTRESS, this._player._id) == 0
            var wallAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_WALL) &&
                               getCooldown(CHIP_WALL, this._player._id) == 0

            if (fortressAvailable || wallAvailable) {
                return true  // Shield available but not active
            }
        }

        return false  // All critical buffs either active or unavailable
    }

    // ====================================================================
    // PREDEFINED SCENARIO CONSTRUCTORS (Legacy - for reference)
    // ====================================================================

    // SCENARIO 1: Aggressive - buff, move close, spam damage, hide (BUILD-AWARE)
    createAggressiveScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  // Track simulated position

        // 1. Apply offensive buff (if not already active)
        var buffAction = this.getOffensiveBuff()
        if (buffAction != null) {
            push(actions, buffAction)
            tpBudget -= getCachedChipCost(buffAction.chip)
        }

        // 2. AGI-specific: Apply damage return buff
        var damageReturnAction = this.getDamageReturnBuff()
        if (damageReturnAction != null && tpBudget >= getCachedChipCost(damageReturnAction.chip)) {
            push(actions, damageReturnAction)
            tpBudget -= getCachedChipCost(damageReturnAction.chip)
        }

        // 3. STR-specific: Strip enemy buffs with LIBERATION
        var debuffAction = this.getDebuffAction()
        if (debuffAction != null && tpBudget >= 4) {
            push(actions, debuffAction)
            tpBudget -= 4
        }

        // 4. Move to best damage cell
        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
            if (moveCost != null) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  // Update simulated position!
            }
        }

        // 5. Spam weapons + damage chips (aggressive) - use simulated position
        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // 6. Hide and seek repositioning
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // SCENARIO 2: Conservative - buff, careful movement, moderate damage, hide (BUILD-AWARE)
    createConservativeScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  // Track simulated position

        // 1. Offensive buff
        var buffAction = this.getOffensiveBuff()
        if (buffAction != null) {
            push(actions, buffAction)
            tpBudget -= getCachedChipCost(buffAction.chip)
        }

        // 2. AGI-specific: Damage return buff
        var damageReturnAction = this.getDamageReturnBuff()
        if (damageReturnAction != null && tpBudget >= getCachedChipCost(damageReturnAction.chip)) {
            push(actions, damageReturnAction)
            tpBudget -= getCachedChipCost(damageReturnAction.chip)
        }

        // 3. Defensive buff (shields)
        var defensiveBuff = this.getDefensiveBuff()
        if (defensiveBuff != null && tpBudget >= getCachedChipCost(defensiveBuff.chip)) {
            push(actions, defensiveBuff)
            tpBudget -= getCachedChipCost(defensiveBuff.chip)
        }

        // 4. Healing if injured (HP < 70%)
        var healAction = this.getHealingAction(tpBudget, 0.7)
        if (healAction != null) {
            push(actions, healAction)
            tpBudget -= getCachedChipCost(healAction.chip)
        }

        // 5. Move conservatively (not all the way)
        var moveAction = this.getMoveToOptimalCell(floor(mpBudget * 0.7))  // Use 70% of MP
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
            if (moveCost != null) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  // Update simulated position!
            }
        }

        // 6. Moderate attack usage (70% TP) - weapons + damage chips
        var attackActions = this.getAttackActions(tpBudget, 0.7, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // 7. Hide
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // SCENARIO 3: Defensive - healing → shields → conservative damage → hide
    createDefensiveScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  // Track simulated position

        // 1. PRIORITY: Healing first if injured (HP < 70%)
        var healAction = this.getHealingAction(tpBudget, 0.7)
        if (healAction != null) {
            push(actions, healAction)
            tpBudget -= getCachedChipCost(healAction.chip)
        }

        // 2. Defensive buffs (shields)
        var defensiveBuff = this.getDefensiveBuff()
        if (defensiveBuff != null && tpBudget >= getCachedChipCost(defensiveBuff.chip)) {
            push(actions, defensiveBuff)
            tpBudget -= getCachedChipCost(defensiveBuff.chip)
        }

        // 3. Minimal movement (save MP for escape)
        var moveAction = this.getMoveToOptimalCell(floor(mpBudget * 0.5))
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
            if (moveCost != null) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  // Update simulated position!
            }
        }

        // 4. Conservative attacks (50% TP) - weapons + damage chips
        var attackActions = this.getAttackActions(tpBudget, 0.5, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // 5. Hide
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // SCENARIO 4: All-in damage - OTKO variant or pure damage spam
    createAllInDamageScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  // Track simulated position

        // CHECK OTKO OPPORTUNITY: If enemy HP low, teleport and burst
        if (this.checkOTKOOpportunity()) {
            // Check if we need to teleport to get in range
            var distToTarget = getCellDistance(this._player._cellPos, this._target._cellPos)
            var maxWeaponRange = 12  // M-LASER max range

            if (distToTarget > maxWeaponRange &&
                mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                getCooldown(CHIP_TELEPORTATION, this._player._id) == 0 &&
                tpBudget >= 5) {

                var bestCell = this._fieldMap.getBestWeaponOrChipCell()
                if (bestCell != null && bestCell != -1) {
                    var teleportDist = getCellDistance(this._player._cellPos, bestCell._id)
                    if (teleportDist >= 1 && teleportDist <= 12) {
                        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestCell._id, this._target))
                        tpBudget -= 5
                        simPos = bestCell._id
                    }
                }
            }

            // Spam ALL weapons and damage chips (100% remaining TP)
            var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
            for (var atk in attackActions) {
                push(actions, atk)
            }

            return actions
        }

        // STANDARD ALL-IN: Move + spam all TP
        // 1. Move to best damage cell
        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
            if (moveCost != null) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  // Update simulated position!
            }
        }

        // 2. ALL weapons and damage chips (100% TP, no reserve)
        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // No repositioning - stand and fight

        return actions
    }

    // SCENARIO 5: Kiting - damage from range, kite away, repeat
    createKitingScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  // Track simulated position

        // 1. Attack from current position (long-range weapons + damage chips)
        var attackActions = this.getAttackActions(tpBudget, 0.6, simPos)  // 60% TP
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // 2. Kite away from enemy
        var kiteAction = this.getKiteAwayAction(mpBudget)
        if (kiteAction != null) {
            push(actions, kiteAction)
        }

        return actions
    }

    // SCENARIO 6: Efficient - minimal buffs, focused damage, hide
    createEfficientScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  // Track simulated position

        // 1. Only buff if very cost-effective
        if (tpBudget >= 30) {  // Only if we have TP to spare
            var buffAction = this.getOffensiveBuff()
            if (buffAction != null && getCachedChipCost(buffAction.chip) <= 6) {
                push(actions, buffAction)
                tpBudget -= getCachedChipCost(buffAction.chip)
            }
        }

        // 2. Move to optimal cell
        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
            if (moveCost != null) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  // Update simulated position!
            }
        }

        // 3. Balanced damage (80% TP) - weapons + damage chips
        var attackActions = this.getAttackActions(tpBudget, 0.8, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // 4. Hide
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // ========== OTKO TELEPORT SCENARIO ==========

    // OTKO Teleport Scenario: Teleport to OTKO cell + burst damage spam
    // Used in KILL state when OTKO cells are available
    createOTKOTeleportScenario(otkoCell, availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP

        // 1. Teleport to OTKO cell (5 TP)
        if (tpBudget >= 5) {
            push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, otkoCell, this._target))
            tpBudget -= 5
            debug("[OTKO-TELEPORT] Teleporting to OTKO cell " + otkoCell + " for optimal kill positioning")
        }

        // 2. Spam ALL weapons and damage chips from OTKO position (100% remaining TP)
        // Use otkoCell as simulated position for attack actions
        var attackActions = this.getAttackActions(tpBudget, 1.0, otkoCell)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // No repositioning - stand and burst damage
        return actions
    }

    // Defensive TELEPORT Escape: Emergency evacuation when HP critical
    // Teleports to safest reachable cell + heal + shield
    createTeleportEscapeScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP

        // Need minimum 5 TP for teleport
        if (tpBudget < 5) {
            return null
        }

        // Find safest cell within teleportation range (1-12)
        var safestCell = -1
        var lowestThreat = 99999
        var playerPos = this._player._cellPos

        for (var cellId in mapKeys(this._fieldMap.damageMap)) {
            var dist = getCellDistance(playerPos, cellId)
            if (dist >= 1 && dist <= 12) {
                var threat = this._fieldMap.getThreatAtCell(cellId)
                if (threat < lowestThreat) {
                    lowestThreat = threat
                    safestCell = cellId
                }
            }
        }

        if (safestCell == -1) {
            return null  // No safe cell found
        }

        // 1. Teleport to safest cell (5 TP)
        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, safestCell, this._target))
        tpBudget -= 5
        debug("[TELEPORT-ESCAPE] Evacuating to cell " + safestCell + " (threat: " + lowestThreat + ")")

        // 2. Apply REMISSION heal (4 TP)
        if (tpBudget >= 4 && mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0) {
            push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player))
            tpBudget -= 4
            debug("[TELEPORT-ESCAPE] Applying REMISSION heal")
        }

        // 3. Apply shield (FORTRESS or WALL)
        var shieldAction = this.getDefensiveBuff()
        if (shieldAction != null) {
            var shieldCost = getCachedChipCost(shieldAction.chip)
            if (tpBudget >= shieldCost) {
                push(actions, shieldAction)
                tpBudget -= shieldCost
                debug("[TELEPORT-ESCAPE] Applying shield")
            }
        }

        return actions
    }

    // ========== PARAMETRIC SCENARIO GENERATOR ==========

    // Unified parametric scenario generator - replaces 6 hardcoded functions with 1 configurable function
    createParametricScenario(params, availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        // PHASE 1: HEALING (if threshold met)
        if (params.healThreshold >= 0) {
            // Special case: healThreshold=1.0 means "use ALL healing" (REMISSION + REGENERATION)
            // Used in FLEE state when REGENERATION is available
            if (params.healThreshold >= 0.99) {
                var currentHP = this._player._currHealth
                var maxHP = this._player._maxHealth
                var hpRatio = currentHP / maxHP

                // Only heal if HP below 100%
                if (hpRatio < params.healThreshold) {
                    // Apply REMISSION first (instant heal, 5 TP)
                    var remissionAction = this.getRemissionAction()
                    if (remissionAction != null && tpBudget >= 5) {
                        push(actions, remissionAction)
                        tpBudget -= 5
                    }

                    // Then apply REGENERATION (multi-turn heal, 3 TP)
                    var regenAction = this.getRegenerationAction()
                    if (regenAction != null && tpBudget >= 3) {
                        push(actions, regenAction)
                        tpBudget -= 3
                    }
                }
            } else {
                // Normal healing: use one chip (REMISSION > REGENERATION priority)
                var healAction = this.getHealingAction(tpBudget, params.healThreshold)
                if (healAction != null) {
                    push(actions, healAction)
                    tpBudget -= getCachedChipCost(healAction.chip)
                }
            }
        }

        // PHASE 2: BUFFS (based on buffStrategy)
        if (params.buffStrategy == 1 || params.buffStrategy == 3) {
            // Offensive buff
            var offensiveBuff = this.getOffensiveBuff()
            if (offensiveBuff != null && tpBudget >= getCachedChipCost(offensiveBuff.chip)) {
                push(actions, offensiveBuff)
                tpBudget -= getCachedChipCost(offensiveBuff.chip)
            }
        }

        if (params.buffStrategy == 2 || params.buffStrategy == 3) {
            // Defensive buff
            var defensiveBuff = this.getDefensiveBuff()
            if (defensiveBuff != null && tpBudget >= getCachedChipCost(defensiveBuff.chip)) {
                push(actions, defensiveBuff)
                tpBudget -= getCachedChipCost(defensiveBuff.chip)
            }
        }

        if (params.buffStrategy == 4) {
            // Build-specific buffs (AGI: damage return, STR: LIBERATION)
            var damageReturnBuff = this.getDamageReturnBuff()
            if (damageReturnBuff != null && tpBudget >= getCachedChipCost(damageReturnBuff.chip)) {
                push(actions, damageReturnBuff)
                tpBudget -= getCachedChipCost(damageReturnBuff.chip)
            }

            var debuffAction = this.getDebuffAction()
            if (debuffAction != null && tpBudget >= 4) {
                push(actions, debuffAction)
                tpBudget -= 4
            }
        }

        // MOBILITY BUFF: LEATHER_BOOTS for low-MP builds (applies to all buffStrategy values)
        // Critical for builds with < 10 base MP - enables movement to tactical positions
        var appliedLeatherBoots = false
        var leatherBootsBuff = this.getLeatherBootsBuff()
        if (leatherBootsBuff != null && tpBudget >= 3) {
            push(actions, leatherBootsBuff)
            tpBudget -= 3
            mpBudget += 2  // Update MP budget to reflect boost (affects movement planning)
            appliedLeatherBoots = true
        }

        // TP RECOVERY: ADRENALINE after LEATHER_BOOTS (offsets mobility cost)
        // LEATHER_BOOTS + ADRENALINE combo: -3 TP + 4 TP = +1 net TP + mobility
        if (appliedLeatherBoots) {
            var adrenalineBuff = this.getAdrenalineBuff()
            if (adrenalineBuff != null && tpBudget >= 1) {
                push(actions, adrenalineBuff)
                tpBudget -= 1
                tpBudget += 5  // ADRENALINE gives +5 TP immediately (net +4)
                debug("[SCENARIO] LEATHER_BOOTS + ADRENALINE combo: Net +1 TP + mobility")
            }
        }

        // PHASE 3: OTKO TELEPORT (if repositioning == "otko")
        if (params.repositioning == "otko" && this.checkOTKOOpportunity()) {
            var distToTarget = getCellDistance(this._player._cellPos, this._target._cellPos)
            var maxWeaponRange = 12

            if (distToTarget > maxWeaponRange &&
                mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                getCooldown(CHIP_TELEPORTATION, this._player._id) == 0 &&
                tpBudget >= 5) {

                var bestCell = this._fieldMap.getBestWeaponOrChipCell()
                if (bestCell != null && bestCell != -1) {
                    var teleportDist = getCellDistance(this._player._cellPos, bestCell._id)
                    if (teleportDist >= 1 && teleportDist <= 12) {
                        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestCell._id, this._target))
                        tpBudget -= 5
                        simPos = bestCell._id
                    }
                }
            }
        }

        // PHASE 4: MOVEMENT (based on movementFraction)
        if (params.movementFraction > 0 && params.repositioning != "otko") {
            var mpToUse = floor(mpBudget * params.movementFraction)
            var moveAction = this.getMoveToOptimalCell(mpToUse)
            if (moveAction != null) {
                push(actions, moveAction)
                var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
                if (moveCost != null) {
                    mpBudget -= moveCost
                    simPos = moveAction.targetCell
                }
            }
        }

        // PHASE 5: ATTACKS (use ALL remaining TP - guarantees damage in all scenarios)
        // ALL scenarios now maximize TP usage - they differ in buff/heal priorities, not attack intensity
        if (tpBudget >= 4) {
            // getAttackActions now ALWAYS uses 100% of tpBudget (fraction parameter ignored)
            var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
            for (var atk in attackActions) {
                push(actions, atk)
            }
        }

        // Note: We don't reject buff-only scenarios here anymore
        // Scorer applies -10000 penalty for zero-damage scenarios, ensuring attack scenarios win

        // PHASE 6: REPOSITIONING (based on repositioning type)
        if (params.repositioning == "hide") {
            var hideAction = this.getHideAndSeekAction(mpBudget)
            if (hideAction != null) {
                push(actions, hideAction)
            }
        } else if (params.repositioning == "kite") {
            var kiteAction = this.getKiteAwayAction(mpBudget)
            if (kiteAction != null) {
                push(actions, kiteAction)
            }
        }
        // "stand" and "otko" don't add repositioning

        return actions
    }

    // ========== HELPER METHODS ==========

    // Get offensive buff action (build-specific)
    getOffensiveBuff() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Apply build-specific buffs (simplified - don't check if already active)
        if (str > mag && str > agi) {
            // Strength build
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player)
            }
        } else if (agi > str && agi > mag) {
            // Agility build
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WARM_UP)) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_WARM_UP, -1, this._player)
            }
        }

        return null
    }

    // Get defensive buff action - INTELLIGENT SHIELD CYCLING
    // Maintains continuous shield coverage by alternating FORTRESS (3t) and WALL (2t)
    // Reapplies when shield expires (remainingTurns <= 1) to prevent gaps
    getDefensiveBuff() {
        var currentTP = getTP()

        // Check if shield is currently active
        var hasShield = this._player.hasEffect(EFFECT_RELATIVE_SHIELD)
        var shieldRemaining = hasShield ? this._player.getEffectRemaining(EFFECT_RELATIVE_SHIELD) : 0

        // Only reapply when shield is missing or about to expire (≤1 turn remaining)
        if (hasShield && shieldRemaining > 1) {
            return null  // Shield still active with 2+ turns, wait
        }

        // Prefer FORTRESS (stronger, 3 turns, 6 TP) if available
        var hasFortress = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_FORTRESS)
        var hasWall = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WALL)

        var fortressCd = hasFortress ? getCooldown(CHIP_FORTRESS, this._player._id) : 999
        var wallCd = hasWall ? getCooldown(CHIP_WALL, this._player._id) : 999

        // FORTRESS: 6 TP, 3 turns, 7-8% reduction
        if (hasFortress && fortressCd == 0 && currentTP >= 9) {  // 6 for FORTRESS + 3 reserve
            return new Action(Action.ACTION_BUFF, -1, CHIP_FORTRESS, -1, this._player)
        }

        // WALL: 3 TP, 2 turns, 4-5% reduction (fallback)
        if (hasWall && wallCd == 0 && currentTP >= 6) {  // 3 for WALL + 3 reserve
            return new Action(Action.ACTION_BUFF, -1, CHIP_WALL, -1, this._player)
        }

        return null  // No shields available or insufficient TP
    }

    // Get LEATHER_BOOTS buff action - INTELLIGENT MP CYCLING for low-MP builds
    // CRITICAL: Only use LEATHER_BOOTS when ADRENALINE is available to offset TP cost
    // LEATHER_BOOTS alone (-3 TP) hurts damage output, but with ADRENALINE (+4 net TP) = net +1 TP + mobility
    getLeatherBootsBuff() {
        var baseMP = getTotalMP()

        // Only use for low-MP builds (< 10 base MP)
        if (baseMP >= 10) {
            return null
        }

        // Check if LEATHER_BOOTS is equipped
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS)) {
            return null
        }

        // CRITICAL: Check if ADRENALINE is available (not on cooldown)
        // Without ADRENALINE, LEATHER_BOOTS costs 3 TP with no recovery, which kills damage output
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            var adrenalineCd = getCooldown(CHIP_ADRENALINE, this._player._id)
            if (adrenalineCd > 0) {
                // ADRENALINE on cooldown - skip LEATHER_BOOTS to preserve TP for damage
                return null
            }
        }

        var currentTP = getTP()

        // Check if MP buff is currently active
        var hasMPBuff = this._player.hasEffect(EFFECT_BUFF_MP)
        var buffRemaining = hasMPBuff ? this._player.getEffectRemaining(EFFECT_BUFF_MP) : 0

        // Only reapply when buff is missing or about to expire (≤1 turn remaining)
        if (hasMPBuff && buffRemaining > 1) {
            return null  // Buff still active with 2+ turns, wait
        }

        // LEATHER_BOOTS: 3 TP, 2 turns, +2 MP
        var bootsCd = getCooldown(CHIP_LEATHER_BOOTS, this._player._id)
        if (bootsCd == 0 && currentTP >= 6) {  // 3 for BOOTS + 3 reserve
            return new Action(Action.ACTION_BUFF, -1, CHIP_LEATHER_BOOTS, -1, this._player)
        }

        return null  // Not available or insufficient TP
    }

    // Get ADRENALINE buff action - TP BOOST for low-MP builds using LEATHER_BOOTS
    // Offsets LEATHER_BOOTS cost: spend 3 TP on boots, gain 4 net TP from ADRENALINE
    // Net result: +1 TP + mobility (critical for 6 MP builds)
    getAdrenalineBuff() {
        var baseMP = getTotalMP()

        // Only use for low-MP builds that need LEATHER_BOOTS
        if (baseMP >= 10) {
            return null
        }

        // Check if ADRENALINE is equipped
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            return null
        }

        var currentTP = getTP()

        // Check cooldown (7 turns)
        var adrenalineCd = getCooldown(CHIP_ADRENALINE, this._player._id)
        if (adrenalineCd > 0) {
            return null  // On cooldown
        }

        // ADRENALINE: 1 TP cost, +5 TP gain (net +4 TP immediately)
        // Use when we have enough TP for it to be useful (at least 2 TP remaining after use)
        if (currentTP >= 3) {  // 1 for ADRENALINE + 2 reserve for attacks
            return new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, -1, this._player)
        }

        return null  // Not worth using with very low TP
    }

    // Get movement action to optimal damage cell (NO CACHING - scenarios need different positions)
    getMoveToOptimalCell(mpBudget) {
        if (mpBudget <= 0) return null

        // PRIORITY 1: Check for OTKO cells first (kill opportunity positioning)
        var otkoCells = this._fieldMap.getAllOTKOCells()
        if (count(otkoCells) > 0) {
            // Find closest reachable OTKO cell
            var bestOTKO = null
            var bestOTKOScore = -999999

            for (var otkoCell in otkoCells) {
                var pathLen = getCachedPathLength(this._player._cellPos, otkoCell._id)
                if (pathLen != null && pathLen <= mpBudget) {
                    // Score: Kill probability (primary) + damage (secondary) - distance (tie-breaker)
                    var score = otkoCell._otkoKillProbability * 10000 + otkoCell._otkoDamage - pathLen * 10
                    if (score > bestOTKOScore) {
                        bestOTKOScore = score
                        bestOTKO = otkoCell
                    }
                }
            }

            if (bestOTKO != null) {
                debug("[MOVE-OTKO] Prioritizing OTKO cell " + bestOTKO._id +
                      " (kill prob=" + floor(bestOTKO._otkoKillProbability * 100) +
                      "%, damage=" + floor(bestOTKO._otkoDamage) + ")")
                return new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, bestOTKO._id, this._target)
            }
        }

        // PRIORITY 2: Threat-aware tactical positioning (damage vs safety)
        // Analysis: Losses take 38% more damage - need to prioritize safer positions
        // Use threat weight based on HP: Low HP = avoid danger, High HP = maximize damage
        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var hpPercent = (playerHP * 100) / playerMaxHP

        // Threat weight: 0 = ignore threat, 1 = equal to damage
        // HP > 70%: threatWeight = 0.3 (mostly offensive)
        // HP 40-70%: threatWeight = 0.5 (balanced)
        // HP < 40%: threatWeight = 0.8 (mostly defensive)
        var threatWeight = 0.3
        if (hpPercent < 40) {
            threatWeight = 0.8
        } else if (hpPercent < 70) {
            threatWeight = 0.5
        }

        var bestCell = this._fieldMap.findBestTacticalCell(mpBudget, threatWeight)
        if (bestCell == null || bestCell == -1) {
            // Fallback to pure damage cell if tactical positioning fails
            bestCell = this._fieldMap.getBestWeaponOrChipCell()
            if (bestCell == null || bestCell == -1) return null

            var pathLength = getCachedPathLength(this._player._cellPos, bestCell._id)
            if (pathLength == null || pathLength > mpBudget) {
                bestCell = this._strategy.findBestReachableDamageCell(mpBudget)
                if (bestCell == null || bestCell == -1) return null
            }
        }

        var action = new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, bestCell._id, this._target)
        return action
    }

    // Get hide and seek action (CACHED)
    getHideAndSeekAction(mpBudget) {
        if (mpBudget <= 0) return null

        // Return cached result if available
        if (this._hideCache != null) {
            return this._hideCache
        }

        var hideCell = this._fieldMap.findHideAndSeekCell("defensive")
        if (hideCell != null && hideCell != -1) {
            this._hideCache = new Action(Action.MOVEMENT_HNS, -1, -1, hideCell, this._target)
            return this._hideCache
        }

        return null
    }

    // Get kite away action (CACHED)
    getKiteAwayAction(mpBudget) {
        if (mpBudget <= 0) return null

        // Return cached result if available
        if (this._kiteCache != null) {
            return this._kiteCache
        }

        this._kiteCache = new Action(Action.MOVEMENT_FLEE, -1, -1, -1, this._target)
        return this._kiteCache
    }

    // Get weapon spam actions (fraction = 0.0-1.0 of TP to use)
    // simPos: simulated position to check weapon range from (defaults to current position)
    getWeaponSpamActions(tpBudget, fraction, simPos = -1) {
        var actions = []
        var tpToUse = floor(tpBudget * fraction)

        // Use simulated position if provided, otherwise use current position
        var checkPos = (simPos == -1) ? this._player._cellPos : simPos

        // Use equipped weapons directly (skip expensive sorting for scenario generation)
        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]
            if (tpToUse < weapon._cost) continue

            // Check if weapon is usable from simulated/current position
            var dist = getCellDistance(checkPos, this._target._cellPos)
            if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue
            if (!lineOfSight(checkPos, this._target._cellPos)) continue

            // Spam weapon up to max uses
            var uses = min(weapon._maxUse, floor(tpToUse / weapon._cost))
            for (var i = 0; i < uses; i++) {
                push(actions, new Action(Action.ACTION_DIRECT, weapon._id, -1, this._target._cellPos, this._target))
                tpToUse -= weapon._cost
            }
        }

        return actions
    }

    // ========== ENHANCED HELPER METHODS (Build-Aware) ==========

    // Get damage return buff for AGI builds (MIRROR/THORN/BRAMBLE)
    // Get damage return buff - INTELLIGENT CYCLING FOR AGILITY BUILDS
    // Maintains continuous damage return coverage by alternating MIRROR (3t) and THORN (2t)
    // Uses BRAMBLE (1t, 25% return) for close-range burst combat
    // Reapplies when buff expires (remainingTurns <= 1) to prevent gaps
    getDamageReturnBuff() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Only for agility builds
        if (agi <= str || agi <= mag) return null

        var currentTP = getTP()

        // Check if damage return is currently active
        var hasReturn = this._player.hasDamageReturn()
        var returnRemaining = hasReturn ? this._player.getDamageReturnRemaining() : 0

        // Only reapply when damage return is missing or about to expire (≤1 turn remaining)
        if (hasReturn && returnRemaining > 1) {
            return null  // Damage return still active with 2+ turns, wait
        }

        // Calculate distance to enemy for BRAMBLE check
        var distToEnemy = getCellDistance(this._player._cellPos, this._target._cellPos)
        if (distToEnemy == null) distToEnemy = 99
        var inCloseCombat = distToEnemy <= 8

        // Check availability of damage return chips
        var hasMirror = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_MIRROR)
        var hasThorn = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_THORN)
        var hasBramble = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_BRAMBLE)

        var mirrorCd = hasMirror ? getCooldown(CHIP_MIRROR, this._player._id) : 999
        var thornCd = hasThorn ? getCooldown(CHIP_THORN, this._player._id) : 999
        var brambleCd = hasBramble ? getCooldown(CHIP_BRAMBLE, this._player._id) : 999

        var mirrorReady = mirrorCd == 0 && hasMirror && currentTP >= 5
        var thornReady = thornCd == 0 && hasThorn && currentTP >= 4
        var brambleReady = brambleCd == 0 && hasBramble && currentTP >= 4

        // PRIORITY 1: BRAMBLE during active melee combat (25% return, best burst damage reflection)
        if (brambleReady && inCloseCombat && currentTP >= 10) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_BRAMBLE, -1, this._player)
        }

        // PRIORITY 2: TP-aware selection - prefer THORN when TP < 15 (cheaper, leaves more TP for attacks)
        if (currentTP < 15) {
            if (thornReady) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_THORN, -1, this._player)  // 4 TP, 2 turns
            }
            if (mirrorReady && currentTP >= 10) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)  // 5 TP, 3 turns
            }
            return null  // TP too low, skip damage return and attack directly
        }

        // PRIORITY 3: Prefer MIRROR when both available AND sufficient TP (3 turn coverage > 2 turn)
        if (mirrorReady && thornReady && currentTP >= 15) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)
        }

        // PRIORITY 4: Use MIRROR when available (best sustained coverage)
        if (mirrorReady) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)
        }

        // PRIORITY 5: Use THORN when available
        if (thornReady) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_THORN, -1, this._player)
        }

        return null  // All on cooldown - coverage gap
    }

    // Get healing action if HP below threshold
    getHealingAction(tpBudget, hpThreshold = 0.7) {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP

        if (hpRatio >= hpThreshold) return null  // Don't heal if above threshold

        // REMISSION: ~125 HP, 5 TP (priority: instant heal)
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0 &&
            tpBudget >= 5) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player)
        }

        // REGENERATION: fallback (multi-turn heal)
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION) &&
            getCooldown(CHIP_REGENERATION, this._player._id) == 0 &&
            tpBudget >= 3) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, -1, this._player)
        }

        return null
    }

    // Get REMISSION action (instant heal, 5 TP)
    getRemissionAction() {
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player)
        }
        return null
    }

    // Get REGENERATION action (multi-turn heal, 3 TP)
    getRegenerationAction() {
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION) &&
            getCooldown(CHIP_REGENERATION, this._player._id) == 0) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, -1, this._player)
        }
        return null
    }

    // Get LIBERATION debuff for STR builds (strip enemy buffs)
    getDebuffAction() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Only for strength builds
        if (str <= mag || str <= agi) return null

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_LIBERATION)) return null
        if (getCooldown(CHIP_LIBERATION, this._player._id) != 0) return null

        // Check if target has buffs worth removing (shields, damage return, resistance buffs)
        var targetBuffs = 0
        if (this._target.hasEffect(EFFECT_ABSOLUTE_SHIELD)) targetBuffs++
        if (this._target.hasEffect(EFFECT_RELATIVE_SHIELD)) targetBuffs++
        if (this._target.hasEffect(EFFECT_DAMAGE_RETURN)) targetBuffs++
        if (this._target.hasEffect(EFFECT_BUFF_RESISTANCE)) targetBuffs++
        if (this._target.hasEffect(EFFECT_BUFF_STRENGTH)) targetBuffs++

        if (targetBuffs > 0) {
            return new Action(Action.ACTION_DEBUFF, -1, CHIP_LIBERATION, this._target._cellPos, this._target)
        }

        return null
    }

    // Enhanced attack actions - BOTH weapons AND damage chips (respects max uses)
    // ALWAYS uses 100% of available TP budget to maximize damage output
    getAttackActions(tpBudget, fraction, simPos) {
        var actions = []
        // MAXIMIZED TP USAGE: Always use ALL remaining TP (ignore fraction parameter)
        // Scenarios differ in what they spend TP on BEFORE attacks (buffs/heals)
        // But all scenarios should maximize damage with whatever TP remains
        var tpToUse = tpBudget  // Use ALL remaining TP, not a fraction
        var weaponUses = [:]  // Track weapon uses per weapon ID
        var chipCooldowns = [:]  // Track chip usage (single use per turn for damage chips)

        // Repeatedly find and use best available attack from simulated position
        while (tpToUse >= 4) {  // Minimum TP for any attack
            var bestAttack = this.findBestAvailableAttack(simPos, weaponUses, chipCooldowns)
            if (bestAttack == null) break  // No more attacks available

            var attackCost = bestAttack['cost']
            if (tpToUse < attackCost) break  // Not enough TP

            var attackType = bestAttack['type']
            var attackId = bestAttack['id']

            // Add action
            if (attackType == 'weapon') {
                push(actions, new Action(Action.ACTION_DIRECT, attackId, -1, this._target._cellPos, this._target))
                var currentUses = weaponUses[attackId]
                if (currentUses == null) currentUses = 0
                weaponUses[attackId] = currentUses + 1
            } else {
                push(actions, new Action(Action.ACTION_DIRECT, -1, attackId, this._target._cellPos, this._target))
                chipCooldowns[attackId] = true  // Mark chip as used
            }

            tpToUse -= attackCost
        }

        return actions
    }

    // Find best available attack (excludes exhausted weapons/chips)
    findBestAvailableAttack(simPos, weaponUses, chipCooldowns) {
        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom
        var bestAttack = null
        var bestDamage = 0

        // Check all equipped weapons
        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]

            // Check if weapon max uses reached
            var currentUses = weaponUses[weaponId]
            if (currentUses == null) currentUses = 0
            if (currentUses >= weapon._maxUse) continue

            // Check range from simulated position
            var dist = getCellDistance(simPos, this._target._cellPos)
            if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue

            // SIMPLIFIED: Use lineOfSight for scenario planning (hitmap not reliable for simulated positions)
            // Hitmap is calculated from player's starting position, but simPos may be different after LEATHER_BOOTS
            if (!lineOfSight(simPos, this._target._cellPos)) {
                continue
            }

            // Calculate damage
            var damage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, weaponId, this._target)
            if (damage > bestDamage) {
                bestDamage = damage
                bestAttack = ["type": "weapon", "id": weaponId, "cost": weapon._cost, "damage": damage]
            }
        }

        // Check all equipped damage chips
        var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG,
                           CHIP_FIRE_BALL, CHIP_ROCK, CHIP_FLAME, CHIP_STALACTITE]

        for (var chipId in damageChips) {
            if (!mapContainsKey(this._arsenal.playerEquippedChips, chipId)) continue
            if (chipCooldowns[chipId] != null) continue  // Already used this scenario
            if (getCooldown(chipId, this._player._id) > 0) continue  // On cooldown

            // Check range from simulated position
            var chip = this._arsenal.playerEquippedChips[chipId]
            var dist = getCellDistance(simPos, this._target._cellPos)
            if (dist == null || dist < chip._minRange || dist > chip._maxRange) continue
            if (!lineOfSight(simPos, this._target._cellPos)) continue

            // Calculate damage
            var damage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, chipId, this._target)
            if (damage > bestDamage) {
                bestDamage = damage
                bestAttack = ["type": "chip", "id": chipId, "cost": getCachedChipCost(chipId), "damage": damage]
            }
        }

        return bestAttack
    }

    // Check if OTKO opportunity exists
    checkOTKOOpportunity() {
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth
        var hpPercent = (enemyHP * 100) / enemyMaxHP

        return (hpPercent < 35 || enemyHP < 500)
    }

    // Estimate maximum damage player can deal this turn (for mutual lethal detection)
    estimateMaxDamageThisTurn(availableTP) {
        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom
        var totalDamage = 0

        // Estimate damage from all equipped weapons (respecting max uses)
        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]
            var weaponDamage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, weaponId, this._target)
            var maxUses = min(weapon._maxUse, floor(availableTP / weapon._cost))
            totalDamage += weaponDamage * maxUses
        }

        // Estimate damage from best damage chip (single use)
        var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG]
        var bestChipDamage = 0
        for (var chipId in damageChips) {
            if (!mapContainsKey(this._arsenal.playerEquippedChips, chipId)) continue
            if (getCooldown(chipId, this._player._id) > 0) continue

            var chipDamage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, chipId, this._target)
            bestChipDamage = max(bestChipDamage, chipDamage)
        }
        totalDamage += bestChipDamage

        return totalDamage
    }

    // ====================================================================
    // COMBO-SPECIFIC SCENARIOS (High-Value Strategic Sequences)
    // ====================================================================

    // COMBO 1: Neutrino Vulnerability Stacking → Amplified Weapon Spam
    // Stack 3x Neutrino (24% vulnerability) then spam best weapons
    // Best used in AGGRO/ATTRITION states when enemy HP > 40%
    createNeutrinoStackingScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        // Check prerequisites
        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return null  // No Neutrino equipped
        }

        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) return null

        // Need diagonal range 2-6 for Neutrino
        var isDiagonal = this.isDiagonal(simPos, this._target._cellPos)
        if (!isDiagonal || dist < 2 || dist > 6) {
            return null  // Not in Neutrino range
        }

        if (!lineOfSight(simPos, this._target._cellPos)) {
            return null  // No LOS
        }

        // Need minimum 16 TP (12 for 3x Neutrino + 4 for at least one weapon use)
        if (tpBudget < 16) {
            return null
        }

        // Check if vulnerability already maxed (3 stacks, 2+ turns remaining)
        var currentStacks = this._arsenal.getVulnerabilityStacks(this._target)
        var vulnRemaining = this._target.getEffectRemaining(EFFECT_VULNERABILITY)
        if (currentStacks >= 3 && vulnRemaining >= 2) {
            return null  // Already maxed, don't waste TP
        }

        debug("[COMBO-NEUTRINO] Creating Neutrino stacking scenario (3x vuln + weapons)")

        // PHASE 1: Weapon swap to Neutrino (if needed)
        if (getWeapon() != WEAPON_NEUTRINO) {
            push(actions, new Action(Action.ACTION_WEAPON_SWAP, -1, -1, -1, this._target))
            actions[count(actions) - 1].weapon = WEAPON_NEUTRINO
            tpBudget -= 1
        }

        // PHASE 2: Stack 3x Neutrino (24% vulnerability = 1.24x damage multiplier)
        for (var i = 0; i < 3; i++) {
            if (tpBudget >= 4) {
                push(actions, new Action(Action.ACTION_DIRECT, WEAPON_NEUTRINO, -1, this._target._cellPos, this._target))
                tpBudget -= 4
            }
        }

        // PHASE 3: Spam remaining weapons with amplified damage
        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // PHASE 4: Hide and seek repositioning
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // COMBO 2: GRAPPLE-HEAVY_SWORD Combo
    // Pull enemy to adjacent cell + apply 60 vulnerability + burst damage
    // RELAXED PREREQUISITES: Generates optimistically, lets simulator score invalid combos low
    createGrappleHeavySwordScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        // CRITICAL checks only (equipment + cooldown)
        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD)) {
            return null  // Can't execute without equipment
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
            return null  // Can't execute without chip
        }
        if (getCooldown(CHIP_GRAPPLE, this._player._id) > 0) {
            return null  // Can't execute on cooldown
        }

        // NULL safety check
        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) {
            return null
        }

        // Minimum TP check (GRAPPLE + HEAVY_SWORD minimum usage)
        if (tpBudget < 10) {  // Reduced from 18-19 to allow more attempts
            return null
        }

        // REMOVED CHECKS (let simulator handle):
        // - Range check (2-8) → simulator will score 0 damage if out of range
        // - Alignment check → simulator will score 0 damage if not aligned
        // - LOS check → simulator will score 0 damage if blocked
        // - Strict TP threshold → allow even if can't finish full combo

        debug("[COMBO-GRAPPLE-HS] Creating GRAPPLE-HEAVY_SWORD scenario (optimistic - simulator will validate)")

        // PHASE 1: Calculate GRAPPLE destination (adjacent to player, toward enemy)
        var playerX = getCellX(simPos)
        var playerY = getCellY(simPos)
        var enemyX = getCellX(this._target._cellPos)
        var enemyY = getCellY(this._target._cellPos)

        var grappleCell = -1
        if (playerY == enemyY) {
            // Horizontal alignment
            grappleCell = (enemyX < playerX) ? getCellFromXY(playerX - 1, playerY) : getCellFromXY(playerX + 1, playerY)
        } else {
            // Vertical alignment
            grappleCell = (enemyY < playerY) ? getCellFromXY(playerX, playerY - 1) : getCellFromXY(playerX, playerY + 1)
        }

        if (grappleCell == -1 || grappleCell == null) {
            return null
        }

        // PHASE 2: GRAPPLE to pull enemy
        push(actions, new Action(Action.ACTION_DIRECT, -1, CHIP_GRAPPLE, grappleCell, this._target))
        tpBudget -= 3

        // PHASE 3: Weapon swap to HEAVY_SWORD (if needed)
        if (getWeapon() != WEAPON_HEAVY_SWORD) {
            push(actions, new Action(Action.ACTION_WEAPON_SWAP, -1, -1, -1, this._target))
            actions[count(actions) - 1].weapon = WEAPON_HEAVY_SWORD
            tpBudget -= 1
        }

        // PHASE 4: HEAVY_SWORD (60 vulnerability for 4 turns)
        push(actions, new Action(Action.ACTION_DIRECT, WEAPON_HEAVY_SWORD, -1, this._target._cellPos, this._target))
        tpBudget -= 15

        // PHASE 5: Spam remaining weapons with 60% vulnerability amplification
        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // PHASE 6: Hide and seek
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // COMBO 3: STEROID → OTKO Recheck
    // Apply STEROID (+160 STR), recalculate damage, teleport OTKO if now possible
    // RELAXED PREREQUISITES: Generates whenever chips available, scorer handles viability
    createSteroidOTKOScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP

        // CRITICAL checks only (equipment + cooldown)
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
            return null
        }
        if (getCooldown(CHIP_STEROID, this._player._id) > 0) {
            return null
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            return null
        }
        if (getCooldown(CHIP_TELEPORTATION, this._player._id) > 0) {
            return null
        }

        // Minimum TP check (STEROID + TELEPORTATION minimum)
        if (tpBudget < 15) {  // Reduced from 22 to allow more attempts
            return null
        }

        // REMOVED CHECKS (let simulator/scorer handle):
        // - HP sweet spot (40-70%) → scorer will evaluate if combo delivers kill
        // - Strict TP threshold → allow partial combos
        // If combo doesn't help, scorer will rank it low

        debug("[COMBO-STEROID-OTKO] Creating STEROID + OTKO scenario (optimistic)")

        // PHASE 1: Apply STEROID (+160 STR for 3 turns)
        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player))
        tpBudget -= 7

        // PHASE 2: Get best OTKO cell with buffed damage
        var bestOTKO = this._fieldMap.getBestOTKOCell()
        if (bestOTKO == null) {
            // No OTKO cells available, fallback to best damage cell + teleport
            bestOTKO = this._fieldMap.getBestWeaponOrChipCell()
            if (bestOTKO == null || bestOTKO == -1) {
                return null
            }
        }

        var teleportDist = getCellDistance(this._player._cellPos, bestOTKO._id)
        if (teleportDist == null || teleportDist < 1 || teleportDist > 12) {
            return null
        }

        // PHASE 3: Teleport to OTKO cell
        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestOTKO._id, this._target))
        tpBudget -= 5

        // PHASE 4: Spam ALL weapons from OTKO position
        var attackActions = this.getAttackActions(tpBudget, 1.0, bestOTKO._id)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    // COMBO 3B: STEROID → Recheck (Two-Phase Adaptive)
    // Apply STEROID (+160 STR), CHECKPOINT, then branch based on updated kill probability
    // Branch A (kill prob >= 85%): Teleport + OTKO burst
    // Branch B (else): Normal weapon attacks + hide
    createSteroidRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP

        // CRITICAL checks only (equipment + cooldown)
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
            return null
        }
        if (getCooldown(CHIP_STEROID, this._player._id) > 0) {
            return null
        }

        // Minimum TP check (STEROID + some attacks)
        if (tpBudget < 10) {
            return null
        }

        debug("[COMBO-STEROID-RECHECK] Creating two-phase STEROID scenario (adaptive)")

        // PHASE 1: Apply STEROID (+160 STR for 3 turns)
        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player))
        tpBudget -= 7

        // PHASE 2: CHECKPOINT - Re-evaluate with buffed stats
        // Pass context: target reference, remaining TP
        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget

        var checkpoint = Action.createCheckpoint("BUFF_RECHECK", "evaluateBuffRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-STEROID-RECHECK] Added checkpoint: will re-evaluate kill probability with +160 STR")

        return actions
    }

    // COMBO 3C: Neutrino → Recheck (Two-Phase Adaptive)
    // Stack 2-3 Neutrino hits (16-24% vuln), CHECKPOINT, then branch on amplified damage
    // Branch A (if amplification enables OTKO): Aggressive burst
    // Branch B (else): Balanced attacks
    createNeutrinoRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var simPos = this._player._cellPos

        // CRITICAL checks only (equipment)
        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return null
        }

        // Minimum TP check (2-3 Neutrino shots + some attacks)
        if (tpBudget < 15) {
            return null
        }

        // Check if in Neutrino range (diagonal 2-6)
        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) return null

        var isOnAxis = getCellX(simPos) == getCellX(this._target._cellPos) ||
                       getCellY(simPos) == getCellY(this._target._cellPos)
        if (!isOnAxis) return null
        if (dist < 2 || dist > 6) return null

        debug("[COMBO-NEUTRINO-RECHECK] Creating two-phase Neutrino stacking scenario (adaptive)")

        // PHASE 1: Stack 2-3 Neutrino shots (16-24% vulnerability)
        var neutrinoCount = floor((tpBudget - 10) / 4)  // Reserve 10 TP for attacks after checkpoint
        if (neutrinoCount > 3) neutrinoCount = 3  // Max 3 stacks (24%)
        if (neutrinoCount < 2) neutrinoCount = 2  // Min 2 stacks (16%)

        for (var n = 0; n < neutrinoCount; n++) {
            push(actions, new Action(Action.ACTION_DIRECT, WEAPON_NEUTRINO, -1, -1, this._target))
            tpBudget -= 4
        }

        var expectedVuln = neutrinoCount * 8

        // PHASE 2: CHECKPOINT - Re-evaluate with vulnerability applied
        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget
        context['vulnerabilityPercent'] = expectedVuln  // Fixed: use correct context key

        var checkpoint = Action.createCheckpoint("VULNERABILITY_RECHECK", "evaluateVulnerabilityRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-NEUTRINO-RECHECK] Added checkpoint: will re-evaluate with " + expectedVuln + "% vulnerability")

        return actions
    }

    // COMBO 3D: GRAPPLE-HS → Recheck (Two-Phase Adaptive)
    // GRAPPLE pull enemy close, CHECKPOINT, then branch on position/damage potential
    // Branch A (if in Heavy Sword range): Apply vulnerability + burst
    // Branch B (else): Normal attacks from current position
    createGrappleHSRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var simPos = this._player._cellPos

        // CRITICAL checks only (equipment + cooldown)
        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD)) {
            return null
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
            return null
        }
        if (getCooldown(CHIP_GRAPPLE, this._player._id) > 0) {
            return null
        }

        // Minimum TP check (GRAPPLE + Heavy Sword + some attacks)
        if (tpBudget < 12) {
            return null
        }

        // Check if on axis with enemy
        var enemyPos = this._target._cellPos
        var isOnAxis = getCellX(simPos) == getCellX(enemyPos) ||
                       getCellY(simPos) == getCellY(enemyPos)
        if (!isOnAxis) return null

        var dist = getCellDistance(simPos, enemyPos)
        if (dist == null) return null
        if (dist < 2 || dist > 8) return null  // GRAPPLE range 2-8

        debug("[COMBO-GRAPPLE-HS-RECHECK] Creating two-phase GRAPPLE pull scenario (adaptive)")

        // PHASE 1: GRAPPLE pull enemy closer (to distance 2)
        // Calculate GRAPPLE destination cell (between player and enemy, distance 2 from player)
        var dx = getCellX(enemyPos) - getCellX(simPos)
        var dy = getCellY(enemyPos) - getCellY(simPos)
        var dirX = 0
        var dirY = 0
        if (dx != 0) dirX = dx / abs(dx)  // Normalize to -1, 0, or 1
        if (dy != 0) dirY = dy / abs(dy)

        var grappleTargetCell = getCellFromXY(getCellX(simPos) + dirX, getCellY(simPos) + dirY)
        if (grappleTargetCell == null) {
            return null  // Invalid destination
        }

        push(actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_GRAPPLE, grappleTargetCell, this._target))
        tpBudget -= 4

        // PHASE 2: CHECKPOINT - Re-evaluate with enemy at distance 2
        // Use VULNERABILITY_RECHECK with 0% vulnerability (just position change)
        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget
        context['vulnerabilityPercent'] = 0  // No vulnerability, just position change

        var checkpoint = Action.createCheckpoint("VULNERABILITY_RECHECK", "evaluateVulnerabilityRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-GRAPPLE-HS-RECHECK] Added checkpoint: will re-evaluate after pulling enemy to distance 2")

        return actions
    }

    // COMBO 3E: Heal → Recheck (Two-Phase Adaptive)
    // REMISSION heal, CHECKPOINT, then branch on HP percentage
    // Branch A (if HP > 70%): Aggressive attack
    // Branch B (if HP 50-70%): Balanced attack
    // Branch C (if HP < 50%): Defensive kite
    createHealRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP

        // CRITICAL checks only (equipment + HP need)
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION)) {
            return null
        }
        if (getCooldown(CHIP_REMISSION, this._player._id) > 0) {
            return null
        }

        // Check if we actually need healing
        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var playerHPPercent = (playerHP * 100) / playerMaxHP

        if (playerHPPercent > 70) {
            return null  // Don't heal if HP is already high
        }

        // Minimum TP check (REMISSION + some attacks)
        if (tpBudget < 10) {
            return null
        }

        debug("[COMBO-HEAL-RECHECK] Creating two-phase healing scenario (adaptive)")

        // PHASE 1: REMISSION heal
        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player))
        tpBudget -= 3

        // PHASE 2: CHECKPOINT - Re-evaluate after healing
        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget

        var checkpoint = Action.createCheckpoint("HEAL_RECHECK", "evaluateHealRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-HEAL-RECHECK] Added checkpoint: will re-evaluate aggression after healing")

        return actions
    }

    // COMBO 4: Neutrino Pre-Stack → Teleport OTKO
    // Stack 3x Neutrino (24% vuln), then teleport + burst with amplified damage
    // Best used in KILL state when enemy HP < 40% AND we're in Neutrino range
    createNeutrinoOTKOScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        // Check prerequisites
        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return null
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            return null
        }
        if (getCooldown(CHIP_TELEPORTATION, this._player._id) > 0) {
            return null
        }

        // Need Neutrino stacking (12) + Teleport (5) + weapons (10) = 27 TP minimum
        if (tpBudget < 27) {
            return null
        }

        // Check if enemy HP < 40% (KILL state)
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth
        var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

        if (enemyHPPercent >= 40) {
            return null  // Not in KILL state
        }

        // Check if currently in Neutrino range (diagonal 2-6)
        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) return null

        var isDiagonal = this.isDiagonal(simPos, this._target._cellPos)
        if (!isDiagonal || dist < 2 || dist > 6) {
            return null  // Not in Neutrino range
        }

        if (!lineOfSight(simPos, this._target._cellPos)) {
            return null
        }

        debug("[COMBO-NEUTRINO-OTKO] Creating Neutrino pre-stack + teleport OTKO scenario")

        // PHASE 1: Weapon swap to Neutrino
        if (getWeapon() != WEAPON_NEUTRINO) {
            push(actions, new Action(Action.ACTION_WEAPON_SWAP, -1, -1, -1, this._target))
            actions[count(actions) - 1].weapon = WEAPON_NEUTRINO
            tpBudget -= 1
        }

        // PHASE 2: Stack 3x Neutrino (24% vulnerability)
        for (var i = 0; i < 3; i++) {
            if (tpBudget >= 4) {
                push(actions, new Action(Action.ACTION_DIRECT, WEAPON_NEUTRINO, -1, this._target._cellPos, this._target))
                tpBudget -= 4
            }
        }

        // PHASE 3: Get best OTKO cell
        var bestOTKO = this._fieldMap.getBestOTKOCell()
        if (bestOTKO == null) {
            bestOTKO = this._fieldMap.getBestWeaponOrChipCell()
            if (bestOTKO == null) {
                return null
            }
        }

        var teleportDist = getCellDistance(simPos, bestOTKO._id)
        if (teleportDist == null || teleportDist < 1 || teleportDist > 12) {
            return null
        }

        // PHASE 4: Teleport to OTKO cell
        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestOTKO._id, this._target))
        tpBudget -= 5

        // PHASE 5: Spam ALL weapons with 24% amplification from OTKO position
        var attackActions = this.getAttackActions(tpBudget, 1.0, bestOTKO._id)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    // COMBO 5: ADRENALINE Bridge → Combo Enabler
    // Use ADRENALINE (+4 net TP) to enable high-value combos when short 1-4 TP
    // Wraps around other combo scenarios
    createAdrenalineComboScenario(comboScenarioCreator, requiredTP, availableTP, availableMP) {
        var tpGap = requiredTP - availableTP

        // Check if ADRENALINE can bridge the gap (need 1-4 TP gap)
        if (tpGap < 1 || tpGap > 4) {
            return null
        }

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            return null
        }
        if (getCooldown(CHIP_ADRENALINE, this._player._id) > 0) {
            return null
        }

        // Need at least 1 TP for ADRENALINE
        if (availableTP < 1) {
            return null
        }

        debug("[COMBO-ADRENALINE] Using ADRENALINE to bridge " + tpGap + " TP gap for combo")

        var actions = []

        // PHASE 1: Use ADRENALINE (+4 net TP)
        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, -1, this._player))
        var newTPBudget = availableTP - 1 + 5  // -1 cost, +5 TP gain = +4 net

        // PHASE 2: Execute the combo scenario with new TP budget
        var comboActions = comboScenarioCreator(newTPBudget, availableMP)
        if (comboActions == null || count(comboActions) == 0) {
            return null  // Combo not viable even with ADRENALINE
        }

        // Merge ADRENALINE + combo actions
        for (var action in comboActions) {
            push(actions, action)
        }

        return actions
    }

    // ====================================================================
    // BASELINE SCENARIOS (Always Executable - Insurance Against Combo Failures)
    // ====================================================================

    // BASELINE 1: Static Attack Scenario - spam attacks from current position (no movement)
    // Guaranteed executable: No prerequisites, no movement, just attacks
    // Acts as minimum viable combat scenario when all combos fail
    createStaticAttackScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var simPos = this._player._cellPos  // Stay at current position

        debug("[BASELINE-STATIC] Creating static attack scenario (no movement)")

        // Spam ALL weapons from current position
        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // No repositioning - stay and fight
        return actions
    }

    // BASELINE 2: Simple Offensive Scenario - move to best cell + attack
    // Guaranteed executable: Simple movement + attacks, no complex prerequisites
    // Provides baseline offensive performance when combos unavailable
    createSimpleOffensiveScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        debug("[BASELINE-OFFENSIVE] Creating simple offensive scenario (move + attack)")

        // PHASE 1: Move to best weapon cell (if possible)
        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getCachedPathLength(this._player._cellPos, moveAction.targetCell)
            if (moveCost != null) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  // Update simulated position
            }
        }

        // PHASE 2: Spam ALL weapons from final position
        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        // PHASE 3: Hide and seek repositioning
        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    // Helper: Check if two cells are on diagonal line
    isDiagonal(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        var dx = abs(x2 - x1)
        var dy = abs(y2 - y1)
        return dx == dy && dx > 0  // Perfect diagonal (45°)
    }

    // Helper: Check if two cells are on same horizontal/vertical line
    isOnSameLine(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        return (x1 == x2 || y1 == y2)  // Horizontal OR vertical
    }
}
