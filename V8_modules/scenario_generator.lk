// REMOVED: include('tactical_awareness.lk')
// Phase 2 features not needed - TP/MP reset each turn

class ScenarioParams {
    buffStrategy = 0       
    healThreshold = -1     
    movementFraction = 1.0 
    attackFraction = 1.0   
    repositioning = "hide" 

    constructor(buffStrat, healThr, moveFrac, attackFrac, reposition) {
        this.buffStrategy = buffStrat
        this.healThreshold = healThr
        this.movementFraction = moveFrac
        this.attackFraction = attackFrac  
        this.repositioning = reposition
    }
}

class ScenarioGenerator {
    _arsenal = null
    _player = null
    _target = null
    _fieldMap = null
    _strategy = null

    _moveCache = [:]     
    _hideCache = null    
    _kiteCache = null    

    static USE_STATE_BASED_SCENARIOS = true  

    constructor(arsenal, player, target, fieldMap, strategy) {
        this._arsenal = arsenal
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
        this._strategy = strategy
        this._moveCache = [:]  
    }

    generateScenarios() {
        this._target.updateEntity()
        debug("[SCENARIO-GEN] Updated target entity (pos=" + this._target._cellPos + " HP=" + this._target._currHealth + ")")

        var scenarios = []
        var availableTP = getTP()
        var availableMP = getMP()

        // REMOVED: Phase 2 TP Reservation Logic
        // TP/MP reset to maximum each turn, so "reserving for next turn" is nonsensical
        // If we wanted to ensure defensive actions within THIS turn, scenarios should
        // compete on merit, not by handicapping offensive budget

        var state = this.determineStrategicState()
        debug("[STATE] Strategic state: " + state)

        if (state == "KILL") {
            
            debug("[STATE-KILL] Enemy killable - checking OTKO cells for optimal positioning")

            var neutrinoOTKO = this.createNeutrinoOTKOScenario(availableTP, availableMP)
            if (neutrinoOTKO != null) {
                debug("[STATE-KILL] Adding Neutrino-OTKO combo scenario")
                push(scenarios, neutrinoOTKO)
            }

            var bestOTKO = this._fieldMap.getBestOTKOCell()
            var hasTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)
            var teleportReady = hasTeleport && getCooldown(CHIP_TELEPORTATION, player._id) == 0

            if (bestOTKO != null && teleportReady && availableTP >= 15) {
                
                var distToOTKO = getCellDistance(player._cellPos, bestOTKO._id)
                if (distToOTKO != null && distToOTKO >= 1 && distToOTKO <= 12) {
                    debug("[STATE-KILL] Teleporting to OTKO cell " + bestOTKO._id +
                          " (kill prob=" + floor(bestOTKO._otkoKillProbability * 100) + "%)")
                    push(scenarios, this.createOTKOTeleportScenario(bestOTKO._id, availableTP, availableMP))
                }
            }

            push(scenarios, this.createParametricScenario(new ScenarioParams(4, -1, 1.0, 1.0, "otko"), availableTP, availableMP))
            push(scenarios, this.createParametricScenario(new ScenarioParams(0, -1, 1.0, 1.0, "stand"), availableTP, availableMP))

            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }
        else if (state == "AGGRO") {
            
            debug("[STATE-AGGRO] Early game / buff application phase")

            var grappleHS = this.createGrappleHeavySwordScenario(availableTP, availableMP)
            if (grappleHS != null) {
                debug("[STATE-AGGRO] Adding GRAPPLE-HEAVY_SWORD combo scenario")
                push(scenarios, grappleHS)
            }

            var neutrinoStack = this.createNeutrinoStackingScenario(availableTP, availableMP)
            if (neutrinoStack != null) {
                debug("[STATE-AGGRO] Adding Neutrino stacking combo scenario")
                push(scenarios, neutrinoStack)
            }

            var steroidOTKO = this.createSteroidOTKOScenario(availableTP, availableMP)
            if (steroidOTKO != null) {
                debug("[STATE-AGGRO] Adding STEROID-OTKO combo scenario")
                push(scenarios, steroidOTKO)
            }

            var steroidRecheck = this.createSteroidRecheckScenario(availableTP, availableMP)
            if (steroidRecheck != null) {
                debug("[STATE-AGGRO] Adding STEROID-Recheck two-phase scenario")
                push(scenarios, steroidRecheck)
            }

            push(scenarios, this.createParametricScenario(new ScenarioParams(4, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  
            push(scenarios, this.createParametricScenario(new ScenarioParams(1, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  
            push(scenarios, this.createParametricScenario(new ScenarioParams(0, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  

            push(scenarios, this.createParametricScenario(new ScenarioParams(2, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  

            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))  
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))  
        }
        else if (state == "ATTRITION") {
            
            debug("[STATE-ATTRITION] Ongoing balanced combat")

            var playerHP = this._player._currHealth
            var enemyHP = this._target._currHealth
            var losingHPRace = (playerHP < enemyHP)

            if (losingHPRace) {
                debug("[STATE-ATTRITION] Losing HP race (" + playerHP + " < " + enemyHP + ") - adding defensive scenarios")
                
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.7, 0.7, 0.7, "hide"), availableTP, availableMP))  
                push(scenarios, this.createParametricScenario(new ScenarioParams(3, 0.5, 0.8, 0.8, "hide"), availableTP, availableMP))  
            }

            var grappleHS = this.createGrappleHeavySwordScenario(availableTP, availableMP)
            if (grappleHS != null) {
                debug("[STATE-ATTRITION] Adding GRAPPLE-HEAVY_SWORD combo scenario")
                push(scenarios, grappleHS)
            }

            var neutrinoStack = this.createNeutrinoStackingScenario(availableTP, availableMP)
            if (neutrinoStack != null) {
                debug("[STATE-ATTRITION] Adding Neutrino stacking combo scenario")
                push(scenarios, neutrinoStack)
            }

            var steroidOTKO = this.createSteroidOTKOScenario(availableTP, availableMP)
            if (steroidOTKO != null) {
                debug("[STATE-ATTRITION] Adding STEROID-OTKO combo scenario")
                push(scenarios, steroidOTKO)
            }

            var neutrinoRecheck = this.createNeutrinoRecheckScenario(availableTP, availableMP)
            if (neutrinoRecheck != null) {
                debug("[STATE-ATTRITION] Adding Neutrino-Recheck checkpoint scenario")
                push(scenarios, neutrinoRecheck)
            }

            var grappleHSRecheck = this.createGrappleHSRecheckScenario(availableTP, availableMP)
            if (grappleHSRecheck != null) {
                debug("[STATE-ATTRITION] Adding GRAPPLE-HS-Recheck checkpoint scenario")
                push(scenarios, grappleHSRecheck)
            }

            push(scenarios, this.createParametricScenario(new ScenarioParams(4, -1, 0.8, 0.8, "hide"), availableTP, availableMP))  
            push(scenarios, this.createParametricScenario(new ScenarioParams(3, -1, 0.8, 0.8, "hide"), availableTP, availableMP))  
            push(scenarios, this.createParametricScenario(new ScenarioParams(0, -1, 1.0, 1.0, "hide"), availableTP, availableMP))  

            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }
        else if (state == "SUSTAIN") {
            
            debug("[STATE-SUSTAIN] HP management phase")

            var healRecheck = this.createHealRecheckScenario(availableTP, availableMP)
            if (healRecheck != null) {
                debug("[STATE-SUSTAIN] Adding Heal-Recheck checkpoint scenario")
                push(scenarios, healRecheck)
            }

            push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.7, 0.6, 0.6, "hide"), availableTP, availableMP))  
            push(scenarios, this.createParametricScenario(new ScenarioParams(4, 0.7, 0.6, 0.6, "kite"), availableTP, availableMP))  
            push(scenarios, this.createParametricScenario(new ScenarioParams(3, -1, 0.6, 0.6, "hide"), availableTP, availableMP))  

            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }
        else if (state == "FLEE") {

            debug("[STATE-FLEE] Emergency survival mode")

            var hasTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)
            var teleportReady = hasTeleport && getCooldown(CHIP_TELEPORTATION, player._id) == 0

            if (teleportReady) {

                var currentThreat = this._fieldMap.getThreatAtCell(player._cellPos)
                if (currentThreat > 200) {
                    debug("[STATE-FLEE] High threat detected (" + currentThreat + ") - prioritizing TELEPORT escape")
                    var escapeScenario = this.createTeleportEscapeScenario(availableTP, availableMP)
                    if (escapeScenario != null) {
                        push(scenarios, escapeScenario)
                    }
                }
            }

            var healRecheck = this.createHealRecheckScenario(availableTP, availableMP)
            if (healRecheck != null) {
                debug("[STATE-FLEE] Adding emergency Heal-Recheck checkpoint scenario")
                push(scenarios, healRecheck)
            }

            var hasRegen = mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)
            var regenAvailable = hasRegen && getCooldown(CHIP_REGENERATION, player._id) == 0

            if (regenAvailable) {

                debug("[STATE-FLEE] REGENERATION available - defensive healing")
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 1.0, 0.2, 0.2, "hide"), availableTP, availableMP))
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 1.0, 0.3, 0.2, "kite"), availableTP, availableMP))
            } else {

                debug("[STATE-FLEE] REGENERATION on cooldown - lifesteal strategy (ENHANCED_LIGHTNINGER spam)")
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.7, 0.5, 1.0, "kite"), availableTP, availableMP))
                push(scenarios, this.createParametricScenario(new ScenarioParams(2, 0.5, 0.3, 1.0, "kite"), availableTP, availableMP))
            }

            push(scenarios, this.createSimpleOffensiveScenario(availableTP, availableMP))
            push(scenarios, this.createStaticAttackScenario(availableTP, availableMP))
        }

        return scenarios
    }

    determineStrategicState() {
        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth

        var playerHPPercent = (playerHP * 100) / playerMaxHP
        var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

        var currentTurn = getTurn()
        var availableTP = getTP()

        if (playerHPPercent < 40) {
            return "FLEE"
        }

        if (enemyHPPercent < 40) {
            
            var estimatedDamage = this.estimateMaxDamageThisTurn(availableTP)
            var killProbability = estimatedDamage / enemyHP

            if (killProbability >= 0.75) {
                return "KILL"
            }
        }

        if (playerHPPercent >= 40 && playerHPPercent <= 60 && enemyHPPercent > 40) {
            return "SUSTAIN"
        }

        var earlyGame = (currentTurn >= 1 && currentTurn <= 4)
        var buffsExpired = this.checkCriticalBuffsExpired()

        if ((earlyGame || buffsExpired) && playerHPPercent > 50 && enemyHPPercent > 60) {
            return "AGGRO"
        }

        return "ATTRITION"
    }

    checkCriticalBuffsExpired() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (str > mag && str > agi) {
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
                var steroidActive = getCooldown(CHIP_STEROID, this._player._id) > 0
                if (!steroidActive) {
                    return true  
                }
            }
        }

        else if (agi > str && agi > mag) {
            var hasReturn = this._player.hasDamageReturn()
            if (!hasReturn) {
                
                var mirrorAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR) &&
                                     getCooldown(CHIP_MIRROR, this._player._id) == 0
                var thornAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN) &&
                                    getCooldown(CHIP_THORN, this._player._id) == 0
                var brambleAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE) &&
                                      getCooldown(CHIP_BRAMBLE, this._player._id) == 0

                if (mirrorAvailable || thornAvailable || brambleAvailable) {
                    return true  
                }
            }
        }

        var hasShield = this._player.hasEffect(EFFECT_RELATIVE_SHIELD)
        if (!hasShield) {
            var fortressAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_FORTRESS) &&
                                   getCooldown(CHIP_FORTRESS, this._player._id) == 0
            var wallAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_WALL) &&
                               getCooldown(CHIP_WALL, this._player._id) == 0

            if (fortressAvailable || wallAvailable) {
                return true  
            }
        }

        return false  
    }

    createAggressiveScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  

        var buffAction = this.getOffensiveBuff()
        if (buffAction != null) {
            push(actions, buffAction)
            tpBudget -= getCachedChipCost(buffAction.chip)
        }

        var damageReturnAction = this.getDamageReturnBuff()
        if (damageReturnAction != null && tpBudget >= getCachedChipCost(damageReturnAction.chip)) {
            push(actions, damageReturnAction)
            tpBudget -= getCachedChipCost(damageReturnAction.chip)
        }

        var debuffAction = this.getDebuffAction()
        if (debuffAction != null && tpBudget >= 4) {
            push(actions, debuffAction)
            tpBudget -= 4
        }

        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getGraphMPCost(moveAction.targetCell)
            if (moveCost < 999) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    createConservativeScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  

        var buffAction = this.getOffensiveBuff()
        if (buffAction != null) {
            push(actions, buffAction)
            tpBudget -= getCachedChipCost(buffAction.chip)
        }

        var damageReturnAction = this.getDamageReturnBuff()
        if (damageReturnAction != null && tpBudget >= getCachedChipCost(damageReturnAction.chip)) {
            push(actions, damageReturnAction)
            tpBudget -= getCachedChipCost(damageReturnAction.chip)
        }

        var defensiveBuff = this.getDefensiveBuff()
        if (defensiveBuff != null && tpBudget >= getCachedChipCost(defensiveBuff.chip)) {
            push(actions, defensiveBuff)
            tpBudget -= getCachedChipCost(defensiveBuff.chip)
        }

        var healAction = this.getHealingAction(tpBudget, 0.7)
        if (healAction != null) {
            push(actions, healAction)
            tpBudget -= getCachedChipCost(healAction.chip)
        }

        var moveAction = this.getMoveToOptimalCell(floor(mpBudget * 0.7))  
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getGraphMPCost(moveAction.targetCell)
            if (moveCost < 999) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 0.7, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    createDefensiveScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  

        var healAction = this.getHealingAction(tpBudget, 0.7)
        if (healAction != null) {
            push(actions, healAction)
            tpBudget -= getCachedChipCost(healAction.chip)
        }

        var defensiveBuff = this.getDefensiveBuff()
        if (defensiveBuff != null && tpBudget >= getCachedChipCost(defensiveBuff.chip)) {
            push(actions, defensiveBuff)
            tpBudget -= getCachedChipCost(defensiveBuff.chip)
        }

        var moveAction = this.getMoveToOptimalCell(floor(mpBudget * 0.5))
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getGraphMPCost(moveAction.targetCell)
            if (moveCost < 999) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 0.5, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    createAllInDamageScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  

        if (this.checkOTKOOpportunity()) {
            
            var distToTarget = getCellDistance(this._player._cellPos, this._target._cellPos)
            var maxWeaponRange = 12  

            if (distToTarget > maxWeaponRange &&
                mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                getCooldown(CHIP_TELEPORTATION, this._player._id) == 0 &&
                tpBudget >= 5) {

                var bestCell = this._fieldMap.getBestWeaponOrChipCell()
                if (bestCell != null && bestCell != -1) {
                    var teleportDist = getCellDistance(this._player._cellPos, bestCell._id)
                    if (teleportDist >= 1 && teleportDist <= 12) {
                        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestCell._id, this._target))
                        tpBudget -= 5
                        simPos = bestCell._id
                    }
                }
            }

            var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
            for (var atk in attackActions) {
                push(actions, atk)
            }

            return actions
        }

        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getGraphMPCost(moveAction.targetCell)
            if (moveCost < 999) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    createKitingScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  

        var attackActions = this.getAttackActions(tpBudget, 0.6, simPos)  
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var kiteAction = this.getKiteAwayAction(mpBudget)
        if (kiteAction != null) {
            push(actions, kiteAction)
        }

        return actions
    }

    createEfficientScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos  

        if (tpBudget >= 30) {  
            var buffAction = this.getOffensiveBuff()
            if (buffAction != null && getCachedChipCost(buffAction.chip) <= 6) {
                push(actions, buffAction)
                tpBudget -= getCachedChipCost(buffAction.chip)
            }
        }

        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getGraphMPCost(moveAction.targetCell)
            if (moveCost < 999) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 0.8, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    createOTKOTeleportScenario(otkoCell, availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP

        if (tpBudget >= 5) {
            push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, otkoCell, this._target))
            tpBudget -= 5
            debug("[OTKO-TELEPORT] Teleporting to OTKO cell " + otkoCell + " for optimal kill positioning")
        }

        var attackActions = this.getAttackActions(tpBudget, 1.0, otkoCell)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    createTeleportEscapeScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP

        if (tpBudget < 5) {
            return null
        }

        var safestCell = -1
        var lowestThreat = 99999
        var playerPos = this._player._cellPos

        for (var cellId in mapKeys(this._fieldMap.damageMap)) {
            var dist = getCellDistance(playerPos, cellId)
            if (dist >= 1 && dist <= 12) {
                var threat = this._fieldMap.getThreatAtCell(cellId)
                if (threat < lowestThreat) {
                    lowestThreat = threat
                    safestCell = cellId
                }
            }
        }

        if (safestCell == -1) {
            return null  
        }

        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, safestCell, this._target))
        tpBudget -= 5
        debug("[TELEPORT-ESCAPE] Evacuating to cell " + safestCell + " (threat: " + lowestThreat + ")")

        if (tpBudget >= 4 && mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0) {
            push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player))
            tpBudget -= 4
            debug("[TELEPORT-ESCAPE] Applying REMISSION heal")
        }

        var shieldAction = this.getDefensiveBuff()
        if (shieldAction != null) {
            var shieldCost = getCachedChipCost(shieldAction.chip)
            if (tpBudget >= shieldCost) {
                push(actions, shieldAction)
                tpBudget -= shieldCost
                debug("[TELEPORT-ESCAPE] Applying shield")
            }
        }

        return actions
    }

    createParametricScenario(params, availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        if (params.healThreshold >= 0) {
            
            if (params.healThreshold >= 0.99) {
                var currentHP = this._player._currHealth
                var maxHP = this._player._maxHealth
                var hpRatio = currentHP / maxHP

                if (hpRatio < params.healThreshold) {
                    
                    var remissionAction = this.getRemissionAction()
                    if (remissionAction != null && tpBudget >= 5) {
                        push(actions, remissionAction)
                        tpBudget -= 5
                    }

                    var regenAction = this.getRegenerationAction()
                    if (regenAction != null && tpBudget >= 3) {
                        push(actions, regenAction)
                        tpBudget -= 3
                    }
                }
            } else {
                
                var healAction = this.getHealingAction(tpBudget, params.healThreshold)
                if (healAction != null) {
                    push(actions, healAction)
                    tpBudget -= getCachedChipCost(healAction.chip)
                }
            }
        }

        if (params.buffStrategy == 1 || params.buffStrategy == 3) {
            
            var offensiveBuff = this.getOffensiveBuff()
            if (offensiveBuff != null && tpBudget >= getCachedChipCost(offensiveBuff.chip)) {
                push(actions, offensiveBuff)
                tpBudget -= getCachedChipCost(offensiveBuff.chip)
            }
        }

        if (params.buffStrategy == 2 || params.buffStrategy == 3) {
            
            var defensiveBuff = this.getDefensiveBuff()
            if (defensiveBuff != null && tpBudget >= getCachedChipCost(defensiveBuff.chip)) {
                push(actions, defensiveBuff)
                tpBudget -= getCachedChipCost(defensiveBuff.chip)
            }
        }

        if (params.buffStrategy == 4) {
            
            var damageReturnBuff = this.getDamageReturnBuff()
            if (damageReturnBuff != null && tpBudget >= getCachedChipCost(damageReturnBuff.chip)) {
                push(actions, damageReturnBuff)
                tpBudget -= getCachedChipCost(damageReturnBuff.chip)
            }

            var debuffAction = this.getDebuffAction()
            if (debuffAction != null && tpBudget >= 4) {
                push(actions, debuffAction)
                tpBudget -= 4
            }
        }

        var appliedLeatherBoots = false
        var leatherBootsBuff = this.getLeatherBootsBuff()
        if (leatherBootsBuff != null && tpBudget >= 3) {
            push(actions, leatherBootsBuff)
            tpBudget -= 3
            mpBudget += 2  
            appliedLeatherBoots = true
        }

        if (appliedLeatherBoots) {
            var adrenalineBuff = this.getAdrenalineBuff()
            if (adrenalineBuff != null && tpBudget >= 1) {
                push(actions, adrenalineBuff)
                tpBudget -= 1
                tpBudget += 5  
                debug("[SCENARIO] LEATHER_BOOTS + ADRENALINE combo: Net +1 TP + mobility")
            }
        }

        if (params.repositioning == "otko" && this.checkOTKOOpportunity()) {
            var distToTarget = getCellDistance(this._player._cellPos, this._target._cellPos)
            var maxWeaponRange = 12

            if (distToTarget > maxWeaponRange &&
                mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                getCooldown(CHIP_TELEPORTATION, this._player._id) == 0 &&
                tpBudget >= 5) {

                var bestCell = this._fieldMap.getBestWeaponOrChipCell()
                if (bestCell != null && bestCell != -1) {
                    var teleportDist = getCellDistance(this._player._cellPos, bestCell._id)
                    if (teleportDist >= 1 && teleportDist <= 12) {
                        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestCell._id, this._target))
                        tpBudget -= 5
                        simPos = bestCell._id
                    }
                }
            }
        }

        if (params.movementFraction > 0 && params.repositioning != "otko") {
            var mpToUse = floor(mpBudget * params.movementFraction)
            var moveAction = this.getMoveToOptimalCell(mpToUse)
            if (moveAction != null) {
                push(actions, moveAction)
                var moveCost = getGraphMPCost(moveAction.targetCell)
                if (moveCost < 999) {
                    mpBudget -= moveCost
                    simPos = moveAction.targetCell
                }
            }
        }

        if (tpBudget >= 4) {
            
            var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
            for (var atk in attackActions) {
                push(actions, atk)
            }
        }

        if (params.repositioning == "hide") {
            var hideAction = this.getHideAndSeekAction(mpBudget)
            if (hideAction != null) {
                push(actions, hideAction)
            }
        } else if (params.repositioning == "kite") {
            var kiteAction = this.getKiteAwayAction(mpBudget)
            if (kiteAction != null) {
                push(actions, kiteAction)
            }
        }
        
        return actions
    }

    getOffensiveBuff() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (str > mag && str > agi) {
            
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player)
            }
        } else if (agi > str && agi > mag) {
            
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WARM_UP)) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_WARM_UP, -1, this._player)
            }
        }

        return null
    }

    getDefensiveBuff() {
        var currentTP = getTP()

        var hasShield = this._player.hasEffect(EFFECT_RELATIVE_SHIELD)
        var shieldRemaining = hasShield ? this._player.getEffectRemaining(EFFECT_RELATIVE_SHIELD) : 0

        if (hasShield && shieldRemaining > 1) {
            return null  
        }

        var hasFortress = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_FORTRESS)
        var hasWall = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WALL)

        var fortressCd = hasFortress ? getCooldown(CHIP_FORTRESS, this._player._id) : 999
        var wallCd = hasWall ? getCooldown(CHIP_WALL, this._player._id) : 999

        if (hasFortress && fortressCd == 0 && currentTP >= 9) {  
            return new Action(Action.ACTION_BUFF, -1, CHIP_FORTRESS, -1, this._player)
        }

        if (hasWall && wallCd == 0 && currentTP >= 6) {  
            return new Action(Action.ACTION_BUFF, -1, CHIP_WALL, -1, this._player)
        }

        return null  
    }

    getLeatherBootsBuff() {
        var baseMP = getTotalMP()

        if (baseMP >= 10) {
            return null
        }

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS)) {
            return null
        }

        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            var adrenalineCd = getCooldown(CHIP_ADRENALINE, this._player._id)
            if (adrenalineCd > 0) {
                
                return null
            }
        }

        var currentTP = getTP()

        var hasMPBuff = this._player.hasEffect(EFFECT_BUFF_MP)
        var buffRemaining = hasMPBuff ? this._player.getEffectRemaining(EFFECT_BUFF_MP) : 0

        if (hasMPBuff && buffRemaining > 1) {
            return null  
        }

        var bootsCd = getCooldown(CHIP_LEATHER_BOOTS, this._player._id)
        if (bootsCd == 0 && currentTP >= 6) {  
            return new Action(Action.ACTION_BUFF, -1, CHIP_LEATHER_BOOTS, -1, this._player)
        }

        return null  
    }

    getAdrenalineBuff() {
        var baseMP = getTotalMP()

        if (baseMP >= 10) {
            return null
        }

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            return null
        }

        var currentTP = getTP()

        var adrenalineCd = getCooldown(CHIP_ADRENALINE, this._player._id)
        if (adrenalineCd > 0) {
            return null  
        }

        if (currentTP >= 3) {  
            return new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, -1, this._player)
        }

        return null  
    }

    getMoveToOptimalCell(mpBudget) {
        if (mpBudget <= 0) return null

        var otkoCells = this._fieldMap.getAllOTKOCells()
        if (count(otkoCells) > 0) {
            
            var bestOTKO = null
            var bestOTKOScore = -999999

            for (var otkoCell in otkoCells) {
                var pathLen = getGraphMPCost(otkoCell._id)
                if (pathLen < 999 && pathLen <= mpBudget) {
                    
                    var score = otkoCell._otkoKillProbability * 10000 + otkoCell._otkoDamage - pathLen * 10
                    if (score > bestOTKOScore) {
                        bestOTKOScore = score
                        bestOTKO = otkoCell
                    }
                }
            }

            if (bestOTKO != null) {
                debug("[MOVE-OTKO] Prioritizing OTKO cell " + bestOTKO._id +
                      " (kill prob=" + floor(bestOTKO._otkoKillProbability * 100) +
                      "%, damage=" + floor(bestOTKO._otkoDamage) + ")")
                return new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, bestOTKO._id, this._target)
            }
        }

        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var hpPercent = (playerHP * 100) / playerMaxHP

        var threatWeight = 0.3
        if (hpPercent < 40) {
            threatWeight = 0.8
        } else if (hpPercent < 70) {
            threatWeight = 0.5
        }

        var bestCell = this._fieldMap.findBestTacticalCell(mpBudget, threatWeight)
        if (bestCell == null || bestCell == -1) {

            bestCell = this._fieldMap.getBestWeaponOrChipCell()
            if (bestCell == null || bestCell == -1) {
                // Fallback: no attack cells available, just move toward enemy
                debug("[MOVE-APPROACH] No attack cells available, moving toward enemy")
                var approachCell = this.getApproachEnemyCell(mpBudget)
                if (approachCell != null && approachCell != -1) {
                    return new Action(Action.MOVEMENT_APPROACH, -1, -1, approachCell, this._target)
                }
                return null
            }

            var pathLength = getGraphMPCost(bestCell._id)
            if (pathLength >= 999 || pathLength > mpBudget) {
                bestCell = this._strategy.findBestReachableDamageCell(mpBudget)
                if (bestCell == null || bestCell == -1) {
                    // Fallback: no reachable damage cells, just move toward enemy
                    debug("[MOVE-APPROACH] No reachable damage cells, moving toward enemy")
                    var approachCell = this.getApproachEnemyCell(mpBudget)
                    if (approachCell != null && approachCell != -1) {
                        return new Action(Action.MOVEMENT_APPROACH, -1, -1, approachCell, this._target)
                    }
                    return null
                }
            }
        }

        var action = new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, bestCell._id, this._target)
        return action
    }

    getHideAndSeekAction(mpBudget) {
        if (mpBudget <= 0) return null

        if (this._hideCache != null) {
            return this._hideCache
        }

        var hideCell = this._fieldMap.findHideAndSeekCell("defensive")
        if (hideCell != null && hideCell != -1) {
            this._hideCache = new Action(Action.MOVEMENT_HNS, -1, -1, hideCell, this._target)
            return this._hideCache
        }

        return null
    }

    getKiteAwayAction(mpBudget) {
        if (mpBudget <= 0) return null

        if (this._kiteCache != null) {
            return this._kiteCache
        }

        this._kiteCache = new Action(Action.MOVEMENT_FLEE, -1, -1, -1, this._target)
        return this._kiteCache
    }

    getApproachEnemyCell(mpBudget) {
        if (mpBudget <= 0) return null

        // Get all reachable cells within MP budget
        var reachableCells = getReachableCells()
        if (reachableCells == null || count(reachableCells) == 0) return null

        var enemyPos = this._target._cellPos
        var currentDist = getCellDistance(this._player._cellPos, enemyPos)
        if (currentDist == null) return null

        // Find the reachable cell that gets us closest to the enemy
        var bestCell = null
        var bestDist = currentDist

        for (var cellId in reachableCells) {
            var cellDist = getCellDistance(cellId, enemyPos)
            if (cellDist == null) continue

            // Only consider cells that get us closer
            if (cellDist < bestDist) {
                var pathCost = getGraphMPCost(cellId)
                if (pathCost < 999 && pathCost <= mpBudget) {
                    bestDist = cellDist
                    bestCell = cellId
                }
            }
        }

        if (bestCell != null) {
            debug("[APPROACH-ENEMY] Moving from dist=" + currentDist + " to dist=" + bestDist + " (cell " + bestCell + ")")
            return bestCell
        }

        return null
    }

    getWeaponSpamActions(tpBudget, fraction, simPos = -1) {
        var actions = []
        var tpToUse = floor(tpBudget * fraction)

        var checkPos = (simPos == -1) ? this._player._cellPos : simPos

        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]
            if (tpToUse < weapon._cost) continue

            var dist = getCellDistance(checkPos, this._target._cellPos)
            if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue
            if (!lineOfSight(checkPos, this._target._cellPos)) continue

            var uses = min(weapon._maxUse, floor(tpToUse / weapon._cost))
            for (var i = 0; i < uses; i++) {
                push(actions, new Action(Action.ACTION_DIRECT, weapon._id, -1, this._target._cellPos, this._target))
                tpToUse -= weapon._cost
            }
        }

        return actions
    }

    getDamageReturnBuff() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (agi <= str || agi <= mag) return null

        var currentTP = getTP()

        var hasReturn = this._player.hasDamageReturn()
        var returnRemaining = hasReturn ? this._player.getDamageReturnRemaining() : 0

        if (hasReturn && returnRemaining > 1) {
            return null  
        }

        var distToEnemy = getCellDistance(this._player._cellPos, this._target._cellPos)
        if (distToEnemy == null) distToEnemy = 99
        var inCloseCombat = distToEnemy <= 8

        var hasMirror = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_MIRROR)
        var hasThorn = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_THORN)
        var hasBramble = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_BRAMBLE)

        var mirrorCd = hasMirror ? getCooldown(CHIP_MIRROR, this._player._id) : 999
        var thornCd = hasThorn ? getCooldown(CHIP_THORN, this._player._id) : 999
        var brambleCd = hasBramble ? getCooldown(CHIP_BRAMBLE, this._player._id) : 999

        var mirrorReady = mirrorCd == 0 && hasMirror && currentTP >= 5
        var thornReady = thornCd == 0 && hasThorn && currentTP >= 4
        var brambleReady = brambleCd == 0 && hasBramble && currentTP >= 4

        if (brambleReady && inCloseCombat && currentTP >= 10) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_BRAMBLE, -1, this._player)
        }

        if (currentTP < 15) {
            if (thornReady) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_THORN, -1, this._player)  
            }
            if (mirrorReady && currentTP >= 10) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)  
            }
            return null  
        }

        if (mirrorReady && thornReady && currentTP >= 15) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)
        }

        if (mirrorReady) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)
        }

        if (thornReady) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_THORN, -1, this._player)
        }

        return null  
    }

    getHealingAction(tpBudget, hpThreshold = 0.7) {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP

        if (hpRatio < 0.35 &&
            getCooldown(CHIP_REGENERATION, this._player._id) == 0 &&
            mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION) &&
            tpBudget >= 8) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, -1, this._player)
        }

        if (hpRatio < 0.80 &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0 &&
            mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            tpBudget >= 5) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player)
        }

        return null
    }

    getRemissionAction() {
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player)
        }
        return null
    }

    getRegenerationAction() {
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION) &&
            getCooldown(CHIP_REGENERATION, this._player._id) == 0) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, -1, this._player)
        }
        return null
    }

    getDebuffAction() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (str <= mag || str <= agi) return null

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_LIBERATION)) return null
        if (getCooldown(CHIP_LIBERATION, this._player._id) != 0) return null

        var targetBuffs = 0
        if (this._target.hasEffect(EFFECT_ABSOLUTE_SHIELD)) targetBuffs++
        if (this._target.hasEffect(EFFECT_RELATIVE_SHIELD)) targetBuffs++
        if (this._target.hasEffect(EFFECT_DAMAGE_RETURN)) targetBuffs++
        if (this._target.hasEffect(EFFECT_BUFF_RESISTANCE)) targetBuffs++
        if (this._target.hasEffect(EFFECT_BUFF_STRENGTH)) targetBuffs++

        if (targetBuffs > 0) {
            return new Action(Action.ACTION_DEBUFF, -1, CHIP_LIBERATION, this._target._cellPos, this._target)
        }

        return null
    }

    getAttackActions(tpBudget, fraction, simPos) {
        var actions = []
        
        var tpToUse = tpBudget  
        var weaponUses = [:]  
        var chipCooldowns = [:]  

        while (tpToUse >= 4) {  
            var bestAttack = this.findBestAvailableAttack(simPos, weaponUses, chipCooldowns)
            if (bestAttack == null) break  

            var attackCost = bestAttack['cost']
            if (tpToUse < attackCost) break  

            var attackType = bestAttack['type']
            var attackId = bestAttack['id']

            if (attackType == 'weapon') {
                push(actions, new Action(Action.ACTION_DIRECT, attackId, -1, this._target._cellPos, this._target))
                var currentUses = weaponUses[attackId]
                if (currentUses == null) currentUses = 0
                weaponUses[attackId] = currentUses + 1
            } else {
                push(actions, new Action(Action.ACTION_DIRECT, -1, attackId, this._target._cellPos, this._target))
                chipCooldowns[attackId] = true  
            }

            tpToUse -= attackCost
        }

        return actions
    }

    findBestAvailableAttack(simPos, weaponUses, chipCooldowns) {
        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom
        var sci = this._player._science
        var bestAttack = null
        var bestDamage = 0

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]

            var currentUses = weaponUses[weaponId]
            if (currentUses == null) currentUses = 0
            if (currentUses >= weapon._maxUse) continue

            if (mapContainsKey(this._fieldMap.weaponHitmap, weaponId)) {
                var shooterCells = this._fieldMap.weaponHitmap[weaponId]
                var canShootFromHere = false
                for (var cell in shooterCells) {
                    if (cell == simPos) {
                        canShootFromHere = true
                        break
                    }
                }
                if (!canShootFromHere) continue
            } else {
                var dist = getCellDistance(simPos, this._target._cellPos)
                if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue

                if (!lineOfSight(simPos, this._target._cellPos)) {
                    continue
                }
            }

            var damage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, weaponId, this._target)
            if (damage > bestDamage) {
                var aoeCheck = this._strategy.checkAoEWeaponSafety(weaponId, this._target._cellPos, simPos)
                if (aoeCheck['safe']) {
                    bestDamage = damage
                    bestAttack = ["type": "weapon", "id": weaponId, "cost": weapon._cost, "damage": damage]
                }
            }
        }

        var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG,
                           CHIP_FIRE_BALL, CHIP_ROCK, CHIP_FLAME, CHIP_STALACTITE, CHIP_ARSENIC]

        for (var chipId in damageChips) {
            if (!mapContainsKey(this._arsenal.playerEquippedChips, chipId)) continue
            if (chipCooldowns[chipId] != null) continue  
            if (getCooldown(chipId, this._player._id) > 0) continue  

            var chip = this._arsenal.playerEquippedChips[chipId]
            var dist = getCellDistance(simPos, this._target._cellPos)
            if (dist == null || dist < chip._minRange || dist > chip._maxRange) continue
            if (!lineOfSight(simPos, this._target._cellPos)) continue

            var damage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, chipId, this._target)
            if (damage > bestDamage) {
                var aoeCheck = this._strategy.checkAoESafetyFromCell(chipId, this._target._cellPos, simPos)
                if (aoeCheck['safe']) {
                    bestDamage = damage
                    bestAttack = ["type": "chip", "id": chipId, "cost": getCachedChipCost(chipId), "damage": damage]
                }
            }
        }

        return bestAttack
    }

    checkOTKOOpportunity() {
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth
        var hpPercent = (enemyHP * 100) / enemyMaxHP

        return (hpPercent < 35 || enemyHP < 500)
    }

    estimateMaxDamageThisTurn(availableTP) {
        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom
        var sci = this._player._science
        var totalDamage = 0

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]
            var weaponDamage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, weaponId, this._target)
            var maxUses = min(weapon._maxUse, floor(availableTP / weapon._cost))
            totalDamage += weaponDamage * maxUses
        }

        var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG]
        var bestChipDamage = 0
        for (var chipId in damageChips) {
            if (!mapContainsKey(this._arsenal.playerEquippedChips, chipId)) continue
            if (getCooldown(chipId, this._player._id) > 0) continue

            var chipDamage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, chipId, this._target)
            bestChipDamage = max(bestChipDamage, chipDamage)
        }
        totalDamage += bestChipDamage

        return totalDamage
    }

    createNeutrinoStackingScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return null  
        }

        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) return null

        var isDiagonal = this.isDiagonal(simPos, this._target._cellPos)
        if (!isDiagonal || dist < 2 || dist > 6) {
            return null  
        }

        if (!lineOfSight(simPos, this._target._cellPos)) {
            return null  
        }

        if (tpBudget < 16) {
            return null
        }

        var currentStacks = this._arsenal.getVulnerabilityStacks(this._target)
        var vulnRemaining = this._target.getEffectRemaining(EFFECT_VULNERABILITY)
        if (currentStacks >= 3 && vulnRemaining >= 2) {
            return null  
        }

        debug("[COMBO-NEUTRINO] Creating Neutrino stacking scenario (3x vuln + weapons)")

        if (getWeapon() != WEAPON_NEUTRINO) {
            push(actions, new Action(Action.ACTION_WEAPON_SWAP, -1, -1, -1, this._target))
            actions[count(actions) - 1].weapon = WEAPON_NEUTRINO
            tpBudget -= 1
        }

        for (var i = 0; i < 3; i++) {
            if (tpBudget >= 4) {
                push(actions, new Action(Action.ACTION_DIRECT, WEAPON_NEUTRINO, -1, this._target._cellPos, this._target))
                tpBudget -= 4
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    createGrappleHeavySwordScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD)) {
            return null  
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
            return null  
        }
        if (getCooldown(CHIP_GRAPPLE, this._player._id) > 0) {
            return null  
        }

        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) {
            return null
        }

        if (tpBudget < 10) {  
            return null
        }

        debug("[COMBO-GRAPPLE-HS] Creating GRAPPLE-HEAVY_SWORD scenario (optimistic - simulator will validate)")

        var playerX = getCellX(simPos)
        var playerY = getCellY(simPos)
        var enemyPos = this._target._cellPos
        var enemyX = getCellX(enemyPos)
        var enemyY = getCellY(enemyPos)

        var isOnSameLine = (playerY == enemyY) || (playerX == enemyX)
        if (!isOnSameLine) {
            debug("[COMBO-GRAPPLE-HS] ABORT: Enemy not on same H/V line (player=" + simPos + " enemy=" + enemyPos + ")")
            return null
        }

        var grappleCell = -1
        if (playerY == enemyY) {

            grappleCell = (enemyX < playerX) ? getCellFromXY(playerX - 1, playerY) : getCellFromXY(playerX + 1, playerY)
        } else {

            grappleCell = (enemyY < playerY) ? getCellFromXY(playerX, playerY - 1) : getCellFromXY(playerX, playerY + 1)
        }

        debug("[COMBO-GRAPPLE-HS] Calculated grapple destination: cell " + grappleCell + " (enemy at " + enemyPos + ")")

        if (grappleCell == -1 || grappleCell == null) {
            return null
        }

        push(actions, new Action(Action.ACTION_DIRECT, -1, CHIP_GRAPPLE, grappleCell, this._target))
        tpBudget -= 3

        if (getWeapon() != WEAPON_HEAVY_SWORD) {
            push(actions, new Action(Action.ACTION_WEAPON_SWAP, WEAPON_HEAVY_SWORD, -1, -1, this._target))
            tpBudget -= 1
        }

        push(actions, new Action(Action.ACTION_DIRECT, WEAPON_HEAVY_SWORD, -1, this._target._cellPos, this._target))
        tpBudget -= 15

        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    createSteroidOTKOScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
            return null
        }
        if (getCooldown(CHIP_STEROID, this._player._id) > 0) {
            return null
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            return null
        }
        if (getCooldown(CHIP_TELEPORTATION, this._player._id) > 0) {
            return null
        }

        if (tpBudget < 15) {  
            return null
        }

        debug("[COMBO-STEROID-OTKO] Creating STEROID + OTKO scenario (optimistic)")

        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player))
        tpBudget -= 7

        var bestOTKO = this._fieldMap.getBestOTKOCell()
        if (bestOTKO == null) {
            
            bestOTKO = this._fieldMap.getBestWeaponOrChipCell()
            if (bestOTKO == null || bestOTKO == -1) {
                return null
            }
        }

        var teleportDist = getCellDistance(this._player._cellPos, bestOTKO._id)
        if (teleportDist == null || teleportDist < 1 || teleportDist > 12) {
            return null
        }

        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestOTKO._id, this._target))
        tpBudget -= 5

        var attackActions = this.getAttackActions(tpBudget, 1.0, bestOTKO._id)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    createSteroidRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
            return null
        }
        if (getCooldown(CHIP_STEROID, this._player._id) > 0) {
            return null
        }

        if (tpBudget < 10) {
            return null
        }

        debug("[COMBO-STEROID-RECHECK] Creating two-phase STEROID scenario (adaptive)")

        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player))
        tpBudget -= 7

        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget

        var checkpoint = Action.createCheckpoint("BUFF_RECHECK", "evaluateBuffRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-STEROID-RECHECK] Added checkpoint: will re-evaluate kill probability with +160 STR")

        return actions
    }

    createNeutrinoRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var simPos = this._player._cellPos

        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return null
        }

        if (tpBudget < 15) {
            return null
        }

        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) return null

        var isOnAxis = getCellX(simPos) == getCellX(this._target._cellPos) ||
                       getCellY(simPos) == getCellY(this._target._cellPos)
        if (!isOnAxis) return null
        if (dist < 2 || dist > 6) return null

        debug("[COMBO-NEUTRINO-RECHECK] Creating two-phase Neutrino stacking scenario (adaptive)")

        var neutrinoCount = floor((tpBudget - 10) / 4)  
        if (neutrinoCount > 3) neutrinoCount = 3  
        if (neutrinoCount < 2) neutrinoCount = 2  

        for (var n = 0; n < neutrinoCount; n++) {
            push(actions, new Action(Action.ACTION_DIRECT, WEAPON_NEUTRINO, -1, -1, this._target))
            tpBudget -= 4
        }

        var expectedVuln = neutrinoCount * 8

        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget
        context['vulnerabilityPercent'] = expectedVuln  

        var checkpoint = Action.createCheckpoint("VULNERABILITY_RECHECK", "evaluateVulnerabilityRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-NEUTRINO-RECHECK] Added checkpoint: will re-evaluate with " + expectedVuln + "% vulnerability")

        return actions
    }

    createGrappleHSRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var simPos = this._player._cellPos

        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD)) {
            return null
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
            return null
        }
        if (getCooldown(CHIP_GRAPPLE, this._player._id) > 0) {
            return null
        }

        if (tpBudget < 12) {
            return null
        }

        var enemyPos = this._target._cellPos
        var isOnAxis = getCellX(simPos) == getCellX(enemyPos) ||
                       getCellY(simPos) == getCellY(enemyPos)
        if (!isOnAxis) return null

        var dist = getCellDistance(simPos, enemyPos)
        if (dist == null) return null
        if (dist < 2 || dist > 8) return null  

        debug("[COMBO-GRAPPLE-HS-RECHECK] Creating two-phase GRAPPLE pull scenario (adaptive)")

        var dx = getCellX(enemyPos) - getCellX(simPos)
        var dy = getCellY(enemyPos) - getCellY(simPos)
        var dirX = 0
        var dirY = 0
        if (dx != 0) dirX = dx / abs(dx)  
        if (dy != 0) dirY = dy / abs(dy)

        var grappleTargetCell = getCellFromXY(getCellX(simPos) + dirX, getCellY(simPos) + dirY)
        if (grappleTargetCell == null) {
            return null  
        }

        push(actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_GRAPPLE, grappleTargetCell, this._target))
        tpBudget -= 4

        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget
        context['vulnerabilityPercent'] = 0  

        var checkpoint = Action.createCheckpoint("VULNERABILITY_RECHECK", "evaluateVulnerabilityRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-GRAPPLE-HS-RECHECK] Added checkpoint: will re-evaluate after pulling enemy to distance 2")

        return actions
    }

    createHealRecheckScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION)) {
            return null
        }
        if (getCooldown(CHIP_REMISSION, this._player._id) > 0) {
            return null
        }

        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var playerHPPercent = (playerHP * 100) / playerMaxHP

        if (playerHPPercent > 70) {
            return null  
        }

        if (tpBudget < 10) {
            return null
        }

        debug("[COMBO-HEAL-RECHECK] Creating two-phase healing scenario (adaptive)")

        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player))
        tpBudget -= 5

        var context = [:]
        context['target'] = this._target
        context['remainingTP'] = tpBudget

        var checkpoint = Action.createCheckpoint("HEAL_RECHECK", "evaluateHealRecheckContinuation", context)
        push(actions, checkpoint)

        debug("[COMBO-HEAL-RECHECK] Added checkpoint: will re-evaluate aggression after healing")

        return actions
    }

    createNeutrinoOTKOScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        if (!mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return null
        }
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            return null
        }
        if (getCooldown(CHIP_TELEPORTATION, this._player._id) > 0) {
            return null
        }

        if (tpBudget < 27) {
            return null
        }

        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth
        var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

        if (enemyHPPercent >= 40) {
            return null  
        }

        var dist = getCellDistance(simPos, this._target._cellPos)
        if (dist == null) return null

        var isDiagonal = this.isDiagonal(simPos, this._target._cellPos)
        if (!isDiagonal || dist < 2 || dist > 6) {
            return null  
        }

        if (!lineOfSight(simPos, this._target._cellPos)) {
            return null
        }

        debug("[COMBO-NEUTRINO-OTKO] Creating Neutrino pre-stack + teleport OTKO scenario")

        if (getWeapon() != WEAPON_NEUTRINO) {
            push(actions, new Action(Action.ACTION_WEAPON_SWAP, -1, -1, -1, this._target))
            actions[count(actions) - 1].weapon = WEAPON_NEUTRINO
            tpBudget -= 1
        }

        for (var i = 0; i < 3; i++) {
            if (tpBudget >= 4) {
                push(actions, new Action(Action.ACTION_DIRECT, WEAPON_NEUTRINO, -1, this._target._cellPos, this._target))
                tpBudget -= 4
            }
        }

        var bestOTKO = this._fieldMap.getBestOTKOCell()
        if (bestOTKO == null) {
            bestOTKO = this._fieldMap.getBestWeaponOrChipCell()
            if (bestOTKO == null) {
                return null
            }
        }

        var teleportDist = getCellDistance(simPos, bestOTKO._id)
        if (teleportDist == null || teleportDist < 1 || teleportDist > 12) {
            return null
        }

        push(actions, new Action(Action.ACTION_TELEPORT, -1, CHIP_TELEPORTATION, bestOTKO._id, this._target))
        tpBudget -= 5

        var attackActions = this.getAttackActions(tpBudget, 1.0, bestOTKO._id)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    createAdrenalineComboScenario(comboScenarioCreator, requiredTP, availableTP, availableMP) {
        var tpGap = requiredTP - availableTP

        if (tpGap < 1 || tpGap > 4) {
            return null
        }

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            return null
        }
        if (getCooldown(CHIP_ADRENALINE, this._player._id) > 0) {
            return null
        }

        if (availableTP < 1) {
            return null
        }

        debug("[COMBO-ADRENALINE] Using ADRENALINE to bridge " + tpGap + " TP gap for combo")

        var actions = []

        push(actions, new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, -1, this._player))
        var newTPBudget = availableTP - 1 + 5  

        var comboActions = comboScenarioCreator(newTPBudget, availableMP)
        if (comboActions == null || count(comboActions) == 0) {
            return null  
        }

        for (var action in comboActions) {
            push(actions, action)
        }

        return actions
    }

    createStaticAttackScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var simPos = this._player._cellPos  

        debug("[BASELINE-STATIC] Creating static attack scenario (no movement)")

        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        return actions
    }

    createSimpleOffensiveScenario(availableTP, availableMP) {
        var actions = []
        var tpBudget = availableTP
        var mpBudget = availableMP
        var simPos = this._player._cellPos

        debug("[BASELINE-OFFENSIVE] Creating simple offensive scenario (move + attack)")

        var moveAction = this.getMoveToOptimalCell(mpBudget)
        if (moveAction != null) {
            push(actions, moveAction)
            var moveCost = getGraphMPCost(moveAction.targetCell)
            if (moveCost < 999) {
                mpBudget -= moveCost
                simPos = moveAction.targetCell  
            }
        }

        var attackActions = this.getAttackActions(tpBudget, 1.0, simPos)
        for (var atk in attackActions) {
            push(actions, atk)
        }

        var hideAction = this.getHideAndSeekAction(mpBudget)
        if (hideAction != null) {
            push(actions, hideAction)
        }

        return actions
    }

    isDiagonal(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        var dx = abs(x2 - x1)
        var dy = abs(y2 - y1)
        return dx == dy && dx > 0  
    }

    isOnSameLine(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        return (x1 == x2 || y1 == y2)  
    }
}
