// ========================================
// Kill Planning Module
// ========================================
// Detects 2-turn kill opportunities and manages TP reservation
// Prevents wasting TP on buffs when enemy can be killed next turn

include('debug_config.lk')

global KILL_PLAN_STATE = null  // Global kill plan state

class KillPlanner {
    _arsenal = null
    _player = null
    _target = null

    constructor(arsenal, player, target) {
        this._arsenal = arsenal
        this._player = player
        this._target = target
    }

    // Calculate maximum possible damage this turn with all TP
    calculateMaxDamageThisTurn(availableTP) {
        var damageItems = []

        // Get all equipped damage-dealing weapons
        var weapons = mapValues(this._arsenal.playerEquippedWeapons)
        for (var weapon in weapons) {
            if (weapon._cost <= availableTP) {
                var netDmg = this._arsenal.getNetDamageAgainstTarget(
                    this._player._strength,
                    this._player._magic,
                    this._player._wisdom,
                    this._player._science,
                    weapon._id,
                    this._target
                )

                if (netDmg > 0) {
                    push(damageItems, [
                        'id': weapon._id,
                        'cost': weapon._cost,
                        'damage': netDmg,
                        'maxUse': weapon._maxUse,
                        'isWeapon': true
                    ])
                }
            }
        }

        // Get all equipped damage-dealing chips
        var chips = mapValues(this._arsenal.playerEquippedChips)
        for (var chip in chips) {
            if (chip._cost <= availableTP && chip._damageType != null) {
                var netDmg = this._arsenal.getNetDamageAgainstTarget(
                    this._player._strength,
                    this._player._magic,
                    this._player._wisdom,
                    this._player._science,
                    chip._id,
                    this._target
                )

                if (netDmg > 0) {
                    push(damageItems, [
                        'id': chip._id,
                        'cost': chip._cost,
                        'damage': netDmg,
                        'maxUse': 1,
                        'isWeapon': false
                    ])
                }
            }
        }

        // Sort by damage/cost ratio (greedy selection)
        arraySort(damageItems, function(a, b) {
            var ratioA = a['damage'] / a['cost']
            var ratioB = b['damage'] / b['cost']
            return ratioB - ratioA
        })

        // Greedy TP allocation
        var remainingTP = availableTP
        var totalDamage = 0

        for (var item in damageItems) {
            var cost = item['cost']
            var damage = item['damage']
            var maxUse = item['maxUse']
            var isWeapon = item['isWeapon']

            if (isWeapon) {
                // Weapons can be used multiple times
                var affordableUses = floor(remainingTP / cost)
                var actualUses = min(affordableUses, maxUse)

                totalDamage += damage * actualUses
                remainingTP -= cost * actualUses
            } else {
                // Chips can only be used once
                if (remainingTP >= cost) {
                    totalDamage += damage
                    remainingTP -= cost
                }
            }
        }

        return totalDamage
    }

    // Detect 2-turn kill opportunity
    detect2TurnKill() {
        var targetHP = this._target._currHp
        var currentTP = this._player._currTp

        // Calculate damage we can do this turn with ALL TP
        var damage1 = this.calculateMaxDamageThisTurn(currentTP)

        // Calculate damage we can do next turn (assume full TP regen)
        var nextTurnTP = min(12, currentTP + 6)  // Assume 6 TP regen
        var damage2 = this.calculateMaxDamageThisTurn(nextTurnTP)

        // Check if 2-turn kill is possible
        var totalDamage = damage1 + damage2
        var canKill2Turn = (totalDamage >= targetHP)

        // Check if 1-turn kill is already possible
        var canKill1Turn = (damage1 >= targetHP)

        var result = [
            'canKill1Turn': canKill1Turn,
            'canKill2Turn': canKill2Turn,
            'damage1': damage1,
            'damage2': damage2,
            'totalDamage': totalDamage,
            'targetHP': targetHP,
            'tpReserveNeeded': 0
        ]

        if (canKill2Turn && !canKill1Turn) {
            // Calculate minimum TP needed next turn to finish
            var hpAfterThisTurn = targetHP - damage1
            var minTPNeeded = this.calculateMinTPForDamage(hpAfterThisTurn)

            result['tpReserveNeeded'] = minTPNeeded
            debugInfo("[KILL-PLAN] 2-turn kill detected! Need " + minTPNeeded + " TP next turn to finish (" + hpAfterThisTurn + " HP remaining)")
        }

        return result
    }

    // Calculate minimum TP needed to deal specified damage
    calculateMinTPForDamage(targetDamage) {
        // Find most efficient damage source
        var weapons = mapValues(this._arsenal.playerEquippedWeapons)
        var bestRatio = 0
        var bestCost = 12

        for (var weapon in weapons) {
            var netDmg = this._arsenal.getNetDamageAgainstTarget(
                this._player._strength,
                this._player._magic,
                this._player._wisdom,
                this._player._science,
                weapon._id,
                this._target
            )

            if (netDmg > 0) {
                var ratio = netDmg / weapon._cost
                if (ratio > bestRatio) {
                    bestRatio = ratio
                    bestCost = weapon._cost
                }
            }
        }

        if (bestRatio > 0) {
            var usesNeeded = ceil(targetDamage / (bestRatio * bestCost))
            return min(12, usesNeeded * bestCost)
        }

        return 12  // Fallback: reserve full TP
    }

    // Update global kill plan state
    updateGlobalKillPlan() {
        var plan = this.detect2TurnKill()

        KILL_PLAN_STATE = [
            'active': plan['canKill2Turn'] && !plan['canKill1Turn'],
            'tpReserve': plan['tpReserveNeeded'],
            'targetHP': plan['targetHP'],
            'damage1': plan['damage1'],
            'damage2': plan['damage2']
        ]

        return KILL_PLAN_STATE
    }
}

// Helper: Check if we're in KILL_RESERVE state
function isKillReserveActive() {
    if (KILL_PLAN_STATE == null) return false
    return KILL_PLAN_STATE['active']
}

// Helper: Get reserved TP amount
function getReservedTP() {
    if (KILL_PLAN_STATE == null) return 0
    if (!KILL_PLAN_STATE['active']) return 0
    return KILL_PLAN_STATE['tpReserve']
}

// Helper: Get available TP after reservation
function getAvailableTPAfterReservation(currentTP) {
    var reserved = getReservedTP()
    return max(0, currentTP - reserved)
}
