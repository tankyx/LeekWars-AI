/**
 * ProbabilityDistribution.lk - Probability distribution with atoms and density
 *
 * Represents a mixed probability distribution:
 * - Discrete atoms: point masses with specific probabilities
 * - Continuous density: described by piecewise polynomial function
 *
 * Used for calculating damage probability distributions in LeekWars
 */

include("polynomial");
include("piecewise_function");

public class ProbabilityDistribution {
    // Atoms: {value: number, probability: number}
    private var atoms;

    // Density function (piecewise polynomial)
    // Note: integral may be < 1 if atoms exist
    private var density;

    /**
     * Constructor
     * @param atoms - array of {value: number, probability: number}
     * @param density - PiecewiseFunction representing continuous part
     */
    public ProbabilityDistribution(atoms, density) {
        if (atoms == null) atoms = [];
        if (density == null) density = PiecewiseFunction.zero();

        this.atoms = atoms;
        this.density = density;
        this._mergeAtoms();
    }

    /**
     * Create distribution from rectangle (uniform distribution)
     * Used for item damage ranges without critical hits
     */
    public static fromRectangle(min, max) {
        var rect = PiecewiseFunction.rectangle(min, max);
        return new ProbabilityDistribution([], rect);
    }

    /**
     * Create distribution for item with critical hit chance
     * @param minDamage - minimum damage without crit
     * @param maxDamage - maximum damage without crit
     * @param critProb - probability of critical hit
     * @param critFactor - critical damage multiplier (usually 1.3)
     */
    public static fromRectangleWithCrit(minDamage, maxDamage, critProb, critFactor) {
        // Non-crit rectangle: (1 - critProb) * rectangle[minDamage, maxDamage]
        var noCritRect = PiecewiseFunction.rectangle(minDamage, maxDamage);
        noCritRect = noCritRect.multiplyByConstant(1 - critProb);

        // Crit rectangle: critProb * rectangle[minDamage * critFactor, maxDamage * critFactor]
        var critRect = PiecewiseFunction.rectangle(minDamage * critFactor, maxDamage * critFactor);
        critRect = critRect.multiplyByConstant(critProb);

        // Sum the two
        var combinedDensity = noCritRect.add(critRect);

        return new ProbabilityDistribution([], combinedDensity);
    }

    /**
     * Create distribution for fixed damage item
     * @param damage - exact damage value
     */
    public static fromFixedDamage(damage) {
        return new ProbabilityDistribution([{value: damage, probability: 1.0}], PiecewiseFunction.zero());
    }

    /**
     * Create distribution for fixed damage with critical hit
     */
    public static fromFixedDamageWithCrit(damage, critProb, critFactor) {
        var atoms = [
            {value: damage, probability: 1 - critProb},
            {value: damage * critFactor, probability: critProb}
        ];
        return new ProbabilityDistribution(atoms, PiecewiseFunction.zero());
    }

    /**
     * Merge atoms with same value
     */
    private _mergeAtoms() {
        var merged = [];

        for (var i = 0; i < count(this.atoms); i++) {
            var atom = this.atoms[i];
            var found = false;

            for (var j = 0; j < count(merged); j++) {
                if (abs(merged[j]["value"] - atom["value"]) < 0.001) {
                    merged[j]["probability"] += atom["probability"];
                    found = true;
                    break;
                }
            }

            if (!found) {
                push(merged, {value: atom["value"], probability: atom["probability"]});
            }
        }

        this.atoms = merged;
    }

    /**
     * Add another distribution to this one (sum of random variables)
     * This is the key operation for combining item damages
     */
    public convolve(other) {
        var newAtoms = [];
        var newDensity = PiecewiseFunction.zero();

        // Case 1: atom * atom
        // Probability of (this atom + other atom) = product of probabilities
        for (var i = 0; i < count(this.atoms); i++) {
            for (var j = 0; j < count(other.atoms); j++) {
                push(newAtoms, {
                    value: this.atoms[i]["value"] + other.atoms[j]["value"],
                    probability: this.atoms[i]["probability"] * other.atoms[j]["probability"]
                });
            }
        }

        // Case 2: atom * density
        // Shift other's density by this atom value, scale by atom probability
        for (var i = 0; i < count(this.atoms); i++) {
            var shifted = other.density.translate(this.atoms[i]["value"]);
            var scaled = shifted.multiplyByConstant(this.atoms[i]["probability"]);
            newDensity = newDensity.add(scaled);
        }

        // Case 3: density * atom
        // Shift this density by other atom value, scale by atom probability
        for (var i = 0; i < count(other.atoms); i++) {
            var shifted = this.density.translate(other.atoms[i]["value"]);
            var scaled = shifted.multiplyByConstant(other.atoms[i]["probability"]);
            newDensity = newDensity.add(scaled);
        }

        // Case 4: density * density
        // This is the complex convolution operation
        newDensity = newDensity.add(this._convolveDensities(this.density, other.density));

        return new ProbabilityDistribution(newAtoms, newDensity);
    }

    /**
     * Convolve two piecewise functions (the hard part)
     * For LeekWars, we often convolve with rectangles, which simplifies
     */
    private _convolveDensities(f, g) {
        // If one is zero, result is zero
        var fPieces = f.getPieces();
        var gPieces = g.getPieces();

        if (count(fPieces) == 0 || count(gPieces) == 0) {
            return PiecewiseFunction.zero();
        }

        // Check if g is a rectangle (single piece with constant polynomial)
        if (count(gPieces) == 1 && gPieces[0]["poly"].getDegree() == 0) {
            return this._convolveWithRectangle(f, gPieces[0]);
        }

        // Check if f is a rectangle
        if (count(fPieces) == 1 && fPieces[0]["poly"].getDegree() == 0) {
            return this._convolveWithRectangle(g, fPieces[0]);
        }

        // General case: convolve arbitrary piecewise functions
        // This is complex, so we'll implement a general algorithm
        return this._convolveGeneral(f, g);
    }

    /**
     * Convolve piecewise function with a rectangle
     * This is the common case in LeekWars (adding one more item)
     */
    private _convolveWithRectangle(f, rectPiece) {
        var rectMin = rectPiece["min"];
        var rectMax = rectPiece["max"];
        var rectHeight = rectPiece["poly"].getCoeff(0);

        var fPieces = f.getPieces();
        var newPieces = [];

        // For each possible sum value s, the convolution is:
        // (f * rect)(s) = rectHeight * integral of f from (s - rectMax) to (s - rectMin)
        //
        // We need to determine breakpoints where the integral formula changes
        // This happens when s - rectMax or s - rectMin crosses a breakpoint of f

        var breakpoints = []; // All points where formula changes

        // Add shifted breakpoints from f
        for (var i = 0; i < count(fPieces); i++) {
            push(breakpoints, fPieces[i]["min"] + rectMin);
            push(breakpoints, fPieces[i]["max"] + rectMin);
            push(breakpoints, fPieces[i]["min"] + rectMax);
            push(breakpoints, fPieces[i]["max"] + rectMax);
        }

        breakpoints = sort(breakpoints);

        // Calculate primitive of f
        var F = f.primitive();

        // For each interval between breakpoints
        for (var i = 0; i < count(breakpoints) - 1; i++) {
            var s_min = breakpoints[i];
            var s_max = breakpoints[i + 1];

            // Skip zero-width intervals
            if (abs(s_max - s_min) < 0.0001) continue;

            // The convolution on [s_min, s_max] is:
            // rectHeight * (F(s - rectMin) - F(s - rectMax))
            // This is a polynomial in s (difference of two translates of F)

            var midpoint = (s_min + s_max) / 2;

            // Evaluate to check if non-zero
            var integralMin = midpoint - rectMax;
            var integralMax = midpoint - rectMin;

            var value = F.evaluate(integralMax) - F.evaluate(integralMin);

            if (abs(value) < 0.0001) continue; // Skip zero regions

            // Build polynomial for this piece
            // Result is rectHeight * (F(s - rectMin) - F(s - rectMax))

            // Get the polynomial from F at the appropriate interval
            var F_pieces = F.getPieces();
            var relevantPoly = null;

            for (var j = 0; j < count(F_pieces); j++) {
                var Fp = F_pieces[j];
                // Check if interval [integralMin, integralMax] overlaps with this piece
                if (integralMax >= Fp["min"] && integralMin <= Fp["max"]) {
                    relevantPoly = Fp["poly"];
                    break;
                }
            }

            if (relevantPoly != null) {
                // Create: rectHeight * (F(s - rectMin) - F(s - rectMax))
                var poly1 = relevantPoly.translate(-rectMin);
                var poly2 = relevantPoly.translate(-rectMax);
                var diffPoly = poly1.add(poly2.multiplyByConstant(-1));
                var resultPoly = diffPoly.multiplyByConstant(rectHeight);

                push(newPieces, {
                    poly: resultPoly,
                    min: s_min,
                    max: s_max
                });
            }
        }

        return new PiecewiseFunction(newPieces);
    }

    /**
     * General convolution of two arbitrary piecewise functions
     * More complex, used when both have multiple pieces
     */
    private _convolveGeneral(f, g) {
        // For simplicity, we'll use a numerical approach for complex cases
        // In practice, LeekWars combos build up incrementally with rectangles
        // so this path is rarely taken

        // TODO: Implement full symbolic convolution if needed
        // For now, return approximation or simplified version

        return PiecewiseFunction.zero();
    }

    /**
     * Apply absolute armor reduction
     * Armor reduces all damage by a fixed amount, clamping at 0
     * This creates an atom at 0
     */
    public applyAbsoluteArmor(armor) {
        if (armor <= 0) return this;

        var newAtoms = [];
        var probZero = 0;

        // Shift atoms
        for (var i = 0; i < count(this.atoms); i++) {
            var newValue = this.atoms[i]["value"] - armor;
            if (newValue <= 0) {
                probZero += this.atoms[i]["probability"];
            } else {
                push(newAtoms, {value: newValue, probability: this.atoms[i]["probability"]});
            }
        }

        // Shift density and calculate probability of hitting 0
        var shiftedDensity = this.density.translate(-armor);
        var domain = this.density.getDomain();

        // Probability that original damage <= armor (becomes 0)
        var probDensityZero = this.density.integrate(domain["min"], min(domain["max"], armor));
        probZero += probDensityZero;

        // Truncate shifted density at 0 (can't have negative damage)
        var truncatedPieces = [];
        var pieces = shiftedDensity.getPieces();

        for (var i = 0; i < count(pieces); i++) {
            var piece = pieces[i];
            if (piece["max"] > 0) {
                var newMin = max(piece["min"], 0);
                var newMax = piece["max"];

                push(truncatedPieces, {
                    poly: piece["poly"],
                    min: newMin,
                    max: newMax
                });
            }
        }

        var newDensity = new PiecewiseFunction(truncatedPieces);

        // Add atom at 0 if probability > 0
        if (probZero > 0.0001) {
            push(newAtoms, {value: 0, probability: probZero});
        }

        return new ProbabilityDistribution(newAtoms, newDensity);
    }

    /**
     * Apply relative armor (percentage reduction)
     */
    public applyRelativeArmor(reductionPercent) {
        if (reductionPercent <= 0) return this;

        var multiplier = 1 - (reductionPercent / 100);

        // Scale atoms
        var newAtoms = [];
        for (var i = 0; i < count(this.atoms); i++) {
            push(newAtoms, {
                value: this.atoms[i]["value"] * multiplier,
                probability: this.atoms[i]["probability"]
            });
        }

        // Scale density: multiply all damage values by multiplier
        // This means translating to 0, scaling, translating back... but for multiplication,
        // we need to scale the x-axis which changes the integral
        // Scaling x by factor k scales density by 1/k

        var pieces = this.density.getPieces();
        var newPieces = [];

        for (var i = 0; i < count(pieces); i++) {
            var piece = pieces[i];

            // To scale damage by multiplier, we need new piece at [min*mult, max*mult]
            // with polynomial adjusted for x-scaling

            // If f(x) is original density, we want g(y) where y = x * multiplier
            // g(y) = f(y / multiplier) / multiplier

            var scaledPoly = piece["poly"].multiplyByConstant(1 / multiplier);

            // We also need to substitute x -> x/multiplier in the polynomial
            // This is complex for general polynomials, so for now we'll use approximation

            push(newPieces, {
                poly: piece["poly"],
                min: piece["min"] * multiplier,
                max: piece["max"] * multiplier
            });
        }

        var newDensity = new PiecewiseFunction(newPieces);

        return new ProbabilityDistribution(newAtoms, newDensity);
    }

    /**
     * Calculate cumulative distribution function
     * Returns a PiecewiseFunction representing P(X <= x)
     */
    public getCDF() {
        // Start with step function from atoms
        var atomsContribution = this._getAtomsCDF();

        // Add integral of density
        var densityPrimitive = this.density.primitive();

        return atomsContribution.add(densityPrimitive);
    }

    /**
     * Get step function CDF from atoms
     */
    private _getAtomsCDF() {
        if (count(this.atoms) == 0) {
            return PiecewiseFunction.zero();
        }

        // Sort atoms by value
        var sortedAtoms = this.atoms;
        // Simple bubble sort
        for (var i = 0; i < count(sortedAtoms) - 1; i++) {
            for (var j = 0; j < count(sortedAtoms) - i - 1; j++) {
                if (sortedAtoms[j]["value"] > sortedAtoms[j + 1]["value"]) {
                    var temp = sortedAtoms[j];
                    sortedAtoms[j] = sortedAtoms[j + 1];
                    sortedAtoms[j + 1] = temp;
                }
            }
        }

        var pieces = [];
        var cumProb = 0;

        for (var i = 0; i < count(sortedAtoms); i++) {
            var atom = sortedAtoms[i];
            var nextValue = (i < count(sortedAtoms) - 1) ? sortedAtoms[i + 1]["value"] : atom["value"] + 1000;

            // Constant piece at cumProb from this atom to next
            push(pieces, {
                poly: Polynomial.constant(cumProb),
                min: atom["value"],
                max: nextValue
            });

            cumProb += atom["probability"];
        }

        return new PiecewiseFunction(pieces);
    }

    /**
     * Get probability of dealing at least minDamage
     */
    public getProbabilityAtLeast(minDamage) {
        var cdf = this.getCDF();
        var domain = this.density.getDomain();

        // P(X >= minDamage) = 1 - P(X < minDamage) = 1 - CDF(minDamage - 0.5)
        return 1 - cdf.evaluate(minDamage - 0.5);
    }

    /**
     * Get probability of dealing exactly damage (after rounding)
     */
    public getProbabilityExactly(damage) {
        var cdf = this.getCDF();

        // P(damage - 0.5 <= X < damage + 0.5)
        return cdf.evaluate(damage + 0.5) - cdf.evaluate(damage - 0.5);
    }

    /**
     * Get probability of dealing between min and max damage (inclusive, after rounding)
     */
    public getProbabilityBetween(minDamage, maxDamage) {
        var cdf = this.getCDF();
        return cdf.evaluate(maxDamage + 0.5) - cdf.evaluate(minDamage - 0.5);
    }

    /**
     * Get atoms (for debugging)
     */
    public getAtoms() {
        return this.atoms;
    }

    /**
     * Get density (for debugging)
     */
    public getDensity() {
        return this.density;
    }

    /**
     * String representation
     */
    public toString() {
        var result = "ProbabilityDistribution:\n";

        if (count(this.atoms) > 0) {
            result += "Atoms:\n";
            for (var i = 0; i < count(this.atoms); i++) {
                var a = this.atoms[i];
                result += "  P(X = " + round(a["value"] * 100) / 100 + ") = ";
                result += round(a["probability"] * 10000) / 10000 + "\n";
            }
        }

        var pieces = this.density.getPieces();
        if (count(pieces) > 0) {
            result += "Density: " + count(pieces) + " pieces\n";
        }

        return result;
    }
}
