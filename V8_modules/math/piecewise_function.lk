/**
 * PiecewiseFunction.lk - Piecewise polynomial functions for probability densities
 *
 * Represents a function defined by polynomial pieces over intervals
 * Each piece has a polynomial and a domain [min, max]
 */

include('polynomial.lk');

class PiecewiseFunction {
    // Array of pieces: {poly: Polynomial, min: number, max: number}
    pieces = []

    /**
     * Constructor
     * @param pieces - array of {poly: Polynomial, min: number, max: number}
     */
    constructor(pieces) {
        this.pieces = pieces;
        this._sortPieces();
    }

    /**
     * Sort pieces by min value
     */
    _sortPieces() {
        // Simple bubble sort
        for (var i = 0; i < count(this.pieces) - 1; i++) {
            for (var j = 0; j < count(this.pieces) - i - 1; j++) {
                if (this.pieces[j]["min"] > this.pieces[j + 1]["min"]) {
                    var temp = this.pieces[j];
                    this.pieces[j] = this.pieces[j + 1];
                    this.pieces[j + 1] = temp;
                }
            }
        }
    }

    /**
     * Get all breakpoints (where pieces change)
     */
    getBreakpoints() {
        var points = [];
        for (var i = 0; i < count(this.pieces); i++) {
            if (!inArray(points, this.pieces[i]["min"])) {
                push(points, this.pieces[i]["min"]);
            }
            if (!inArray(points, this.pieces[i]["max"])) {
                push(points, this.pieces[i]["max"]);
            }
        }
        return sort(points);
    }

    /**
     * Get domain of the function
     */
    getDomain() {
        if (count(this.pieces) == 0) {
            return {min: 0, max: 0};
        }

        var minVal = this.pieces[0]["min"];
        var maxVal = this.pieces[0]["max"];

        for (var i = 1; i < count(this.pieces); i++) {
            minVal = min(minVal, this.pieces[i]["min"]);
            maxVal = max(maxVal, this.pieces[i]["max"]);
        }

        return {min: minVal, max: maxVal};
    }

    /**
     * Evaluate function at point x
     */
    evaluate(x) {
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            if (x >= piece["min"] && x <= piece["max"]) {
                return piece["poly"].evaluate(x);
            }
        }
        return 0; // Outside all domains
    }

    /**
     * Add two piecewise functions
     * Result has breakpoints at union of both functions' breakpoints
     */
    add(other) {
        // Get all unique breakpoints from both functions
        var allBreaks = [];
        var myBreaks = this.getBreakpoints();
        var otherBreaks = other.getBreakpoints();

        for (var i = 0; i < count(myBreaks); i++) {
            if (!inArray(allBreaks, myBreaks[i])) {
                push(allBreaks, myBreaks[i]);
            }
        }
        for (var i = 0; i < count(otherBreaks); i++) {
            if (!inArray(allBreaks, otherBreaks[i])) {
                push(allBreaks, otherBreaks[i]);
            }
        }

        allBreaks = sort(allBreaks);

        // For each interval between breakpoints, add the polynomials
        var newPieces = [];
        for (var i = 0; i < count(allBreaks) - 1; i++) {
            var intervalMin = allBreaks[i];
            var intervalMax = allBreaks[i + 1];
            var midpoint = (intervalMin + intervalMax) / 2;

            // Get polynomials valid at midpoint
            var poly1 = this._getPolynomialAt(midpoint);
            var poly2 = other._getPolynomialAt(midpoint);

            if (poly1 != null && poly2 != null) {
                var sumPoly = poly1.add(poly2);
                push(newPieces, {
                    poly: sumPoly,
                    min: intervalMin,
                    max: intervalMax
                });
            } else if (poly1 != null) {
                push(newPieces, {
                    poly: poly1,
                    min: intervalMin,
                    max: intervalMax
                });
            } else if (poly2 != null) {
                push(newPieces, {
                    poly: poly2,
                    min: intervalMin,
                    max: intervalMax
                });
            }
        }

        return new PiecewiseFunction(newPieces);
    }

    /**
     * Get polynomial valid at point x (or null if none)
     */
    _getPolynomialAt(x) {
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            if (x >= piece["min"] && x <= piece["max"]) {
                return piece["poly"];
            }
        }
        return null;
    }

    /**
     * Multiply by constant
     */
    multiplyByConstant(k) {
        var newPieces = [];
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            push(newPieces, {
                poly: piece["poly"].multiplyByConstant(k),
                min: piece["min"],
                max: piece["max"]
            });
        }
        return new PiecewiseFunction(newPieces);
    }

    /**
     * Calculate primitive (antiderivative)
     * The primitive is continuous, so we need to adjust constants
     */
    primitive() {
        if (count(this.pieces) == 0) {
            return PiecewiseFunctionZero();
        }

        var newPieces = [];
        var accumulatedValue = 0; // Running total at breakpoints

        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];

            // Get primitive with constant 0
            var primitivePoly = piece["poly"].primitive(0);

            // Calculate value at start of interval
            var valueAtStart = primitivePoly.evaluate(piece["min"]);

            // Adjust constant so primitive is continuous
            var adjustedConstant = accumulatedValue - valueAtStart;
            primitivePoly = piece["poly"].primitive(adjustedConstant);

            push(newPieces, {
                poly: primitivePoly,
                min: piece["min"],
                max: piece["max"]
            });

            // Update accumulated value for next piece
            accumulatedValue = primitivePoly.evaluate(piece["max"]);
        }

        return new PiecewiseFunction(newPieces);
    }

    /**
     * Integrate from a to b
     */
    integrate(a, b) {
        var F = this.primitive();
        return F.evaluate(b) - F.evaluate(a);
    }

    /**
     * Translate function by offset: f(x) -> f(x - offset)
     */
    translate(offset) {
        var newPieces = [];
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            push(newPieces, {
                poly: piece["poly"].translate(offset),
                min: piece["min"] + offset,
                max: piece["max"] + offset
            });
        }
        return new PiecewiseFunction(newPieces);
    }

    /**
     * Get pieces array (for debugging/inspection)
     */
    getPieces() {
        return this.pieces;
    }

    /**
     * String representation for debugging
     */
    toString() {
        if (count(this.pieces) == 0) {
            return "Empty piecewise function";
        }

        var result = "Piecewise function:\n";
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            result += "  [" + piece["min"] + ", " + piece["max"] + "]: ";
            result += piece["poly"].toString() + "\n";
        }
        return result;
    }
}

// Global factory functions (replaces static methods)

/**
 * Create constant piecewise function over a domain
 */
function PiecewiseFunctionConstant(value, minDomain, maxDomain) {
    var poly = PolynomialConstant(value);
    return new PiecewiseFunction([{
        poly: poly,
        min: minDomain,
        max: maxDomain
    }]);
}

/**
 * Create rectangle (crÃ©neau) function - uniform density
 * Height is automatically 1 / (max - min) to make integral = 1
 */
function PiecewiseFunctionRectangle(min, max) {
    var height = 1.0 / (max - min);
    var poly = PolynomialConstant(height);
    return new PiecewiseFunction([{
        poly: poly,
        min: min,
        max: max
    }]);
}

/**
 * Create zero function
 */
function PiecewiseFunctionZero() {
    return new PiecewiseFunction([]);
}
