
include('polynomial.lk');

class PiecewiseFunction {
    
    pieces = []

    constructor(pieces) {
        this.pieces = pieces;
        this._sortPieces();
    }

    _sortPieces() {
        
        for (var i = 0; i < count(this.pieces) - 1; i++) {
            for (var j = 0; j < count(this.pieces) - i - 1; j++) {
                if (this.pieces[j]["min"] > this.pieces[j + 1]["min"]) {
                    var temp = this.pieces[j];
                    this.pieces[j] = this.pieces[j + 1];
                    this.pieces[j + 1] = temp;
                }
            }
        }
    }

    getBreakpoints() {
        var points = [];
        for (var i = 0; i < count(this.pieces); i++) {
            if (!inArray(points, this.pieces[i]["min"])) {
                push(points, this.pieces[i]["min"]);
            }
            if (!inArray(points, this.pieces[i]["max"])) {
                push(points, this.pieces[i]["max"]);
            }
        }
        return sort(points);
    }

    getDomain() {
        if (count(this.pieces) == 0) {
            return {min: 0, max: 0};
        }

        var minVal = this.pieces[0]["min"];
        var maxVal = this.pieces[0]["max"];

        for (var i = 1; i < count(this.pieces); i++) {
            minVal = min(minVal, this.pieces[i]["min"]);
            maxVal = max(maxVal, this.pieces[i]["max"]);
        }

        return {min: minVal, max: maxVal};
    }

    evaluate(x) {
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            if (x >= piece["min"] && x <= piece["max"]) {
                return piece["poly"].evaluate(x);
            }
        }
        return 0; 
    }

    add(other) {
        
        var allBreaks = [];
        var myBreaks = this.getBreakpoints();
        var otherBreaks = other.getBreakpoints();

        for (var i = 0; i < count(myBreaks); i++) {
            if (!inArray(allBreaks, myBreaks[i])) {
                push(allBreaks, myBreaks[i]);
            }
        }
        for (var i = 0; i < count(otherBreaks); i++) {
            if (!inArray(allBreaks, otherBreaks[i])) {
                push(allBreaks, otherBreaks[i]);
            }
        }

        allBreaks = sort(allBreaks);

        var newPieces = [];
        for (var i = 0; i < count(allBreaks) - 1; i++) {
            var intervalMin = allBreaks[i];
            var intervalMax = allBreaks[i + 1];
            var midpoint = (intervalMin + intervalMax) / 2;

            var poly1 = this._getPolynomialAt(midpoint);
            var poly2 = other._getPolynomialAt(midpoint);

            if (poly1 != null && poly2 != null) {
                var sumPoly = poly1.add(poly2);
                push(newPieces, {
                    poly: sumPoly,
                    min: intervalMin,
                    max: intervalMax
                });
            } else if (poly1 != null) {
                push(newPieces, {
                    poly: poly1,
                    min: intervalMin,
                    max: intervalMax
                });
            } else if (poly2 != null) {
                push(newPieces, {
                    poly: poly2,
                    min: intervalMin,
                    max: intervalMax
                });
            }
        }

        return new PiecewiseFunction(newPieces);
    }

    _getPolynomialAt(x) {
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            if (x >= piece["min"] && x <= piece["max"]) {
                return piece["poly"];
            }
        }
        return null;
    }

    multiplyByConstant(k) {
        var newPieces = [];
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            push(newPieces, {
                poly: piece["poly"].multiplyByConstant(k),
                min: piece["min"],
                max: piece["max"]
            });
        }
        return new PiecewiseFunction(newPieces);
    }

    primitive() {
        if (count(this.pieces) == 0) {
            return PiecewiseFunctionZero();
        }

        var newPieces = [];
        var accumulatedValue = 0; 

        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];

            var primitivePoly = piece["poly"].primitive(0);

            var valueAtStart = primitivePoly.evaluate(piece["min"]);

            var adjustedConstant = accumulatedValue - valueAtStart;
            primitivePoly = piece["poly"].primitive(adjustedConstant);

            push(newPieces, {
                poly: primitivePoly,
                min: piece["min"],
                max: piece["max"]
            });

            accumulatedValue = primitivePoly.evaluate(piece["max"]);
        }

        return new PiecewiseFunction(newPieces);
    }

    integrate(a, b) {
        var F = this.primitive();
        return F.evaluate(b) - F.evaluate(a);
    }

    translate(offset) {
        var newPieces = [];
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            push(newPieces, {
                poly: piece["poly"].translate(offset),
                min: piece["min"] + offset,
                max: piece["max"] + offset
            });
        }
        return new PiecewiseFunction(newPieces);
    }

    getPieces() {
        return this.pieces;
    }

    toString() {
        if (count(this.pieces) == 0) {
            return "Empty piecewise function";
        }

        var result = "Piecewise function:\n";
        for (var i = 0; i < count(this.pieces); i++) {
            var piece = this.pieces[i];
            result += "  [" + piece["min"] + ", " + piece["max"] + "]: ";
            result += piece["poly"].toString() + "\n";
        }
        return result;
    }
}

function PiecewiseFunctionConstant(value, minDomain, maxDomain) {
    var poly = PolynomialConstant(value);
    return new PiecewiseFunction([{
        poly: poly,
        min: minDomain,
        max: maxDomain
    }]);
}

function PiecewiseFunctionRectangle(min, max) {
    var height = 1.0 / (max - min);
    var poly = PolynomialConstant(height);
    return new PiecewiseFunction([{
        poly: poly,
        min: min,
        max: max
    }]);
}

function PiecewiseFunctionZero() {
    return new PiecewiseFunction([]);
}
