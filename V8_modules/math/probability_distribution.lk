
include('polynomial.lk');
include('piecewise_function.lk');

class ProbabilityDistribution {
    
    atoms = []

    density = null

    constructor(atoms, density) {
        if (atoms == null) atoms = [];
        if (density == null) density = PiecewiseFunctionZero();

        this.atoms = atoms;
        this.density = density;
        this._mergeAtoms();
    }

    _mergeAtoms() {
        var merged = [];

        for (var i = 0; i < count(this.atoms); i++) {
            var atom = this.atoms[i];
            var found = false;

            for (var j = 0; j < count(merged); j++) {
                if (abs(merged[j]["value"] - atom["value"]) < 0.001) {
                    merged[j]["probability"] += atom["probability"];
                    found = true;
                    break;
                }
            }

            if (!found) {
                push(merged, {value: atom["value"], probability: atom["probability"]});
            }
        }

        this.atoms = merged;
    }

    convolve(other) {
        var newAtoms = [];
        var newDensity = PiecewiseFunctionZero();

        for (var i = 0; i < count(this.atoms); i++) {
            for (var j = 0; j < count(other.atoms); j++) {
                push(newAtoms, {
                    value: this.atoms[i]["value"] + other.atoms[j]["value"],
                    probability: this.atoms[i]["probability"] * other.atoms[j]["probability"]
                });
            }
        }

        for (var i = 0; i < count(this.atoms); i++) {
            var shifted = other.density.translate(this.atoms[i]["value"]);
            var scaled = shifted.multiplyByConstant(this.atoms[i]["probability"]);
            newDensity = newDensity.add(scaled);
        }

        for (var i = 0; i < count(other.atoms); i++) {
            var shifted = this.density.translate(other.atoms[i]["value"]);
            var scaled = shifted.multiplyByConstant(other.atoms[i]["probability"]);
            newDensity = newDensity.add(scaled);
        }

        newDensity = newDensity.add(this._convolveDensities(this.density, other.density));

        return new ProbabilityDistribution(newAtoms, newDensity);
    }

    _convolveDensities(f, g) {
        
        var fPieces = f.getPieces();
        var gPieces = g.getPieces();

        if (count(fPieces) == 0 || count(gPieces) == 0) {
            return PiecewiseFunctionZero();
        }

        if (count(gPieces) == 1 && gPieces[0]["poly"].getDegree() == 0) {
            return this._convolveWithRectangle(f, gPieces[0]);
        }

        if (count(fPieces) == 1 && fPieces[0]["poly"].getDegree() == 0) {
            return this._convolveWithRectangle(g, fPieces[0]);
        }

        return this._convolveGeneral(f, g);
    }

    _convolveWithRectangle(f, rectPiece) {
        var rectMin = rectPiece["min"];
        var rectMax = rectPiece["max"];
        var rectHeight = rectPiece["poly"].getCoeff(0);

        var fPieces = f.getPieces();
        var newPieces = [];

        var breakpoints = []; 

        for (var i = 0; i < count(fPieces); i++) {
            push(breakpoints, fPieces[i]["min"] + rectMin);
            push(breakpoints, fPieces[i]["max"] + rectMin);
            push(breakpoints, fPieces[i]["min"] + rectMax);
            push(breakpoints, fPieces[i]["max"] + rectMax);
        }

        breakpoints = sort(breakpoints);

        var F = f.primitive();

        for (var i = 0; i < count(breakpoints) - 1; i++) {
            var s_min = breakpoints[i];
            var s_max = breakpoints[i + 1];

            if (abs(s_max - s_min) < 0.0001) continue;

            var midpoint = (s_min + s_max) / 2;

            var integralMin = midpoint - rectMax;
            var integralMax = midpoint - rectMin;

            var value = F.evaluate(integralMax) - F.evaluate(integralMin);

            if (abs(value) < 0.0001) continue; 

            var F_pieces = F.getPieces();
            var relevantPoly = null;

            for (var j = 0; j < count(F_pieces); j++) {
                var Fp = F_pieces[j];
                
                if (integralMax >= Fp["min"] && integralMin <= Fp["max"]) {
                    relevantPoly = Fp["poly"];
                    break;
                }
            }

            if (relevantPoly != null) {
                
                var poly1 = relevantPoly.translate(-rectMin);
                var poly2 = relevantPoly.translate(-rectMax);
                var diffPoly = poly1.add(poly2.multiplyByConstant(-1));
                var resultPoly = diffPoly.multiplyByConstant(rectHeight);

                push(newPieces, {
                    poly: resultPoly,
                    min: s_min,
                    max: s_max
                });
            }
        }

        return new PiecewiseFunction(newPieces);
    }

    _convolveGeneral(f, g) {
        
        return PiecewiseFunctionZero();
    }

    applyAbsoluteArmor(armor) {
        if (armor <= 0) return this;

        var newAtoms = [];
        var probZero = 0;

        for (var i = 0; i < count(this.atoms); i++) {
            var newValue = this.atoms[i]["value"] - armor;
            if (newValue <= 0) {
                probZero += this.atoms[i]["probability"];
            } else {
                push(newAtoms, {value: newValue, probability: this.atoms[i]["probability"]});
            }
        }

        var shiftedDensity = this.density.translate(-armor);
        var domain = this.density.getDomain();

        var probDensityZero = this.density.integrate(domain["min"], min(domain["max"], armor));
        probZero += probDensityZero;

        var truncatedPieces = [];
        var pieces = shiftedDensity.getPieces();

        for (var i = 0; i < count(pieces); i++) {
            var piece = pieces[i];
            if (piece["max"] > 0) {
                var newMin = max(piece["min"], 0);
                var newMax = piece["max"];

                push(truncatedPieces, {
                    poly: piece["poly"],
                    min: newMin,
                    max: newMax
                });
            }
        }

        var newDensity = new PiecewiseFunction(truncatedPieces);

        if (probZero > 0.0001) {
            push(newAtoms, {value: 0, probability: probZero});
        }

        return new ProbabilityDistribution(newAtoms, newDensity);
    }

    applyRelativeArmor(reductionPercent) {
        if (reductionPercent <= 0) return this;

        var multiplier = 1 - (reductionPercent / 100);

        var newAtoms = [];
        for (var i = 0; i < count(this.atoms); i++) {
            push(newAtoms, {
                value: this.atoms[i]["value"] * multiplier,
                probability: this.atoms[i]["probability"]
            });
        }

        var pieces = this.density.getPieces();
        var newPieces = [];

        for (var i = 0; i < count(pieces); i++) {
            var piece = pieces[i];

            var scaledPoly = piece["poly"].multiplyByConstant(1 / multiplier);

            push(newPieces, {
                poly: piece["poly"],
                min: piece["min"] * multiplier,
                max: piece["max"] * multiplier
            });
        }

        var newDensity = new PiecewiseFunction(newPieces);

        return new ProbabilityDistribution(newAtoms, newDensity);
    }

    getCDF() {
        
        var atomsContribution = this._getAtomsCDF();

        var densityPrimitive = this.density.primitive();

        return atomsContribution.add(densityPrimitive);
    }

    _getAtomsCDF() {
        if (count(this.atoms) == 0) {
            return PiecewiseFunctionZero();
        }

        var sortedAtoms = this.atoms;
        
        for (var i = 0; i < count(sortedAtoms) - 1; i++) {
            for (var j = 0; j < count(sortedAtoms) - i - 1; j++) {
                if (sortedAtoms[j]["value"] > sortedAtoms[j + 1]["value"]) {
                    var temp = sortedAtoms[j];
                    sortedAtoms[j] = sortedAtoms[j + 1];
                    sortedAtoms[j + 1] = temp;
                }
            }
        }

        var pieces = [];
        var cumProb = 0;

        for (var i = 0; i < count(sortedAtoms); i++) {
            var atom = sortedAtoms[i];
            var nextValue = (i < count(sortedAtoms) - 1) ? sortedAtoms[i + 1]["value"] : atom["value"] + 1000;

            push(pieces, {
                poly: PolynomialConstant(cumProb),
                min: atom["value"],
                max: nextValue
            });

            cumProb += atom["probability"];
        }

        return new PiecewiseFunction(pieces);
    }

    getProbabilityAtLeast(minDamage) {
        var cdf = this.getCDF();
        var domain = this.density.getDomain();

        return 1 - cdf.evaluate(minDamage - 0.5);
    }

    getProbabilityExactly(damage) {
        var cdf = this.getCDF();

        return cdf.evaluate(damage + 0.5) - cdf.evaluate(damage - 0.5);
    }

    getProbabilityBetween(minDamage, maxDamage) {
        var cdf = this.getCDF();
        return cdf.evaluate(maxDamage + 0.5) - cdf.evaluate(minDamage - 0.5);
    }

    getAtoms() {
        return this.atoms;
    }

    getDensity() {
        return this.density;
    }

    toString() {
        var result = "ProbabilityDistribution:\n";

        if (count(this.atoms) > 0) {
            result += "Atoms:\n";
            for (var i = 0; i < count(this.atoms); i++) {
                var a = this.atoms[i];
                result += "  P(X = " + round(a["value"] * 100) / 100 + ") = ";
                result += round(a["probability"] * 10000) / 10000 + "\n";
            }
        }

        var pieces = this.density.getPieces();
        if (count(pieces) > 0) {
            result += "Density: " + count(pieces) + " pieces\n";
        }

        return result;
    }
}

function ProbabilityDistributionFromRectangle(min, max) {
    var rect = PiecewiseFunctionRectangle(min, max);
    return new ProbabilityDistribution([], rect);
}

function ProbabilityDistributionFromRectangleWithCrit(minDamage, maxDamage, critProb, critFactor) {
    
    var noCritRect = PiecewiseFunctionRectangle(minDamage, maxDamage);
    noCritRect = noCritRect.multiplyByConstant(1 - critProb);

    var critRect = PiecewiseFunctionRectangle(minDamage * critFactor, maxDamage * critFactor);
    critRect = critRect.multiplyByConstant(critProb);

    var combinedDensity = noCritRect.add(critRect);

    return new ProbabilityDistribution([], combinedDensity);
}

function ProbabilityDistributionFromFixedDamage(damage) {
    return new ProbabilityDistribution([{value: damage, probability: 1.0}], PiecewiseFunctionZero());
}

function ProbabilityDistributionFromFixedDamageWithCrit(damage, critProb, critFactor) {
    var atoms = [
        {value: damage, probability: 1 - critProb},
        {value: damage * critFactor, probability: critProb}
    ];
    return new ProbabilityDistribution(atoms, PiecewiseFunctionZero());
}
