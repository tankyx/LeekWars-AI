include('field_map_patterns.lk')

// ====================================================================
// FIELD MAP - TACTICAL (Hide & Seek, OTKO, Caching)
// ====================================================================

class FieldMap extends FieldMapPatterns {
    // Per-turn cache for enemy accessible cells
    _enemyAccessCache = []
    _enemyAccessCacheTurn = -1
    _enemyAccessCacheIds = []

    private static board_cell_count = 613

    constructor() {
        super()
    }

    // ====================================================================
    // ACCESSIBLE CELLS (for HNS calculations)
    // ====================================================================

    // Compute all cells reachable this turn for given entity
    getAccessibleCells(entity) {
        var acc = []
        if (entity == null) return acc
        var mp = entity._currMp
        var origin = entity._cellPos
        for (var cid = 0; cid < FieldMap.board_cell_count; cid++) {
            if (isObstacle(cid)) continue
            var approx = getCellDistance(origin, cid)
            if (approx == null || approx > mp) continue
            var len = getPathLength(origin, cid)
            if (len == null) continue
            if (len <= mp) push(acc, cid)
        }
        return acc
    }

    // Build or reuse cached enemy accessible cells
    getEnemyAccess() {
        var curTurn = getTurn()
        var enemiesMap = this.getEnemySubMap()
        var enemyIdsNow = mapKeys(enemiesMap)

        // Rebuild conditions: turn changed OR enemy count changed OR ID mismatch
        var needRebuild = (curTurn != this._enemyAccessCacheTurn)
        if (!needRebuild && count(enemyIdsNow) != count(this._enemyAccessCacheIds)) needRebuild = true
        if (!needRebuild) {
            for (var i = 0; i < count(enemyIdsNow); i++) {
                var found = false
                for (var j = 0; j < count(this._enemyAccessCacheIds); j++) {
                    if (enemyIdsNow[i] == this._enemyAccessCacheIds[j]) { found = true; break }
                }
                if (!found) { needRebuild = true; break }
            }
        }

        if (needRebuild) {
            this._enemyAccessCache = []
            this._enemyAccessCacheIds = []
            for (var ei = 0; ei < count(enemyIdsNow); ei++) {
                var eid = enemyIdsNow[ei]
                var enemyObj = enemiesMap[eid]
                if (enemyObj == null) continue
                var eAcc = this.getAccessibleCells(enemyObj)
                if (indexOf(eAcc, enemyObj._cellPos) == -1) push(eAcc, enemyObj._cellPos)
                push(this._enemyAccessCache, ['enemy': enemyObj, 'cells': eAcc])
                push(this._enemyAccessCacheIds, eid)
            }
            this._enemyAccessCacheTurn = curTurn
            debug("[HNS][CACHE] Rebuilt enemy access cache size=" + count(this._enemyAccessCache))
        }
        return this._enemyAccessCache
    }

    // ====================================================================
    // HIDE & SEEK CELL SELECTION
    // ====================================================================

    // Evaluate best hiding cell: minimize danger (LOS exposures) and maximize distance
    findHideAndSeekCell() {
        var enemyAccess = this.getEnemyAccess()
        if (count(enemyAccess) == 0) return null
        var playerAccessible = this.getAccessibleCells(player)
        if (indexOf(playerAccessible, player._cellPos) == -1) push(playerAccessible, player._cellPos)

        var bestCell = -1
        var bestDanger = 99999
        var bestDist = -1
        var playerPos = player._cellPos

        for (var i = 0; i < count(playerAccessible); i++) {
            var cand = playerAccessible[i]
            var danger = 0
            var earlyStop = false
            var closestEnemyDist = 999

            for (var ea = 0; ea < count(enemyAccess); ea++) {
                var enemyRef = enemyAccess[ea]['enemy']
                if (enemyRef == null) continue
                var eOrigDist = getCellDistance(cand, enemyRef._cellPos)
                if (eOrigDist != null && eOrigDist < closestEnemyDist) closestEnemyDist = eOrigDist

                var cellsArr = enemyAccess[ea]['cells']
                for (var ec = 0; ec < count(cellsArr); ec++) {
                    var eCell = cellsArr[ec]
                    if (lineOfSight(eCell, cand)) {
                        danger += 1
                        if (danger > bestDanger && bestDanger == 0) { earlyStop = true; break }
                    }
                }
                if (earlyStop) break
            }
            if (closestEnemyDist == 999) closestEnemyDist = 0

            // Prefer lower danger, then greater distance
            if (danger < bestDanger || (danger == bestDanger && closestEnemyDist > bestDist)) {
                bestDanger = danger
                bestCell = cand
                bestDist = closestEnemyDist
            }
        }

        if (bestCell == -1) return null
        debug("[HNS] bestCell=" + bestCell + " danger=" + bestDanger + " dist=" + bestDist + " playerPos=" + playerPos)
        if (bestCell != playerPos) mark(bestCell, getColor(120, 200, 255), 3)
        return ['cell': bestCell, 'danger': bestDanger, 'safe': (bestDanger == 0)]
    }

    // Compute danger (LOS exposures) for single cell
    private computeDangerForCell(cellId, enemyAccess) {
        var danger = 0
        for (var ea = 0; ea < count(enemyAccess); ea++) {
            var cellsArr = enemyAccess[ea]['cells']
            for (var ec = 0; ec < count(cellsArr); ec++) {
                if (lineOfSight(cellsArr[ec], cellId)) { danger += 1 }
            }
        }
        return danger
    }

    // Approach-oriented HNS: get closer while minimizing danger
    findApproachHideAndSeekCell(target) {
        if (target == null) return null
        var enemyAccess = this.getEnemyAccess()
        if (count(enemyAccess) == 0) return null
        var playerAccessible = this.getAccessibleCells(player)
        if (indexOf(playerAccessible, player._cellPos) == -1) push(playerAccessible, player._cellPos)

        var bestCell = -1
        var bestDanger = 99999
        var bestDist = 99999
        var bestCanAttack = false
        var targetPos = target._cellPos
        var currentDist = getCellDistance(player._cellPos, targetPos)

        for (var i = 0; i < count(playerAccessible); i++) {
            var cand = playerAccessible[i]
            var distTarget = getCellDistance(cand, targetPos)
            if (distTarget == null) continue

            var canAttack = false
            if (mapContainsKey(this.damageMap, cand)) {
                var cellRef = this.damageMap[cand]
                if (cellRef._highestDamageWeapon != -1) canAttack = true
                else if (cellRef._highestDamageChip != -1) canAttack = true
            }

            // Skip cells that increase distance unless they allow attack
            if (!canAttack && distTarget > currentDist) continue

            var danger = this.computeDangerForCell(cand, enemyAccess)

            // Ordering: canAttack > lower danger > lower distance
            if (bestCell == -1) {
                bestCell = cand; bestDanger = danger; bestDist = distTarget; bestCanAttack = canAttack; continue
            }
            if (canAttack && !bestCanAttack) {
                bestCell = cand; bestDanger = danger; bestDist = distTarget; bestCanAttack = true; continue
            }
            if (canAttack == bestCanAttack) {
                if (danger < bestDanger || (danger == bestDanger && distTarget < bestDist) || (danger == bestDanger && distTarget == bestDist && distTarget < currentDist && bestDist >= currentDist)) {
                    bestCell = cand; bestDanger = danger; bestDist = distTarget; bestCanAttack = canAttack
                }
            }
        }

        if (bestCell == -1) return null
        if (bestCell != player._cellPos) mark(bestCell, getColor(255, 200, 120), 3)
        debug("[HNS-APPROACH] bestCell=" + bestCell + " canAttack=" + bestCanAttack + " danger=" + bestDanger + " dist=" + bestDist + " currentDist=" + currentDist)
        return ['cell': bestCell, 'danger': bestDanger, 'canAttack': bestCanAttack, 'dist': bestDist]
    }

    // ====================================================================
    // OTKO TELEPORTATION SUPPORT
    // ====================================================================

    // Find optimal teleport cell for OTKO
    findOptimalTeleportCell(target) {
        if (target == null) return null

        var playerPos = player._cellPos
        var bestCell = -1
        var bestDamage = -1
        var targetHP = target._currHealth

        for (var cellId = 0; cellId < FieldMap.board_cell_count; cellId++) {
            if (isObstacle(cellId)) continue
            if (isEntity(cellId)) continue

            var distFromPlayer = getCellDistance(playerPos, cellId)
            if (distFromPlayer == null || distFromPlayer < 1 || distFromPlayer > 12) continue

            var totalDamage = 0
            var playerTP = player._currTp - 9  // Reserve 9 TP for teleport

            // Check all equipped weapons
            for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
                var wObj = arsenal.playerEquippedWeapons[wid]
                if (wObj == null) continue

                var distToTarget = getCellDistance(cellId, target._cellPos)
                if (distToTarget == null) continue
                if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
                if (!lineOfSight(cellId, target._cellPos)) continue

                var weaponDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)
                var tpBudget = playerTP
                if (getWeapon() != wid) tpBudget -= 1
                var uses = min(wObj._maxUse, floor(tpBudget / wObj._cost))
                totalDamage += weaponDmg * uses
            }

            // Check damage chips if TP remains
            if (playerTP > 0) {
                for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                    var chipObj = arsenal.playerEquippedChips[cid]
                    if (chipObj == null) continue
                    if (cid == CHIP_TELEPORTATION) continue

                    if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                    var distChip = getCellDistance(cellId, target._cellPos)
                    if (distChip == null) continue
                    if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                    if (!lineOfSight(cellId, target._cellPos)) continue

                    var chipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                    var tpRemain = playerTP - totalDamage
                    if (tpRemain < chipObj._cost) continue
                    var usesChip = min(chipObj._maxUse, floor(tpRemain / chipObj._cost))
                    totalDamage += chipDmg * usesChip
                }
            }

            if (totalDamage > bestDamage) {
                bestDamage = totalDamage
                bestCell = cellId
            }
        }

        if (bestCell == -1) return null

        var canKill = (bestDamage >= targetHP)
        debug("[OTKO-TELEPORT] bestCell=" + bestCell + " projectedDamage=" + bestDamage + " targetHP=" + targetHP + " canKill=" + canKill)

        return ['cell': bestCell, 'damage': bestDamage, 'canKill': canKill]
    }
}
