include('field_map_patterns.lk')

// ====================================================================
// FIELD MAP - TACTICAL (Hide & Seek, OTKO, Caching)
// ====================================================================

class FieldMap extends FieldMapPatterns {
    // Per-turn cache for enemy accessible cells
    _enemyAccessCache = []
    _enemyAccessCacheTurn = -1
    _enemyAccessCacheIds = []

    // WEEK 2: Enemy threat map
    enemyThreatMap = [:]
    _threatMapCacheTurn = -1
    _threatMapCacheEnemyPositions = [:]

    private static board_cell_count = 613

    constructor() {
        super()
    }

    // ====================================================================
    // ACCESSIBLE CELLS (for HNS calculations)
    // ====================================================================

    // Compute all cells reachable this turn for given entity
    getAccessibleCells(entity) {
        var acc = []
        if (entity == null) return acc
        var mp = entity._currMp
        var origin = entity._cellPos
        for (var cid = 0; cid < FieldMap.board_cell_count; cid++) {
            if (isObstacle(cid)) continue
            var approx = getCellDistance(origin, cid)
            if (approx == null || approx > mp) continue
            var len = getCachedPathLength(origin, cid)
            if (len == null) continue
            if (len <= mp) push(acc, cid)
        }
        return acc
    }

    // Build or reuse cached enemy accessible cells
    getEnemyAccess() {
        var curTurn = getTurn()
        var enemiesMap = this.getEnemySubMap()
        var enemyIdsNow = mapKeys(enemiesMap)

        // Rebuild conditions: turn changed OR enemy count changed OR ID mismatch
        var needRebuild = (curTurn != this._enemyAccessCacheTurn)
        if (!needRebuild && count(enemyIdsNow) != count(this._enemyAccessCacheIds)) needRebuild = true
        if (!needRebuild) {
            for (var i = 0; i < count(enemyIdsNow); i++) {
                var found = false
                for (var j = 0; j < count(this._enemyAccessCacheIds); j++) {
                    if (enemyIdsNow[i] == this._enemyAccessCacheIds[j]) { found = true; break }
                }
                if (!found) { needRebuild = true; break }
            }
        }

        if (needRebuild) {
            this._enemyAccessCache = []
            this._enemyAccessCacheIds = []
            for (var ei = 0; ei < count(enemyIdsNow); ei++) {
                var eid = enemyIdsNow[ei]
                var enemyObj = enemiesMap[eid]
                if (enemyObj == null) continue
                var eAcc = this.getAccessibleCells(enemyObj)
                if (indexOf(eAcc, enemyObj._cellPos) == -1) push(eAcc, enemyObj._cellPos)
                push(this._enemyAccessCache, ['enemy': enemyObj, 'cells': eAcc])
                push(this._enemyAccessCacheIds, eid)
            }
            this._enemyAccessCacheTurn = curTurn
            debug("[HNS][CACHE] Rebuilt enemy access cache size=" + count(this._enemyAccessCache))
        }
        return this._enemyAccessCache
    }

    // ====================================================================
    // HIDE & SEEK CELL SELECTION
    // ====================================================================

    // Unified Hide & Seek cell evaluation
    // mode: "defensive" (maximize distance) or "approach" (prefer attack cells)
    // target: required for "approach" mode
    findHideAndSeekCell(mode = "defensive", target = null) {
        var enemyAccess = this.getEnemyAccess()
        if (count(enemyAccess) == 0) return null
        var playerAccessible = this.getAccessibleCells(player)
        if (indexOf(playerAccessible, player._cellPos) == -1) push(playerAccessible, player._cellPos)

        var isApproachMode = (mode == "approach")
        var targetPos = isApproachMode ? target._cellPos : -1
        var currentDist = isApproachMode ? getCellDistance(player._cellPos, targetPos) : -1

        var bestCell = -1
        var bestDanger = 99999
        var bestDist = isApproachMode ? 99999 : -1  // Approach: minimize, Defensive: maximize
        var bestCanAttack = false
        var bestCover = -1  // Cover score (0-8, higher is better)
        var playerPos = player._cellPos

        for (var i = 0; i < count(playerAccessible); i++) {
            var cand = playerAccessible[i]

            // Calculate distance metric
            var distMetric = 0
            if (isApproachMode) {
                distMetric = getCellDistance(cand, targetPos)
                if (distMetric == null) continue
            } else {
                // Defensive: distance to closest enemy
                var closestEnemyDist = 999
                for (var ea = 0; ea < count(enemyAccess); ea++) {
                    var enemyRef = enemyAccess[ea]['enemy']
                    if (enemyRef == null) continue
                    var eOrigDist = getCellDistance(cand, enemyRef._cellPos)
                    if (eOrigDist != null && eOrigDist < closestEnemyDist) closestEnemyDist = eOrigDist
                }
                distMetric = (closestEnemyDist == 999) ? 0 : closestEnemyDist
            }

            // Check if cell allows attack (approach mode only)
            var canAttack = false
            if (isApproachMode) {
                // Skip cells that increase distance unless they allow attack
                if (distMetric > currentDist) {
                    if (mapContainsKey(this.damageMap, cand)) {
                        var cellRef = this.damageMap[cand]
                        if (cellRef._highestDamageWeapon != -1 || cellRef._highestDamageChip != -1) {
                            canAttack = true
                        }
                    }
                    if (!canAttack) continue
                } else if (mapContainsKey(this.damageMap, cand)) {
                    var cellRef = this.damageMap[cand]
                    if (cellRef._highestDamageWeapon != -1 || cellRef._highestDamageChip != -1) {
                        canAttack = true
                    }
                }
            }

            // Calculate danger (LOS exposures) and cover score
            var danger = this.computeDangerForCell(cand, enemyAccess)
            var coverScore = this.evaluateCoverScore(cand)

            // Scoring based on mode
            var shouldUpdate = false
            if (bestCell == -1) {
                shouldUpdate = true
            } else if (isApproachMode) {
                // Approach mode: canAttack > lower danger > lower distance > higher cover
                if (canAttack && !bestCanAttack) {
                    shouldUpdate = true
                } else if (canAttack == bestCanAttack) {
                    if (danger < bestDanger ||
                        (danger == bestDanger && distMetric < bestDist) ||
                        (danger == bestDanger && distMetric == bestDist && coverScore > bestCover) ||
                        (danger == bestDanger && distMetric == bestDist && coverScore == bestCover && distMetric < currentDist && bestDist >= currentDist)) {
                        shouldUpdate = true
                    }
                }
            } else {
                // Defensive mode: lower danger > greater distance > higher cover
                if (danger < bestDanger ||
                    (danger == bestDanger && distMetric > bestDist) ||
                    (danger == bestDanger && distMetric == bestDist && coverScore > bestCover)) {
                    shouldUpdate = true
                }
            }

            if (shouldUpdate) {
                bestCell = cand
                bestDanger = danger
                bestDist = distMetric
                bestCanAttack = canAttack
                bestCover = coverScore
            }
        }

        if (bestCell == -1) return null

        if (isApproachMode) {
            if (bestCell != playerPos) mark(bestCell, getColor(255, 200, 120), 3)
            debug("[HNS-" + mode + "] bestCell=" + bestCell + " canAttack=" + bestCanAttack + " danger=" + bestDanger + " dist=" + bestDist + " cover=" + bestCover + " currentDist=" + currentDist)
            return ['cell': bestCell, 'danger': bestDanger, 'canAttack': bestCanAttack, 'dist': bestDist, 'cover': bestCover, 'safe': (bestDanger == 0)]
        } else {
            if (bestCell != playerPos) mark(bestCell, getColor(120, 200, 255), 3)
            debug("[HNS-" + mode + "] bestCell=" + bestCell + " danger=" + bestDanger + " dist=" + bestDist + " cover=" + bestCover + " playerPos=" + playerPos)
            return ['cell': bestCell, 'danger': bestDanger, 'safe': (bestDanger == 0), 'dist': bestDist, 'cover': bestCover]
        }
    }

    // Compute danger (LOS exposures) for single cell
    private computeDangerForCell(cellId, enemyAccess) {
        var danger = 0
        for (var ea = 0; ea < count(enemyAccess); ea++) {
            var cellsArr = enemyAccess[ea]['cells']
            for (var ec = 0; ec < count(cellsArr); ec++) {
                if (lineOfSight(cellsArr[ec], cellId)) { danger += 1 }
            }
        }
        return danger
    }

    // Evaluate cover quality (adjacent obstacles provide tactical advantage)
    // Returns: 0-8 score (higher = more adjacent obstacles)
    private evaluateCoverScore(cellId) {
        var adjacentObstacles = 0
        var cellX = getCellX(cellId)
        var cellY = getCellY(cellId)

        // Check all 8 adjacent cells (using cell coordinate system)
        var offsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
        for (var o = 0; o < count(offsets); o++) {
            var neighborCell = getCellFromXY(cellX + offsets[o][0], cellY + offsets[o][1])
            if (neighborCell != null && isObstacle(neighborCell)) {
                adjacentObstacles += 1
            }
        }
        return adjacentObstacles
    }


    // ====================================================================
    // OTKO TELEPORTATION SUPPORT
    // ====================================================================

    // Find optimal teleport cell for OTKO
    findOptimalTeleportCell(target) {
        if (target == null) return null

        var playerPos = player._cellPos
        var bestCell = -1
        var bestDamage = -1
        var targetHP = target._currHealth

        for (var cellId = 0; cellId < FieldMap.board_cell_count; cellId++) {
            if (isObstacle(cellId)) continue
            if (isEntity(cellId)) continue

            var distFromPlayer = getCellDistance(playerPos, cellId)
            if (distFromPlayer == null || distFromPlayer < 1 || distFromPlayer > 12) continue

            var totalDamage = 0
            var playerTP = player._currTp - 9  // Reserve 9 TP for teleport
            var tpSpent = 0  // Track TP consumed (weapons + chips)

            // Check all equipped weapons
            for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
                var wObj = arsenal.playerEquippedWeapons[wid]
                if (wObj == null) continue

                var distToTarget = getCellDistance(cellId, target._cellPos)
                if (distToTarget == null) continue
                if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
                if (!lineOfSight(cellId, target._cellPos)) continue

                var weaponDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)
                var tpBudget = playerTP - tpSpent
                var swapCost = (getWeapon() != wid) ? 1 : 0
                if (tpBudget <= swapCost) continue
                var uses = min(wObj._maxUse, floor((tpBudget - swapCost) / wObj._cost))
                if (uses <= 0) continue
                totalDamage += weaponDmg * uses
                tpSpent += swapCost + uses * wObj._cost
            }

            // Check damage chips if TP remains
            var tpRemaining = playerTP - tpSpent
            if (tpRemaining > 0) {
                for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                    var chipObj = arsenal.playerEquippedChips[cid]
                    if (chipObj == null) continue
                    if (cid == CHIP_TELEPORTATION) continue

                    if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                    var distChip = getCellDistance(cellId, target._cellPos)
                    if (distChip == null) continue
                    if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                    if (!lineOfSight(cellId, target._cellPos)) continue

                    var chipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                    var tpBudgetChip = playerTP - tpSpent
                    if (tpBudgetChip < chipObj._cost) continue
                    var usesChip = min(chipObj._maxUse, floor(tpBudgetChip / chipObj._cost))
                    if (usesChip <= 0) continue
                    totalDamage += chipDmg * usesChip
                    tpSpent += usesChip * chipObj._cost
                }
            }

            if (totalDamage > bestDamage) {
                bestDamage = totalDamage
                bestCell = cellId
            }
        }

        if (bestCell == -1) return null

        // Calculate kill probability using simple estimate
        // Build item list for best cell
        var bestCellItems = []
        var tpForItems = player._currTp - 9  // Reserve teleport cost

        // Add weapons that can be used from best cell
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            var distToTarget = getCellDistance(bestCell, target._cellPos)
            if (distToTarget == null) continue
            if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
            if (!lineOfSight(bestCell, target._cellPos)) continue

            var swapCost = (getWeapon() != wid) ? 1 : 0
            var uses = min(wObj._maxUse, floor((tpForItems - swapCost) / wObj._cost))

            for (var u = 0; u < uses; u++) {
                push(bestCellItems, wid)
            }
        }

        // Add chips
        for (var cid in mapKeys(arsenal.playerEquippedChips)) {
            var chipObj = arsenal.playerEquippedChips[cid]
            if (chipObj == null) continue
            if (cid == CHIP_TELEPORTATION) continue
            if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

            var distChip = getCellDistance(bestCell, target._cellPos)
            if (distChip == null) continue
            if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
            if (!lineOfSight(bestCell, target._cellPos)) continue

            var usesChip = min(chipObj._maxUse, floor(tpForItems / chipObj._cost))
            for (var uc = 0; uc < usesChip; uc++) {
                push(bestCellItems, cid)
            }
        }

        // Calculate kill probability
        var killProb = arsenal.getKillProbability(
            bestCellItems,
            player._strength,
            player._magic,
            player._wisdom,
            player._agility,
            target
        )

        debug("[OTKO-TELEPORT] bestCell=" + bestCell + " projectedDamage=" + floor(bestDamage) + " targetHP=" + targetHP + " killProbability=" + round(killProb * 100) + "%")

        return ['cell': bestCell, 'damage': bestDamage, 'killProbability': killProb]
    }

    // ====================================================================
    // BURST DAMAGE CALCULATION (for OTKO cell marking)
    // ====================================================================

    // Calculate maximum burst damage from specific cell position
    // OPTIMIZED: Reuses field map data instead of recalculating
    // Returns: {damage, tpRequired, killProbability}
    // Used during buildHitMap() to mark OTKO cells
    calculateBurstDamageFromCell(cellId, target, availableTP) {
        if (target == null) return null
        if (cellId < 0 || cellId >= FieldMap.board_cell_count) return null

        // OPTIMIZATION: Reuse field map's pre-calculated damage data
        // Field map already computed: range checks, LOS checks, damage calculations
        // This cell data is fresh (rebuilt every turn when enemy moves)

        var cell = null
        // Find cell in damage map
        for (var dmCell in this.damageMap) {
            if (dmCell._id == cellId) {
                cell = dmCell
                break
            }
        }

        if (cell == null) return null  // Cell not in damage map (no attacks possible)

        // Use pre-calculated damage from field map
        // This is the damage per-use, already accounting for shields/resistances
        var baseDamage = cell._weaponDamage + cell._chipDamage

        if (baseDamage <= 0) return null  // No damage possible from this cell

        // Estimate maximum damage with available TP
        // Heuristic: Average weapon use costs ~6 TP, can use ~3 times with 25 TP
        // This is a conservative estimate (actual may be higher with multi-weapon combos)
        var avgTPPerUse = 6.0
        var estimatedUses = floor(availableTP / avgTPPerUse)
        if (estimatedUses < 1) estimatedUses = 1
        if (estimatedUses > 4) estimatedUses = 4  // Cap at 4 uses (realistic max)

        var estimatedMaxDamage = baseDamage * estimatedUses

        // Calculate kill probability
        var targetHP = target._currHealth
        var killProbability = (targetHP > 0) ? (estimatedMaxDamage / targetHP) : 0.0

        return [
            'damage': estimatedMaxDamage,
            'tpRequired': availableTP,
            'killProbability': killProbability
        ]
    }

    // Get the best OTKO cell (highest kill probability)
    // Returns Cell object or null if no OTKO cells available
    getBestOTKOCell() {
        var bestCell = null
        var bestKillProb = 0

        for (var cell in this.damageMap) {
            if (cell._isOTKOCell && cell._otkoKillProbability > bestKillProb) {
                bestKillProb = cell._otkoKillProbability
                bestCell = cell
            }
        }

        return bestCell  // Returns cell with highest kill probability
    }

    // Get all OTKO cells (for movement prioritization)
    // Returns array of Cell objects
    getAllOTKOCells() {
        var otkoCells = []

        for (var cell in this.damageMap) {
            if (cell._isOTKOCell) {
                push(otkoCells, cell)
            }
        }

        return otkoCells
    }

    // ====================================================================
    // ENEMY THREAT MAP SYSTEM (Week 2)
    // ====================================================================

    // Build threat map considering enemy movement + attack ranges
    // Shows maximum damage player could take at each cell this turn
    buildEnemyThreatMap() {
        var currentTurn = getTurn()

        // Check cache validity (invalidate if turn changed or enemies moved)
        var cacheValid = (this._threatMapCacheTurn == currentTurn)
        if (cacheValid) {
            var enemies = this.getEnemySubMap()
            for (var eid in mapKeys(enemies)) {
                var enemy = enemies[eid]
                if (mapContainsKey(this._threatMapCacheEnemyPositions, eid)) {
                    if (this._threatMapCacheEnemyPositions[eid] != enemy._cellPos) {
                        cacheValid = false
                        debug("[THREAT-MAP] Cache invalid: enemy " + getName(eid) + " moved")
                        break
                    }
                } else {
                    cacheValid = false
                    break
                }
            }
        }

        if (cacheValid) {
            debug("[THREAT-MAP] Using cached threat map (turn " + currentTurn + ")")
            return
        }

        // Rebuild threat map
        debug("[THREAT-MAP] Building new threat map for turn " + currentTurn)
        mapClear(this.enemyThreatMap)
        mapClear(this._threatMapCacheEnemyPositions)

        var enemies = this.getEnemySubMap()
        var enemyCount = count(mapKeys(enemies))

        if (enemyCount == 0) {
            debug("[THREAT-MAP] No enemies detected")
            return
        }

        // PERFORMANCE: Skip threat map if total enemy MP is very high (too expensive)
        var totalEnemyMP = 0
        for (var eid in mapKeys(enemies)) {
            var enemy = enemies[eid]
            if (!isDead(eid)) totalEnemyMP += enemy._currMp
        }
        if (totalEnemyMP > 20) {
            debug("[THREAT-MAP] SKIPPED - Total enemy MP too high (" + totalEnemyMP + ") - operations limit risk")
            this._threatMapCacheTurn = currentTurn
            return
        }

        for (var eid in mapKeys(enemies)) {
            var enemy = enemies[eid]
            if (isDead(eid)) continue

            // Cache enemy position for validation
            this._threatMapCacheEnemyPositions[eid] = enemy._cellPos

            this.addEnemyThreatToMap(enemy)
        }

        this._threatMapCacheTurn = currentTurn

        var threatenedCells = count(mapKeys(this.enemyThreatMap))
        debug("[THREAT-MAP] Complete. " + threatenedCells + " cells threatened by " + enemyCount + " enemies")
    }

    // Add single enemy's threat to map (movement + attack ranges)
    // OPTIMIZED: Use simplified calculation to avoid operations limit
    addEnemyThreatToMap(enemy) {
        var enemyPos = enemy._cellPos
        var enemyMP = enemy._currMp
        var enemyWeapons = getWeapons(enemy._id)

        debug("[THREAT-MAP] Processing enemy " + getName(enemy._id) + " at cell " + enemyPos + " (MP=" + enemyMP + ", weapons=" + count(enemyWeapons) + ")")

        var totalThreats = 0

        // OPTIMIZED: Calculate threat from CURRENT position with extended weapon ranges
        // Instead of calculating from ALL movement positions (too expensive)
        // We extend weapon max range by enemy MP (approximates "move then shoot")
        for (var j = 0; j < count(enemyWeapons); j++) {
            var weaponId = enemyWeapons[j]
            var minRange = getWeaponMinRange(weaponId)
            var maxRange = getWeaponMaxRange(weaponId) + enemyMP  // Extend by movement range
            var area = getWeaponArea(weaponId)

            // Estimate damage for this weapon
            var damage = this.estimateEnemyWeaponDamage(weaponId, enemy)

            // Cap search radius to avoid excessive operations
            var searchRadius = min(maxRange, 10)

            // Check cells in extended weapon range
            for (var dx = -searchRadius; dx <= searchRadius; dx++) {
                for (var dy = -searchRadius; dy <= searchRadius; dy++) {
                    var cellId = enemyPos + FieldMapCore.x_offset * dx + FieldMapCore.y_offset * dy
                    if (cellId < 0 || cellId >= FieldMap.board_cell_count) continue

                    var dist = getCellDistance(enemyPos, cellId)
                    if (dist == null || dist > maxRange) continue

                    // Skip cells too close (enemy would need to back up first)
                    if (dist < minRange && dist < enemyMP) continue

                    // For laser weapons, approximate LOS (skip detailed check to save ops)
                    // For circle weapons, assume can hit if in range

                    if (!mapContainsKey(this.enemyThreatMap, cellId)) {
                        this.enemyThreatMap[cellId] = 0
                    }

                    // Use MAX threat (enemy will position for best shot)
                    if (damage > this.enemyThreatMap[cellId]) {
                        this.enemyThreatMap[cellId] = damage
                        totalThreats++
                    }
                }
            }
        }

        debug("[THREAT-MAP]   Added " + totalThreats + " threat markers for " + getName(enemy._id))
    }

    // Get all cells reachable within MP budget
    getReachableCellsWithinMP(startCell, maxMP) {
        var reachable = []

        // Use radius search for candidates (faster than exhaustive)
        var radius = min(maxMP, 8)  // Cap at 8 to avoid huge searches

        // Manual radius iteration (getCellsInRadius doesn't exist in LS4)
        for (var dx = -radius; dx <= radius; dx++) {
            for (var dy = -radius; dy <= radius; dy++) {
                var dist = abs(dx) + abs(dy)
                if (dist > radius) continue

                var cellId = startCell + FieldMapCore.x_offset * dx + FieldMapCore.y_offset * dy
                if (cellId < 0 || cellId >= FieldMap.board_cell_count) continue
                if (isObstacle(cellId)) continue

                var pathLen = getCachedPathLength(startCell, cellId)
                if (pathLen != null && pathLen <= maxMP) {
                    push(reachable, cellId)
                }
            }
        }

        return reachable
    }

    // Get all cells attackable from a position with a specific weapon
    getCellsInWeaponRange(fromCell, weaponId, enemy) {
        var cells = []

        // Get weapon info
        var minRange = getWeaponMinRange(weaponId)
        var maxRange = getWeaponMaxRange(weaponId)
        var area = getWeaponArea(weaponId)

        // Manual radius iteration (getCellsInRadius doesn't exist in LS4)
        for (var dx = -maxRange; dx <= maxRange; dx++) {
            for (var dy = -maxRange; dy <= maxRange; dy++) {
                var cellId = fromCell + FieldMapCore.x_offset * dx + FieldMapCore.y_offset * dy
                if (cellId < 0 || cellId >= FieldMap.board_cell_count) continue

                var dist = getCellDistance(fromCell, cellId)
                if (dist == null || dist < minRange || dist > maxRange) continue

                // Check line of sight for line weapons
                if (area == AREA_LASER_LINE) {
                    if (!lineOfSight(fromCell, cellId)) continue
                }

                // Check alignment for circle weapons (simplified - assume can hit)
                // Complex AoE validation would be expensive

                push(cells, cellId)
            }
        }

        return cells
    }

    // Estimate enemy weapon damage (conservative assumption)
    estimateEnemyWeaponDamage(weaponId, enemy) {
        // Get weapon effects to extract damage range
        var effects = getWeaponEffects(weaponId)
        var minDmg = 0
        var maxDmg = 0

        // Find EFFECT_DAMAGE in effects array
        for (var i = 0; i < count(effects); i++) {
            var effect = effects[i]
            if (effect[0] == EFFECT_DAMAGE) {
                minDmg = effect[1]
                maxDmg = effect[2]
                break
            }
        }

        var baseDmg = (minDmg + maxDmg) / 2

        // Check if enemy stats are available
        var enemyStr = enemy._strength
        var enemyMag = enemy._magic
        var enemyWis = enemy._wisdom

        // If stats available, estimate scaled damage
        if (enemyStr != null && enemyStr > 0) {
            // Strength weapon (simplified scaling)
            var scaledDmg = baseDmg * (1 + enemyStr / 100)
            return scaledDmg
        } else if (enemyMag != null && enemyMag > 0) {
            // Magic weapon (simplified scaling)
            var scaledDmg = baseDmg * (1 + enemyMag / 100)
            return scaledDmg
        }

        // Conservative fallback: assume 600 in primary stat (7x multiplier)
        return baseDmg * 7
    }

    // Get threat level at a specific cell
    getThreatAtCell(cellId) {
        if (mapContainsKey(this.enemyThreatMap, cellId)) {
            return this.enemyThreatMap[cellId]
        }
        return 0  // No threat = safe
    }

    // Find cells with zero or low threat
    getSafeCells(maxMP, maxThreat = 0) {
        var safe = []
        var playerPos = player._cellPos

        // Only check reachable cells (performance optimization)
        var candidates = this.getReachableCellsWithinMP(playerPos, maxMP)

        for (var i = 0; i < count(candidates); i++) {
            var cell = candidates[i]

            var threat = this.getThreatAtCell(cell)
            if (threat <= maxThreat) {
                push(safe, cell)
            }
        }

        debug("[THREAT-MAP] Found " + count(safe) + " safe cells within " + maxMP + " MP (threat â‰¤ " + maxThreat + ")")
        return safe
    }

    // Find best waypoint toward a target cell (multi-turn movement planning)
    // Returns cell that: gets us closer to target, is reachable, has acceptable threat
    // OPTIMIZED: Only check damage map cells (pre-calculated optimal positions)
    findSafeWaypointToward(targetCell, maxMP, maxThreat = 200) {
        var playerPos = player._cellPos
        var bestWaypoint = -1
        var bestScore = -99999

        // Cache distance calculations
        var currentDist = getCellDistance(playerPos, targetCell)
        var checked = 0
        var limit = 50  // Performance: check max 50 cells

        // OPTIMIZATION: Only check cells from damage map (pre-calculated positions)
        // This reduces search from ~300 cells to ~30 cells
        for (var cellId in mapKeys(this.damageMap)) {
            if (checked >= limit) break
            checked++

            var pathLen = getCachedPathLength(playerPos, cellId)
            if (pathLen == null || pathLen > maxMP) continue

            // Check threat level
            var threat = this.getThreatAtCell(cellId)
            if (threat > maxThreat) continue

            // Calculate progress toward target (negative = closer)
            var newDist = getCellDistance(cellId, targetCell)
            var progress = currentDist - newDist  // Positive = moving closer

            // Skip if not making progress
            if (progress <= 0) continue

            // Score: prioritize progress, penalize threat, prefer closer waypoints
            var score = progress * 100 - threat * 0.5 - pathLen * 5

            if (score > bestScore) {
                bestScore = score
                bestWaypoint = cellId
            }
        }

        if (bestWaypoint != -1) {
            var threat = this.getThreatAtCell(bestWaypoint)
            var newDist = getCellDistance(bestWaypoint, targetCell)
            debug("[MULTI-TURN] Waypoint to " + targetCell + ": cell " + bestWaypoint + " (threat=" + floor(threat) + ", remaining dist=" + newDist + ")")
        }

        return bestWaypoint
    }

    // Find best tactical cell (high damage, low threat)
    findBestTacticalCell(maxMP, threatWeight = 0.5) {
        var best = -1
        var bestScore = -99999
        var playerPos = player._cellPos

        for (var cellId in mapKeys(this.damageMap)) {
            var cell = this.damageMap[cellId]

            var pathLen = getCachedPathLength(playerPos, cell._id)
            if (pathLen == null || pathLen > maxMP) continue

            var ourDamage = cell._totalDamage
            var threat = this.getThreatAtCell(cell._id)

            // Score = our damage - (threat * weight)
            // Note: ourDamage naturally includes multi-enemy AoE value (sum of all enemies hit)
            // threatWeight: 0 = ignore threat, 1 = equal weight
            var score = ourDamage - (threat * threatWeight)

            if (score > bestScore) {
                bestScore = score
                best = cell
            }
        }

        if (best != -1) {
            var threat = this.getThreatAtCell(best._id)
            var multiHitInfo = best._enemiesHitCount >= 2 ? ", MULTI-HIT: " + best._enemiesHitCount + " enemies" : ""
            debug("[THREAT-MAP] Best tactical cell: " + best._id + " (damage=" + best._totalDamage + ", threat=" + threat + ", score=" + bestScore + multiHitInfo + ")")
        }

        return best
    }

    // Wrapper for compatibility - calls findHideAndSeekCell in defensive mode
    getHideAndSeekCell() {
        var result = this.findHideAndSeekCell("defensive")
        if (result != null) {
            return result['cell']
        }
        return null
    }
}
