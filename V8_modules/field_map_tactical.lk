include('field_map_patterns.lk')

// ====================================================================
// FIELD MAP - TACTICAL (Hide & Seek, OTKO, Caching)
// ====================================================================

class FieldMap extends FieldMapPatterns {
    // Per-turn cache for enemy accessible cells
    _enemyAccessCache = []
    _enemyAccessCacheTurn = -1
    _enemyAccessCacheIds = []

    private static board_cell_count = 613

    constructor() {
        super()
    }

    // ====================================================================
    // ACCESSIBLE CELLS (for HNS calculations)
    // ====================================================================

    // Compute all cells reachable this turn for given entity
    getAccessibleCells(entity) {
        var acc = []
        if (entity == null) return acc
        var mp = entity._currMp
        var origin = entity._cellPos
        for (var cid = 0; cid < FieldMap.board_cell_count; cid++) {
            if (isObstacle(cid)) continue
            var approx = getCellDistance(origin, cid)
            if (approx == null || approx > mp) continue
            var len = getPathLength(origin, cid)
            if (len == null) continue
            if (len <= mp) push(acc, cid)
        }
        return acc
    }

    // Build or reuse cached enemy accessible cells
    getEnemyAccess() {
        var curTurn = getTurn()
        var enemiesMap = this.getEnemySubMap()
        var enemyIdsNow = mapKeys(enemiesMap)

        // Rebuild conditions: turn changed OR enemy count changed OR ID mismatch
        var needRebuild = (curTurn != this._enemyAccessCacheTurn)
        if (!needRebuild && count(enemyIdsNow) != count(this._enemyAccessCacheIds)) needRebuild = true
        if (!needRebuild) {
            for (var i = 0; i < count(enemyIdsNow); i++) {
                var found = false
                for (var j = 0; j < count(this._enemyAccessCacheIds); j++) {
                    if (enemyIdsNow[i] == this._enemyAccessCacheIds[j]) { found = true; break }
                }
                if (!found) { needRebuild = true; break }
            }
        }

        if (needRebuild) {
            this._enemyAccessCache = []
            this._enemyAccessCacheIds = []
            for (var ei = 0; ei < count(enemyIdsNow); ei++) {
                var eid = enemyIdsNow[ei]
                var enemyObj = enemiesMap[eid]
                if (enemyObj == null) continue
                var eAcc = this.getAccessibleCells(enemyObj)
                if (indexOf(eAcc, enemyObj._cellPos) == -1) push(eAcc, enemyObj._cellPos)
                push(this._enemyAccessCache, ['enemy': enemyObj, 'cells': eAcc])
                push(this._enemyAccessCacheIds, eid)
            }
            this._enemyAccessCacheTurn = curTurn
            debug("[HNS][CACHE] Rebuilt enemy access cache size=" + count(this._enemyAccessCache))
        }
        return this._enemyAccessCache
    }

    // ====================================================================
    // HIDE & SEEK CELL SELECTION
    // ====================================================================

    // Unified Hide & Seek cell evaluation
    // mode: "defensive" (maximize distance) or "approach" (prefer attack cells)
    // target: required for "approach" mode
    findHideAndSeekCell(mode = "defensive", target = null) {
        var enemyAccess = this.getEnemyAccess()
        if (count(enemyAccess) == 0) return null
        var playerAccessible = this.getAccessibleCells(player)
        if (indexOf(playerAccessible, player._cellPos) == -1) push(playerAccessible, player._cellPos)

        var isApproachMode = (mode == "approach")
        var targetPos = isApproachMode ? target._cellPos : -1
        var currentDist = isApproachMode ? getCellDistance(player._cellPos, targetPos) : -1

        var bestCell = -1
        var bestDanger = 99999
        var bestDist = isApproachMode ? 99999 : -1  // Approach: minimize, Defensive: maximize
        var bestCanAttack = false
        var bestCover = -1  // Cover score (0-8, higher is better)
        var playerPos = player._cellPos

        for (var i = 0; i < count(playerAccessible); i++) {
            var cand = playerAccessible[i]

            // Calculate distance metric
            var distMetric = 0
            if (isApproachMode) {
                distMetric = getCellDistance(cand, targetPos)
                if (distMetric == null) continue
            } else {
                // Defensive: distance to closest enemy
                var closestEnemyDist = 999
                for (var ea = 0; ea < count(enemyAccess); ea++) {
                    var enemyRef = enemyAccess[ea]['enemy']
                    if (enemyRef == null) continue
                    var eOrigDist = getCellDistance(cand, enemyRef._cellPos)
                    if (eOrigDist != null && eOrigDist < closestEnemyDist) closestEnemyDist = eOrigDist
                }
                distMetric = (closestEnemyDist == 999) ? 0 : closestEnemyDist
            }

            // Check if cell allows attack (approach mode only)
            var canAttack = false
            if (isApproachMode) {
                // Skip cells that increase distance unless they allow attack
                if (distMetric > currentDist) {
                    if (mapContainsKey(this.damageMap, cand)) {
                        var cellRef = this.damageMap[cand]
                        if (cellRef._highestDamageWeapon != -1 || cellRef._highestDamageChip != -1) {
                            canAttack = true
                        }
                    }
                    if (!canAttack) continue
                } else if (mapContainsKey(this.damageMap, cand)) {
                    var cellRef = this.damageMap[cand]
                    if (cellRef._highestDamageWeapon != -1 || cellRef._highestDamageChip != -1) {
                        canAttack = true
                    }
                }
            }

            // Calculate danger (LOS exposures) and cover score
            var danger = this.computeDangerForCell(cand, enemyAccess)
            var coverScore = this.evaluateCoverScore(cand)

            // Scoring based on mode
            var shouldUpdate = false
            if (bestCell == -1) {
                shouldUpdate = true
            } else if (isApproachMode) {
                // Approach mode: canAttack > lower danger > lower distance > higher cover
                if (canAttack && !bestCanAttack) {
                    shouldUpdate = true
                } else if (canAttack == bestCanAttack) {
                    if (danger < bestDanger ||
                        (danger == bestDanger && distMetric < bestDist) ||
                        (danger == bestDanger && distMetric == bestDist && coverScore > bestCover) ||
                        (danger == bestDanger && distMetric == bestDist && coverScore == bestCover && distMetric < currentDist && bestDist >= currentDist)) {
                        shouldUpdate = true
                    }
                }
            } else {
                // Defensive mode: lower danger > greater distance > higher cover
                if (danger < bestDanger ||
                    (danger == bestDanger && distMetric > bestDist) ||
                    (danger == bestDanger && distMetric == bestDist && coverScore > bestCover)) {
                    shouldUpdate = true
                }
            }

            if (shouldUpdate) {
                bestCell = cand
                bestDanger = danger
                bestDist = distMetric
                bestCanAttack = canAttack
                bestCover = coverScore
            }
        }

        if (bestCell == -1) return null

        if (isApproachMode) {
            if (bestCell != playerPos) mark(bestCell, getColor(255, 200, 120), 3)
            debug("[HNS-" + mode + "] bestCell=" + bestCell + " canAttack=" + bestCanAttack + " danger=" + bestDanger + " dist=" + bestDist + " cover=" + bestCover + " currentDist=" + currentDist)
            return ['cell': bestCell, 'danger': bestDanger, 'canAttack': bestCanAttack, 'dist': bestDist, 'cover': bestCover, 'safe': (bestDanger == 0)]
        } else {
            if (bestCell != playerPos) mark(bestCell, getColor(120, 200, 255), 3)
            debug("[HNS-" + mode + "] bestCell=" + bestCell + " danger=" + bestDanger + " dist=" + bestDist + " cover=" + bestCover + " playerPos=" + playerPos)
            return ['cell': bestCell, 'danger': bestDanger, 'safe': (bestDanger == 0), 'dist': bestDist, 'cover': bestCover]
        }
    }

    // Compute danger (LOS exposures) for single cell
    private computeDangerForCell(cellId, enemyAccess) {
        var danger = 0
        for (var ea = 0; ea < count(enemyAccess); ea++) {
            var cellsArr = enemyAccess[ea]['cells']
            for (var ec = 0; ec < count(cellsArr); ec++) {
                if (lineOfSight(cellsArr[ec], cellId)) { danger += 1 }
            }
        }
        return danger
    }

    // Evaluate cover quality (adjacent obstacles provide tactical advantage)
    // Returns: 0-8 score (higher = more adjacent obstacles)
    private evaluateCoverScore(cellId) {
        var adjacentObstacles = 0
        var cellX = getCellX(cellId)
        var cellY = getCellY(cellId)

        // Check all 8 adjacent cells (using cell coordinate system)
        var offsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
        for (var o = 0; o < count(offsets); o++) {
            var neighborCell = getCellFromXY(cellX + offsets[o][0], cellY + offsets[o][1])
            if (neighborCell != null && isObstacle(neighborCell)) {
                adjacentObstacles += 1
            }
        }
        return adjacentObstacles
    }


    // ====================================================================
    // OTKO TELEPORTATION SUPPORT
    // ====================================================================

    // Find optimal teleport cell for OTKO
    findOptimalTeleportCell(target) {
        if (target == null) return null

        var playerPos = player._cellPos
        var bestCell = -1
        var bestDamage = -1
        var targetHP = target._currHealth

        for (var cellId = 0; cellId < FieldMap.board_cell_count; cellId++) {
            if (isObstacle(cellId)) continue
            if (isEntity(cellId)) continue

            var distFromPlayer = getCellDistance(playerPos, cellId)
            if (distFromPlayer == null || distFromPlayer < 1 || distFromPlayer > 12) continue

            var totalDamage = 0
            var playerTP = player._currTp - 9  // Reserve 9 TP for teleport
            var tpSpent = 0  // Track TP consumed (weapons + chips)

            // Check all equipped weapons
            for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
                var wObj = arsenal.playerEquippedWeapons[wid]
                if (wObj == null) continue

                var distToTarget = getCellDistance(cellId, target._cellPos)
                if (distToTarget == null) continue
                if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
                if (!lineOfSight(cellId, target._cellPos)) continue

                var weaponDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)
                var tpBudget = playerTP - tpSpent
                var swapCost = (getWeapon() != wid) ? 1 : 0
                if (tpBudget <= swapCost) continue
                var uses = min(wObj._maxUse, floor((tpBudget - swapCost) / wObj._cost))
                if (uses <= 0) continue
                totalDamage += weaponDmg * uses
                tpSpent += swapCost + uses * wObj._cost
            }

            // Check damage chips if TP remains
            var tpRemaining = playerTP - tpSpent
            if (tpRemaining > 0) {
                for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                    var chipObj = arsenal.playerEquippedChips[cid]
                    if (chipObj == null) continue
                    if (cid == CHIP_TELEPORTATION) continue

                    if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                    var distChip = getCellDistance(cellId, target._cellPos)
                    if (distChip == null) continue
                    if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                    if (!lineOfSight(cellId, target._cellPos)) continue

                    var chipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                    var tpBudgetChip = playerTP - tpSpent
                    if (tpBudgetChip < chipObj._cost) continue
                    var usesChip = min(chipObj._maxUse, floor(tpBudgetChip / chipObj._cost))
                    if (usesChip <= 0) continue
                    totalDamage += chipDmg * usesChip
                    tpSpent += usesChip * chipObj._cost
                }
            }

            if (totalDamage > bestDamage) {
                bestDamage = totalDamage
                bestCell = cellId
            }
        }

        if (bestCell == -1) return null

        var canKill = (bestDamage >= targetHP)
        debug("[OTKO-TELEPORT] bestCell=" + bestCell + " projectedDamage=" + bestDamage + " targetHP=" + targetHP + " canKill=" + canKill)

        return ['cell': bestCell, 'damage': bestDamage, 'canKill': canKill]
    }
}
