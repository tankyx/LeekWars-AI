/** Exporté le 10/2/2025, 1:09:47 PM **/

/** 8.0/V8/fight_strategy.lk **/

/** Exporté le 10/1/2025, 4:37:38 PM **/

/** 8.0/V8/fight_strategy.lk **/

class Action {
    static NONE = -1
    static ACTION_DIRECT = 0
    static ACTION_DOT = 1
    static ACTION_DEBUFF = 2
    static ACTION_BUFF = 3
    static ACTION_WEAPON_SWAP = 4
    static MOVEMENT_APPROACH = 5
    static MOVEMENT_OFFENSIVE = 6
    static MOVEMENT_DEFENSIVE = 7
    static MOVEMENT_OTKO = 8
    static MOVEMENT_DOT_OFFENSIVE = 9
    static MOVEMENT_DEBUFF = 10
    static MOVEMENT_FLEE = 11
    static MOVEMENT_HNS = 12 // Hide and Seek
    static MOVEMENT_PAB = 13 // Peek-a-Boo

    type = -1
    weaponId = -1
    chip = -1
    targetCell = -1
    targetEntity = -1

    constructor(type, weaponId, chip, targetCell, targetEntity) {
        this.type = type
        this.weaponId = weaponId
        this.chip = chip
        this.targetCell = targetCell
        this.targetEntity = targetEntity
    }
}

class Strategy {
    _actions = []
    _playerTP = -1
    _fieldMap = null

    constructor() {
        this._playerTP = getTP()
    }

    // Helper to centralize repeated distance and line-of-sight checks.
    inRangeAndLOS(fromCell, targetCell, minR, maxR) {
        var dist = getCellDistance(fromCell, targetCell)
        if (dist < minR || dist > maxR) return false
        if (!lineOfSight(fromCell, targetCell)) return false
        return true
    }

    turnOneBuffs() {
        debug("Applying turn one buffs if available")
        debug("Dumping equipped chips:")
        for (var c in mapKeys(arsenal.playerEquippedChips)) {
            debug(" - " + getChipName(c))
        }
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_KNOWLEDGE)) {
            debug("Using Knowledge chip")
            useChip(CHIP_KNOWLEDGE, player._id)
        }
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ARMORING)) {
            debug("Using Armoring chip")
            useChip(CHIP_ARMORING, player._id)
        }
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ELEVATION)) {
            debug("Using Elevation chip")
            useChip(CHIP_ELEVATION, player._id)
        }
        if (getWeapon() == null) {
            setWeapon(arsenal.getHighestDamageWeapon())
        }
    }

    createMovementAction(type, targetHitCellID, target) {
        push(this._actions, new Action(
            type,
            -1,
            -1,
            targetHitCellID,
            target
        ))
        debug("Planned movement action: Type " + type + " to cell " + targetHitCellID + " towards entity " + getName(target._id))
    }

    createAttackAction(type, target, weaponID = -1, chipID = -1) {
        push(this._actions, new Action(
            type,
            weaponID,
            chipID,
            target._cellPos,
            target
        ))
        debug("Planned attack action: Type " + type + " on entity " + getName(target._id) + " with weapon " + getWeaponName(weaponID) + " and chip " + getChipName(chipID))
    }

    createOffensiveScenario(target, targetHitCell) {
        // If magic oriented, optionally re-select target cell giving higher weight to DoT
        if (player._magic > player._strength) {
            // heuristic weights: treat total DoT as 1.5x direct for magic builds
            var weightedCell = fieldMap.getBestWeightedDamageCell(1.5, 1)
            if (weightedCell != -1) {
                targetHitCell = weightedCell
            }
        }
        // BEFORE committing to original target cell, see if an approach-hide cell is superior (can still attack + less danger)
        var hnsApproach = fieldMap.findApproachHideAndSeekCell(target)
        if (hnsApproach != null) {
            // Replace target cell if it allows attack or if original target not set
            var adopt = false
            if (hnsApproach['canAttack'] || targetHitCell == -1) adopt = true
            else if (targetHitCell != -1 && targetHitCell != null) {
                // If current target has same total damage but is farther, adopt HNS
                if (mapContainsKey(fieldMap.damageMap, hnsApproach['cell']) && mapContainsKey(fieldMap.damageMap, targetHitCell._id)) {
                    var hCellObj = fieldMap.damageMap[hnsApproach['cell']]
                    if (hCellObj._totalDamage == targetHitCell._totalDamage) {
                        var distCurrent = getPathLength(player._cellPos, targetHitCell._id)
                        var distH = getPathLength(player._cellPos, hCellObj._id)
                        if (distH != null && distCurrent != null && distH < distCurrent) adopt = true
                    }
                }
            }
            if (adopt) {
                if (targetHitCell != -1 && targetHitCell != null && targetHitCell._id != hnsApproach['cell']) {
                    debug("[HNS-APPROACH] Replacing offensive target cell with safer approach cell " + hnsApproach['cell'])
                }
                // Wrap chosen id into existing cell object if present in damageMap
                if (mapContainsKey(fieldMap.damageMap, hnsApproach['cell'])) {
                    targetHitCell = fieldMap.damageMap[hnsApproach['cell']]
                } else {
                    // Fallback: fabricate minimal Cell proxy with id for movement if not a damage cell
                    targetHitCell = new Cell(hnsApproach['cell'], false, -1, 0, 0, false, -1, -1)
                }
            }
        }
        // First, we check if we can reach the target hit cell
        var playerPos = player._cellPos
        var playerMP = player._currMp
        var playerTP = player._currTp
        var pathLength = getPathLength(playerPos, targetHitCell._id)

        debug("Player position: " + playerPos)
        debug("Player MP: " + playerMP + " Player TP: " + playerTP)
        debug("Path length to target hit cell: " + pathLength)

        if (pathLength > playerMP) {
            // Can't reach the target hit cell, we move as close as possible
            createMovementAction(Action.MOVEMENT_APPROACH, targetHitCell._id, target)
            debug("Can't reach target hit cell, moving as close as possible")
            return;
        }
        // We can reach the target hit cell, move only if not already there
        if (pathLength > 0) {
            createMovementAction(Action.MOVEMENT_OFFENSIVE, targetHitCell._id, target)
        } else {
            debug("Already on optimal offensive cell (" + targetHitCell._id + ") skipping movement")
        }

        playerPos = targetHitCell._id
        playerMP -= pathLength

        // Decide primary offensive resource (weapon or chip) based on cell best type
        if (targetHitCell._bestType == 0 && targetHitCell._highestDamageWeapon != -1) {
            // Weapon path
            if (getWeapon() != targetHitCell._highestDamageWeapon._id) {
                if (playerTP < 1 + targetHitCell._highestDamageWeapon._cost) {
                    debug("Not enough TP to swap and use weapon " + getWeaponName(targetHitCell._highestDamageWeapon._id))
                } else {
                    createAttackAction(Action.ACTION_WEAPON_SWAP, target, targetHitCell._highestDamageWeapon._id, -1)
                    playerTP -= 1
                }
            }
            var useCount = targetHitCell._highestDamageWeapon._maxUse
            while (playerTP >= targetHitCell._highestDamageWeapon._cost && useCount > 0) {
                createAttackAction(Action.ACTION_DIRECT, target, targetHitCell._highestDamageWeapon._id, -1)
                playerTP -= targetHitCell._highestDamageWeapon._cost
                useCount -= 1
            }
        }
        else if (targetHitCell._bestType == 1 && targetHitCell._highestDamageChip != -1) {
            // Chip path
            var chipRef = targetHitCell._highestDamageChip
            // Use chip as many times as allowed by TP and maxUse
            var chipUses = chipRef._maxUse
            while (playerTP >= chipRef._cost && chipUses > 0) {
                createAttackAction(Action.ACTION_DIRECT, target, -1, chipRef._id)
                playerTP -= chipRef._cost
                chipUses -= 1
            }
        }

        // No more TP or uses on primary weapon; evaluate other weapons
        var primaryWid = -1
        if (targetHitCell._highestDamageWeapon != -1 && targetHitCell._highestDamageWeapon != null) primaryWid = targetHitCell._highestDamageWeapon._id
        var weaponIds = mapKeys(arsenal.playerEquippedWeapons)
        for (var wi = 0; wi < count(weaponIds); wi++) {
            var wid = weaponIds[wi]
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue
            if (wObj._id == primaryWid) continue
            if (playerTP < wObj._cost + 1) {
                debug("Skipping weapon " + getWeaponName(wObj._id) + " since not enough TP for swap and use")
                continue
            }
            debug("Checking weapon " + getWeaponName(wObj._id) + " for possible use")
            var secondHitCell = fieldMap.getClosestHitCellForWeapon(wObj)
            if (secondHitCell == -1) {
                debug("No reachable hit cell found for weapon " + getWeaponName(wObj._id))
                continue
            }
            var secondPathLength = getPathLength(playerPos, secondHitCell._id)
            if (secondPathLength != null && secondPathLength <= playerMP) {
                if (secondPathLength > 0) {
                    createMovementAction(Action.MOVEMENT_OFFENSIVE, secondHitCell._id, target)
                    playerMP -= secondPathLength
                } else {
                    debug("Already on secondary weapon cell for " + getWeaponName(wObj._id))
                }
                createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                playerTP -= 1
                while (playerTP >= wObj._cost) {
                    createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                    playerTP -= wObj._cost
                }
            }
        }

        // Consider spare TP for secondary source (weapon after chip or chip after weapon)
        if (playerTP > 0) {
            if (targetHitCell._bestType == 0) {
                // After weapon usage, try damaging chips
                for (var c in arsenal.playerEquippedChips) {
                    if (playerTP < c._cost) continue
                    if (!mapContainsKey(c._effects, EFFECT_DAMAGE) && !mapContainsKey(c._effects, EFFECT_POISON)) continue
                    createAttackAction(Action.ACTION_DIRECT, target, -1, c._id)
                    playerTP -= c._cost
                }
            } else {
                // After chip usage, attempt remaining weapon attacks with current or swap if efficient
                var activeWeapon = getWeapon()
                if (activeWeapon != null && mapContainsKey(arsenal.playerEquippedWeapons, activeWeapon)) {
                    var aw = arsenal.playerEquippedWeapons[activeWeapon]
                    var useCount2 = aw._maxUse
                    while (playerTP >= aw._cost && useCount2 > 0) {
                        createAttackAction(Action.ACTION_DIRECT, target, aw._id, -1)
                        playerTP -= aw._cost
                        useCount2 -= 1
                    }
                }
            }
        }

        // Post-offensive Hide & Seek: attempt to relocate to a safer cell with remaining MP
        // playerMP tracks remaining MP after initial approach earlier in this function.
        if (playerMP > 0) {
            var hnsInfo = fieldMap.findHideAndSeekCell()
            if (hnsInfo != null) {
                var hideCellId = hnsInfo['cell']
                if (hideCellId != targetHitCell._id) {
                    var legLen = getPathLength(targetHitCell._id, hideCellId)
                    if (legLen != null && legLen <= playerMP) {
                        debug("[HNS] Scheduling post-attack hide move to cell " + hideCellId + " danger=" + hnsInfo['danger'])
                        createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
                        playerMP -= legLen
                    } else if (legLen != null) {
                        debug("[HNS] Can't reach hide cell after attack (need " + legLen + " have " + playerMP + ")")
                    }
                } else {
                    debug("[HNS] Attack cell already optimal hide cell (danger=" + hnsInfo['danger'] + ")")
                }
            }
        }
    }

    // Base defensive scenario usable by all strategies
    createDefensiveScenario(target, targetHitCell) {
        // Optional self-heal before moving away if chip is equipped and usable
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)) {
            var regenChip = arsenal.playerEquippedChips[CHIP_REGENERATION]
            if (getCooldown(CHIP_REGENERATION, getEntity()) == 0 && getTP() >= regenChip._cost && getLife() < getTotalLife()) {
                this.createAttackAction(Action.ACTION_DIRECT, player, -1, CHIP_REGENERATION)
            }
        }

        // Move away from the target using available MP (builtin API)
        // Attempt hide-and-seek cell first (safer than a simple flee if available)
        var hns = fieldMap.findHideAndSeekCell()
        if (hns != null) {
            var hCell = hns['cell']
            if (hCell != player._cellPos) {
                debug("[HNS] Executing defensive hide movement to cell " + hCell + " safe=" + hns['safe'] + " danger=" + hns['danger'])
                this.createMovementAction(Action.MOVEMENT_HNS, hCell, target)
            } else {
                debug("[HNS] Current cell already chosen as best hide cell (danger=" + hns['danger'] + ")")
            }
        } else {
            var usedMp = moveAwayFrom(target._id)
            debug("moveAwayFrom used MP: " + usedMp)
        }

        // After moving, refresh
        player.updateEntity()
        fieldMap.updateMapEntities()

        // Try to shoot any available weapon from the new cell
        var playerPos = player._cellPos
        var playerTP = player._currTp

        if (mapContainsKey(fieldMap.damageMap, playerPos)) {
            var cell = fieldMap.damageMap[playerPos]
            if (cell._highestDamageWeapon != -1) {
                var w = cell._highestDamageWeapon
                var needSwap = (getWeapon() != w._id)

                if (needSwap && playerTP >= 1) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, w._id, -1)
                    playerTP -= 1
                }

                var useCount = w._maxUse
                while (playerTP >= w._cost && useCount > 0) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, w._id, -1)
                    playerTP -= w._cost
                    useCount -= 1
                }
            }
        }
    }

    createAndExecuteDefensiveScenario(target) {
        arrayClear(this._actions)
        this.createDefensiveScenario(target, -1)
        this.executeScenario()
    }

    // If below 25% HP, use defensive; else offensive
    createAndExecuteScenario(target, targetHitCell) {
        arrayClear(this._actions)
        if (getLife() * 4 < getTotalLife()) {
            debug("Low HP detected (<25%), switching to defensive strategy")
            this.createDefensiveScenario(target, targetHitCell)
        } else {
            this.createOffensiveScenario(target, targetHitCell)
        }
        this.executeScenario()
    }

    executeScenario() {
        for (var a in this._actions) {
            if (a.type == Action.MOVEMENT_APPROACH || a.type == Action.MOVEMENT_OFFENSIVE || a.type == Action.MOVEMENT_DEFENSIVE || a.type == Action.MOVEMENT_OTKO || a.type == Action.MOVEMENT_DOT_OFFENSIVE || a.type == Action.MOVEMENT_DEBUFF) {
                debug("Executing movement (toward) action to cell " + a.targetCell)
                moveTowardCell(a.targetCell)
            }
            else if (a.type == Action.MOVEMENT_FLEE) {
                debug("Executing flee/kite movement away from entity " + a.targetEntity._id)
                moveAwayFrom(a.targetEntity._id)
            }
            else if (a.type == Action.MOVEMENT_HNS) {
                debug("Executing Hide&Seek movement to cell " + a.targetCell)
                moveTowardCell(a.targetCell)
            }
            else if (a.type == Action.ACTION_WEAPON_SWAP) {
                debug("Swapping to weapon " + getWeaponName(a.weaponId))
                setWeapon(a.weaponId)
            }
            else if (a.type == Action.ACTION_DIRECT || a.type == Action.ACTION_DOT || a.type == Action.ACTION_DEBUFF) {
                debug("Executing attack action on entity " + a.targetEntity + " with weapon " + getWeaponName(a.weaponId))
                if (a.chip != -1) {
                    useChipOnCell(a.chip, a.targetEntity._cellPos)
                }
                else {
                    useWeaponOnCell(a.targetEntity._cellPos)
                }
            }
        }
    }
}

// Using builtin moveAwayFrom(entityId, [mp]) from LeekScript API.

class StrengthStrategy extends Strategy {
    constructor() {
        super()
    }

    createOTKOScenario(target, targetHitCell) {

    }

    // Override offensive scenario for Strength builds: always prioritize weapons (highest weapon damage cell)
    // Only after exhausting primary + secondary weapons do we spend leftover TP on damage chips (sorted by per-use damage desc).
    createOffensiveScenario(target, targetHitCell) {
        // Re-compute best pure weapon cell ignoring chip-only high damage cells.
        var bestWeaponCell = -1
        var bestWeaponDamage = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in fieldMap.damageMap) {
            if (c._highestDamageWeapon == -1) continue
            var dist = getPathLength(playerPos, c._id)
            if (dist == null) continue
            // Prefer higher weaponDamage, tie-break shorter distance
            if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                bestWeaponDamage = c._weaponDamage
                bestWeaponCell = c
                bestDist = dist
            }
        }
        // Fallback to incoming targetHitCell if no weapon cell found (should be rare)
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) bestWeaponCell = targetHitCell
        if (bestWeaponCell == -1) {
            debug("[STR] No weapon cell found; falling back to base logic")
            return super.createOffensiveScenario(target, targetHitCell)
        }

        // Optional: consider approach hide cell if it allows attack with same weaponDamage and is closer.
        var hnsApproach = fieldMap.findApproachHideAndSeekCell(target)
        if (hnsApproach != null && hnsApproach['canAttack'] && mapContainsKey(fieldMap.damageMap, hnsApproach['cell'])) {
            var hCellObj = fieldMap.damageMap[hnsApproach['cell']]
            if (hCellObj._highestDamageWeapon != -1) {
                var distOrig = getPathLength(playerPos, bestWeaponCell._id)
                var distH = getPathLength(playerPos, hCellObj._id)
                if (distH != null && distOrig != null && hCellObj._weaponDamage >= bestWeaponCell._weaponDamage && distH < distOrig) {
                    debug("[STR][HNS-APPROACH] Switching weapon cell to safer/closer cell " + hCellObj._id)
                    bestWeaponCell = hCellObj
                }
            }
        }

        var pathLen = getPathLength(playerPos, bestWeaponCell._id)
        var playerMP = player._currMp
        var playerTP = player._currTp

        if (pathLen == null) pathLen = 99999
        if (pathLen > playerMP) {
            // Move as close as possible (reuse generic approach movement)
            this.createMovementAction(Action.MOVEMENT_APPROACH, bestWeaponCell._id, target)
            debug("[STR] Approaching weapon cell (unreachable this turn) cell=" + bestWeaponCell._id)
            // No attacks (can't reach) stop here.
            return
        }

        if (pathLen > 0) {
            this.createMovementAction(Action.MOVEMENT_OFFENSIVE, bestWeaponCell._id, target)
            playerMP -= pathLen
            playerPos = bestWeaponCell._id
        } else {
            debug("[STR] Already on best weapon cell " + bestWeaponCell._id)
        }

        // Primary weapon usage
        var primaryWeapon = bestWeaponCell._highestDamageWeapon
        if (primaryWeapon != -1 && primaryWeapon != null) {
            if (getWeapon() != primaryWeapon._id) {
                if (playerTP >= 1 + primaryWeapon._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, primaryWeapon._id, -1)
                    playerTP -= 1
                } else {
                    debug("[STR] Not enough TP to swap and use primary weapon " + getWeaponName(primaryWeapon._id))
                }
            }
            var uses = primaryWeapon._maxUse
            while (playerTP >= primaryWeapon._cost && uses > 0) {
                this.createAttackAction(Action.ACTION_DIRECT, target, primaryWeapon._id, -1)
                playerTP -= primaryWeapon._cost
                uses -= 1
            }
        }

        // Secondary weapons (similar to base but after primary only)
        var primaryWid = (primaryWeapon != -1 && primaryWeapon != null) ? primaryWeapon._id : -1
        var weaponIds = mapKeys(arsenal.playerEquippedWeapons)
        for (var wi = 0; wi < count(weaponIds); wi++) {
            var wid = weaponIds[wi]
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue
            if (wObj._id == primaryWid) continue
            if (playerTP < wObj._cost + 1) continue // need swap + one use
            // Check if we already are on a valid cell for this weapon; if not and have MP remaining we can attempt moving (but we already moved). Skip extra movement for simplicity.
            // Just fire if current cell allows; else attempt to find closest cell within remaining MP.
            var curCellObj = null
            if (mapContainsKey(fieldMap.damageMap, playerPos)) curCellObj = fieldMap.damageMap[playerPos]
            var canFireHere = false
            if (curCellObj != null) {
                for (var wL = 0; wL < count(curCellObj._weaponsList); wL++) { if (curCellObj._weaponsList[wL]._id == wObj._id) { canFireHere = true; break } }
            }
            if (!canFireHere) continue
            this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
            playerTP -= 1
            var uses2 = wObj._maxUse
            while (playerTP >= wObj._cost && uses2 > 0) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses2 -= 1
            }
        }

        // Finally: spend leftover TP on damage/poison chips sorted by per-use total damage (descending)
        if (playerTP > 0) {
            var dmgChips = []
            var chipIds = mapKeys(arsenal.playerEquippedChips)
            for (var ci = 0; ci < count(chipIds); ci++) {
                var cid = chipIds[ci]
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                // Filter attack chips (damage or poison effects)
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue
                // Range & LOS from bestWeaponCell (current position)
                var distChip = getCellDistance(bestWeaponCell._id, target._cellPos)
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(bestWeaponCell._id, target._cellPos)) continue
                var bd = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, chipObj._id)
                push(dmgChips, ['chip': chipObj, 'per': bd['total']])
            }
            // Selection sort descending by per-use total
            for (var i = 0; i < count(dmgChips); i++) {
                var bestIdx = i
                for (var j = i + 1; j < count(dmgChips); j++) { if (dmgChips[j]['per'] > dmgChips[bestIdx]['per']) bestIdx = j }
                if (bestIdx != i) { var tmp = dmgChips[i]; dmgChips[i] = dmgChips[bestIdx]; dmgChips[bestIdx] = tmp }
            }
            for (var dc = 0; dc < count(dmgChips); dc++) {
                var rec = dmgChips[dc]
                var chipUse = rec['chip']
                if (playerTP < chipUse._cost) continue
                var usesC = min(chipUse._maxUse, floor(playerTP / chipUse._cost))
                while (usesC > 0 && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    usesC -= 1
                }
                if (playerTP <= 0) break
            }
        }

        // Post-offensive HNS relocation (reuse base logic portion)
        if (playerMP > 0) {
            var hnsInfo = fieldMap.findHideAndSeekCell()
            if (hnsInfo != null) {
                var hideCellId = hnsInfo['cell']
                if (hideCellId != bestWeaponCell._id) {
                    var legLen = getPathLength(bestWeaponCell._id, hideCellId)
                    if (legLen != null && legLen <= playerMP) {
                        debug("[STR][HNS] Adding hide move to cell " + hideCellId + " danger=" + hnsInfo['danger'])
                        this.createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
                        playerMP -= legLen
                    }
                }
            }
        }
    }

}

class MagicStrategy extends Strategy {
    constructor() {
        super()
    }

    // Static maps to persist across turns (enemy-focused state)
    static _prevPoisonRemaining = [:]        // enemyId -> previous remaining poison turns (last turn)
    static _recentAntidoteTurn = [:]         // enemyId -> last turn we inferred antidote usage
    static _baitMode = [:]                   // enemyId -> bool (true = still baiting, suppress poison chips)

    // Chips that we are allowed to use even while baiting (minimal commitment to force antidote)
    static isBaitAllowedChip(chipId) {
        // Assumes constant CHIP_VENOM exists; extend list if needed (e.g., CHIP_MINOR_TOXIN)
        return chipId == CHIP_VENOM
    }

    // Inference helper: determine if antidote was likely used (poison cleared earlier than natural expiry)
    static inferAntidoteUse(enemyId, prevRemain, currRemain, wasPoisonedPrev, isPoisonedNow) {
        if (!wasPoisonedPrev) return false
        // Natural decay: remaining should go prevRemain-1 (>=0). If poison vanished and prevRemain > 1 --> cleanse.
        if (wasPoisonedPrev && !isPoisonedNow && prevRemain > 1) return true
        // If still poisoned but remaining increased (shouldn't happen) treat as cleanse + reapply (rare) -> consider antidote triggered.
        if (isPoisonedNow && currRemain > prevRemain) return true
        return false
    }

    createDebuffScenario() {

    }

    // ---- Refactored DoT kite orchestration ----
    createAndExecuteDotKite(target, targetHitCell) {
        arrayClear(this._actions)
        target.updateEntity()
        player.updateEntity()

        var poisonActive = target.hasEffect(EFFECT_POISON)
        var poisonRemaining = target.getEffectRemaining(EFFECT_POISON)
        debug("[DoT-KITE] Start poisonActive=" + poisonActive + " remaining=" + poisonRemaining + " TP=" + player._currTp + " MP=" + player._currMp)

        var enemyId = target._id
        var wasPoisonedPrev = mapContainsKey(MagicStrategy._prevPoisonRemaining, enemyId) && MagicStrategy._prevPoisonRemaining[enemyId] >= 0
        var prevRemain = wasPoisonedPrev ? MagicStrategy._prevPoisonRemaining[enemyId] : -1
        var curTurn = getTurn()
        var antidoteCD = getCooldown(CHIP_ANTIDOTE, enemyId)
        var inferredUse = MagicStrategy.inferAntidoteUse(enemyId, prevRemain, poisonRemaining, wasPoisonedPrev, poisonActive)
        // Determine if enemy actually owns Antidote chip; if not, never enter bait mode.
        var enemyHasAntidote = false
        var enemyChipsList = getChips(enemyId)
        if (enemyChipsList != null) {
            for (var ecIdx = 0; ecIdx < count(enemyChipsList); ecIdx++) {
                if (enemyChipsList[ecIdx] == CHIP_ANTIDOTE) { enemyHasAntidote = true; break }
            }
        }
        if (inferredUse) {
            MagicStrategy._recentAntidoteTurn[enemyId] = curTurn
            MagicStrategy._baitMode[enemyId] = false
            debug("[ANTIDOTE][DETECT] Early poison cleanse (prevRemaining=" + prevRemain + ") enemy=" + enemyId + " turn=" + curTurn)
        }
        if (!enemyHasAntidote) {
            MagicStrategy._baitMode[enemyId] = false
            if (!inferredUse) debug("[ANTIDOTE][CHECK] enemy=" + enemyId + " has NO antidote -> disabling bait mode")
        } else {
            if (!mapContainsKey(MagicStrategy._baitMode, enemyId)) {
                MagicStrategy._baitMode[enemyId] = true
            }
            if (antidoteCD == 0 && !inferredUse) {
                if (MagicStrategy._baitMode[enemyId] == false) debug("[ANTIDOTE][RESET] Cooldown ready again -> re-enter bait mode for enemy=" + enemyId)
                MagicStrategy._baitMode[enemyId] = true
            }
        }
        var baiting = MagicStrategy._baitMode[enemyId]
        debug("[ANTIDOTE][STATE] enemy=" + enemyId + " baiting=" + baiting + " inferredUse=" + inferredUse + " cd=" + antidoteCD + " prevRemain=" + prevRemain)
        // Escalate out of bait mode if cleanse confirmed and cooldown running or repeated natural expiry stalling
        if (baiting && wasPoisonedPrev && !poisonActive && prevRemain > 0 && antidoteCD > 0) {
            MagicStrategy._baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Cleanse + cooldown -> full offensive")
        } else if (baiting && prevRemain == 1 && !poisonActive) {
            if (!mapContainsKey(MagicStrategy._recentAntidoteTurn, enemyId)) {
                MagicStrategy._recentAntidoteTurn[enemyId] = curTurn
            } else if (curTurn - MagicStrategy._recentAntidoteTurn[enemyId] >= 2) {
                MagicStrategy._baitMode[enemyId] = false
                baiting = false
                debug("[ANTIDOTE][ESCALATE] Repeated natural expiry loop -> abandon bait mode")
            }
        }

        // Cell planning
        // Try approach-HNS first for better staging before poison planning
        var hnsStage = fieldMap.findApproachHideAndSeekCell(target)
        var poisonPlan = this.selectBestPoisonCell(target)
        if (poisonPlan != null) {
            targetHitCell = poisonPlan['cell']
            debug("[DoT-KITE] Plan cell=" + targetHitCell._id + " chips=" + count(poisonPlan['chips']) + " weapons=" + count(poisonPlan['weapons']))
        } else if (targetHitCell == -1 || targetHitCell == null) {
            targetHitCell = fieldMap.getBestWeightedDamageCell(1.8, 1)
            if (targetHitCell != -1) debug("[DoT-KITE] Fallback weighted cell=" + targetHitCell._id)
        }
        // If approach-HNS gave us a safer cell that still allows attacking and poison plan didn't pick a different one, consider swapping
        if (hnsStage != null && targetHitCell != -1) {
            var consider = false
            if (hnsStage['canAttack'] && poisonPlan == null) consider = true
            if (mapContainsKey(fieldMap.damageMap, hnsStage['cell']) && mapContainsKey(fieldMap.damageMap, targetHitCell._id)) {
                var hObj = fieldMap.damageMap[hnsStage['cell']]
                if (hObj._totalDamage == targetHitCell._totalDamage) {
                    var dCur = getPathLength(player._cellPos, targetHitCell._id)
                    var dH = getPathLength(player._cellPos, hObj._id)
                    if (dH != null && dCur != null && dH < dCur) consider = true
                }
            }
            if (consider) {
                if (mapContainsKey(fieldMap.damageMap, hnsStage['cell'])) {
                    targetHitCell = fieldMap.damageMap[hnsStage['cell']]
                    debug("[DoT-KITE][HNS-APPROACH] Switching to closer/equal-damage approach cell " + hnsStage['cell'])
                }
            }
        }
        if (targetHitCell != -1 && targetHitCell._id != player._cellPos) {
            push(this._actions, new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, targetHitCell._id, target))
        } else if (targetHitCell != -1) {
            debug("[DoT-KITE] Already positioned on chosen cell (" + targetHitCell._id + ") no movement needed")
        }

        var context = ['willAttack': false, 'plannedWeapon': getWeapon(), 'targetHitCell': targetHitCell]

        if (baiting) {
            this.createBaitAntidoteOffensiveDoT(target, poisonPlan, context)
        } else {
            this.createFullOffensiveDoT(target, poisonPlan, context, poisonActive, poisonRemaining)
        }

        // Opportunistic poke if still no attack
        if (!context['willAttack']) {
            var activeW = getWeapon()
            if (activeW != null && mapContainsKey(arsenal.playerEquippedWeapons, activeW)) {
                var wObj = arsenal.playerEquippedWeapons[activeW]
                if (player._currTp >= wObj._cost && this.inRangeAndLOS(targetHitCell._id, target._cellPos, wObj._minRange, wObj._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    context['willAttack'] = true
                }
            }
        }
        if (!context['willAttack']) {
            var activeW2 = getWeapon()
            for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
                var wObj2 = arsenal.playerEquippedWeapons[wid]
                if (activeW2 == wObj2._id) continue
                if (player._currTp < wObj2._cost + 1) continue
                if (!this.inRangeAndLOS(targetHitCell._id, target._cellPos, wObj2._minRange, wObj2._maxRange)) continue
                push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, wObj2._id, -1, target._cellPos, target))
                player._currTp -= 1
                if (player._currTp >= wObj2._cost) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj2._id, -1, target._cellPos, target))
                    player._currTp -= wObj2._cost
                }
                context['willAttack'] = true
                break
            }
        }

        // Movement after attacks: prefer Hide & Seek cell over generic flee
        var originalMP = player._currMp // still full MP (movement not yet executed)
        var pathToAttack = 0
        if (targetHitCell != -1 && targetHitCell != null) pathToAttack = getPathLength(player._cellPos, targetHitCell._id)
        if (pathToAttack == null) pathToAttack = 0
        var hnsInfoKite = fieldMap.findHideAndSeekCell()
        var addedHide = false
        if (hnsInfoKite != null) {
            var hideCellIdK = hnsInfoKite['cell']
            // Compute extra leg MP cost (if we already planned an offensive move)
            var extraLeg = 0
            if (targetHitCell != -1 && targetHitCell != null && hideCellIdK != targetHitCell._id) {
                extraLeg = getPathLength(targetHitCell._id, hideCellIdK)
                if (extraLeg == null) extraLeg = 9999
            }
            if (hideCellIdK == player._cellPos) {
                // No movement needed; if we already scheduled an offensive move, skip hide
            } else {
                var totalNeeded = pathToAttack + extraLeg
                if (totalNeeded <= originalMP) {
                    // Remove previous offensive move if it existed and we are replacing with two legs? Simplicity: keep first leg then add hide leg.
                    if (hideCellIdK != (targetHitCell != -1 && targetHitCell != null ? targetHitCell._id : player._cellPos)) {
                        push(this._actions, new Action(Action.MOVEMENT_HNS, -1, -1, hideCellIdK, target))
                        addedHide = true
                        debug("[DoT-KITE][HNS] Added hide move to cell " + hideCellIdK + " danger=" + hnsInfoKite['danger'])
                    }
                } else {
                    debug("[DoT-KITE][HNS] Not enough MP for hide cell after attack pathNeeded=" + totalNeeded + " MP=" + originalMP)
                }
            }
        }
        if (!addedHide) {
            push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
            debug("[DoT-KITE] Fallback flee movement scheduled")
        }
        debug("[DoT-KITE] Actions scheduled=" + count(this._actions) + " TP_end=" + player._currTp)

        // Persist poison tracking
        if (poisonActive) MagicStrategy._prevPoisonRemaining[enemyId] = poisonRemaining else MagicStrategy._prevPoisonRemaining[enemyId] = -1

        this.executeScenario()
    }

    // Scenario: Bait antidote (restrict to low-impact chips, keep strong ones in reserve, Double Gun + Venom follow-up)
    createBaitAntidoteOffensiveDoT(target, poisonPlan, context) {
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']
        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, wObj._id, -1, target._cellPos, target))
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }
                var usesW = wRec['uses']
                while (usesW > 0 && player._currTp >= wObj._cost) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    usesW -= 1
                    willAttack = true
                }
            }
            // Only bait-allowed chips (e.g., VENOM)
            var chipsToUse = poisonPlan['chips']
            for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                var pc = chipsToUse[cidx]
                if (!MagicStrategy.isBaitAllowedChip(pc._id)) continue
                if (player._currTp < pc._cost) break
                if (!this.inRangeAndLOS(targetHitCell._id, target._cellPos, pc._minRange, pc._maxRange)) continue
                push(this._actions, new Action(Action.ACTION_DIRECT, -1, pc._id, target._cellPos, target))
                player._currTp -= pc._cost
                willAttack = true
            }
        }
        // Follow-up Double Gun then VENOM
        if (player._currTp > 0) {
            var usedFlame = false
            for (var a in this._actions) { if (a.type == Action.ACTION_DIRECT && a.weaponId == WEAPON_FLAME_THROWER) { usedFlame = true; break } }
            if (usedFlame && mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_DOUBLE_GUN)) {
                var dg = arsenal.playerEquippedWeapons[WEAPON_DOUBLE_GUN]
                if (dg != null && this.inRangeAndLOS(targetHitCell._id, target._cellPos, dg._minRange, dg._maxRange)) {
                    var needSwapDG = (getWeapon() != dg._id)
                    if (player._currTp >= dg._cost + (needSwapDG ? 1 : 0)) {
                        if (needSwapDG) { push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, dg._id, -1, target._cellPos, target)); player._currTp -= 1 }
                        var dgUses = min(dg._maxUse, floor(player._currTp / dg._cost))
                        while (dgUses > 0 && player._currTp >= dg._cost) {
                            push(this._actions, new Action(Action.ACTION_DIRECT, dg._id, -1, target._cellPos, target))
                            player._currTp -= dg._cost
                            dgUses -= 1
                            willAttack = true
                        }
                    }
                }
            }
            if (player._currTp > 0 && mapContainsKey(arsenal.playerEquippedChips, CHIP_VENOM)) {
                var vChip = arsenal.playerEquippedChips[CHIP_VENOM]
                if (vChip != null && getCooldown(CHIP_VENOM, player._id) == 0 && player._currTp >= vChip._cost && this.inRangeAndLOS(targetHitCell._id, target._cellPos, vChip._minRange, vChip._maxRange)) {
                    var alreadyVen = false
                    for (var aa in this._actions) { if (aa.type == Action.ACTION_DIRECT && aa.chip == CHIP_VENOM) { alreadyVen = true; break } }
                    if (!alreadyVen) {
                        push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_VENOM, target._cellPos, target))
                        player._currTp -= vChip._cost
                        willAttack = true
                    }
                }
            }
        }
        context['plannedWeapon'] = plannedWeapon
        context['willAttack'] = willAttack
    }

    // Scenario: Full offensive after antidote burned (use all strong poison chips and stacking)
    createFullOffensiveDoT(target, poisonPlan, context, poisonActive, poisonRemaining) {
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']
        var usedFlame = false

        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, wObj._id, -1, target._cellPos, target))
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }
                var usesW = wRec['uses']
                while (usesW > 0 && player._currTp >= wObj._cost) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    usesW -= 1
                    willAttack = true
                    if (wObj._id == WEAPON_FLAME_THROWER) usedFlame = true
                }
            }
            // Use all planned poison chips
            var chipsToUse = poisonPlan['chips']
            for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                var pc = chipsToUse[cidx]
                if (player._currTp < pc._cost) break
                if (!this.inRangeAndLOS(targetHitCell._id, target._cellPos, pc._minRange, pc._maxRange)) continue
                push(this._actions, new Action(Action.ACTION_DIRECT, -1, pc._id, target._cellPos, target))
                player._currTp -= pc._cost
                willAttack = true
            }
        }
        // Fallback strongest chips order (TOXIN, PLAGUE, others)
        if (player._currTp > 0) {
            var priorityChips = []
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN)) push(priorityChips, arsenal.playerEquippedChips[CHIP_TOXIN])
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_PLAGUE)) push(priorityChips, arsenal.playerEquippedChips[CHIP_PLAGUE])
            var allPois = arsenal.getPoisonChipsSorted(player._strength, player._magic, player._wisdom)
            for (var addIdx = 0; addIdx < count(allPois); addIdx++) {
                var pcAdd = allPois[addIdx]
                if (pcAdd._id == CHIP_TOXIN || pcAdd._id == CHIP_PLAGUE) continue
                push(priorityChips, pcAdd)
            }
            for (var pIdx = 0; pIdx < count(priorityChips); pIdx++) {
                var chipP = priorityChips[pIdx]
                if (player._currTp < chipP._cost) continue
                if (getCooldown(chipP._id, player._id) > 0) continue
                if (!this.inRangeAndLOS(targetHitCell._id, target._cellPos, chipP._minRange, chipP._maxRange)) continue
                push(this._actions, new Action(Action.ACTION_DIRECT, -1, chipP._id, target._cellPos, target))
                player._currTp -= chipP._cost
                willAttack = true
            }
        }
        context['willAttack'] = willAttack
        context['plannedWeapon'] = plannedWeapon
    }

    // Plan best reachable cell to maximize stacked poison DoT value this turn.
    // Returns map: ['cell': Cell, 'chips': poisonChipsArray]
    selectBestPoisonCell(target) {
        // We'll derive per-cell viable poison chips and dot weapons straight from field map lists.
        // Verbosity toggle: set true for deep per-cell diagnostics.
        var verbosePlan = false
        var bestCell = -1
    var bestAdjustedScore = -1
        var bestChips = []
        var bestWeapons = []
        var bestRemainingTP = -1
    var bestPathLen = 9999
        var playerPos = player._cellPos
        var mpAvail = player._currMp
        var tpAvail = player._currTp
        var penaltyNoWeaponFactor = 0.15 // fallback penalty when a cell has only chips while weapons are globally reachable
        // Pre-scan using per-cell lists to know if any dot weapon reachable.
        var weaponPreferred = false
        var requireWeaponIfAvailable = true
        for (var preC in fieldMap.damageMap) {
            var pLen = getPathLength(playerPos, preC._id)
            if (pLen == null || pLen > mpAvail) continue
            if (preC._weaponsList == null) continue
            for (var pw = 0; pw < count(preC._weaponsList); pw++) {
                var wPre = preC._weaponsList[pw]
                if (wPre == null) continue
                // Consider only weapons with any DoT component (poison stacking)
                var bdPre = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, wPre._id)
                if (bdPre['dot'] <= 0) continue
                var swapNeedPre = (getWeapon() != wPre._id)
                var swapCostPre = swapNeedPre ? 1 : 0
                if (tpAvail <= swapCostPre) continue
                var maxUsePre = min(wPre._maxUse, floor((tpAvail - swapCostPre) / wPre._cost))
                if (maxUsePre <= 0) continue
                weaponPreferred = true
                break
            }
            if (weaponPreferred) break
        }
    debug("[DoT-KITE][PLAN] weaponPreferred(per-cell)=" + weaponPreferred)
        // Detect if standing cell already offers high-dot weapon so we bias towards staying put
        var stayHighDot = false
        if (mapContainsKey(fieldMap.damageMap, playerPos)) {
            var stayCell = fieldMap.damageMap[playerPos]
            if (stayCell._weaponsList != null) {
                for (var sw = 0; sw < count(stayCell._weaponsList); sw++) {
                    var swW = stayCell._weaponsList[sw]
                    if (swW == null) continue
                    var bdStay = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, swW._id)
                    if (bdStay['dot'] > 0) { stayHighDot = true; break }
                }
            }
        }
        // Iterate over all damageMap cells as candidate movement endpoints
        for (var c in fieldMap.damageMap) {
            var pathLen = getPathLength(playerPos, c._id)
            if (pathLen == null || pathLen > mpAvail) continue
            var score = 0
            var chipPlan = []
            var weaponPlan = []
            var remainingTP = tpAvail
            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] id=" + c._id + " pathLen=" + pathLen + " baseTP=" + remainingTP)
            // Pre-scan poison chips on this cell to identify top (highest dot) chip for TP reservation (e.g., toxin)
            var topPoisonChip = null
            var topPoisonDot = -1
            var topPoisonTotal = 0
            var topPoisonCost = 0
            if (c._chipsList != null) {
                for (var preLC = 0; preLC < count(c._chipsList); preLC++) {
                    var preChip = c._chipsList[preLC]
                    if (preChip == null) continue
                    var bdPreChip = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, preChip._id)
                    if (bdPreChip['dot'] <= 0) continue
                    if (bdPreChip['dot'] > topPoisonDot) {
                        topPoisonDot = bdPreChip['dot']
                        topPoisonChip = preChip
                        topPoisonTotal = bdPreChip['total']
                        topPoisonCost = preChip._cost
                    }
                }
            }
            // WEAPON-FIRST using per-cell list (already geometry-validated)
            if (c._weaponsList != null) {
                // Build filtered list of dot-capable weapons sorted by per-use total damage desc
                var localDotWeapons = []
                for (var lw = 0; lw < count(c._weaponsList); lw++) {
                    var wLoc = c._weaponsList[lw]
                    if (wLoc == null) continue
                    var bdLoc = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, wLoc._id)
                    if (bdLoc['dot'] <= 0) continue
                    // attach computed total for sorting
                    push(localDotWeapons, ['weapon': wLoc, 'total': bdLoc['total'], 'bd': bdLoc])
                }
                // simple selection sort (few weapons typically)
                for (var ii = 0; ii < count(localDotWeapons); ii++) {
                    var bestIdx = ii
                    for (var jj = ii + 1; jj < count(localDotWeapons); jj++) {
                        if (localDotWeapons[jj]['total'] > localDotWeapons[bestIdx]['total']) bestIdx = jj
                    }
                    if (bestIdx != ii) {
                        var tmp = localDotWeapons[ii]
                        localDotWeapons[ii] = localDotWeapons[bestIdx]
                        localDotWeapons[bestIdx] = tmp
                    }
                }
                for (var lw2 = 0; lw2 < count(localDotWeapons); lw2++) {
                    if (remainingTP <= 0) break
                    var recW = localDotWeapons[lw2]
                    var wDOT = recW['weapon']
                    var bdW2 = recW['bd']
                    // Range/LOS sanity (should already be valid but keep lightweight check)
                    if (!this.inRangeAndLOS(c._id, target._cellPos, wDOT._minRange, wDOT._maxRange)) { if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipWeaponRangeRecheck=" + getWeaponName(wDOT._id)); continue }
                    var swapNeededW = (getWeapon() != wDOT._id)
                    var swapCostW = swapNeededW ? 1 : 0
                    if (remainingTP <= swapCostW) continue
                    var usableTP2 = remainingTP - swapCostW
                    var maxWeaponUses2 = min(wDOT._maxUse, floor(usableTP2 / wDOT._cost))
                    if (maxWeaponUses2 <= 0) continue
                    // Reserve TP for top poison chip (e.g., toxin) if available and not yet reserved (no chip scheduled yet)
                    if (topPoisonChip != null && topPoisonCost > 0) {
                        while (maxWeaponUses2 > 0 && (remainingTP - swapCostW - (maxWeaponUses2 * wDOT._cost)) < topPoisonCost) {
                            maxWeaponUses2 -= 1
                        }
                        if (maxWeaponUses2 == 0) {
                            // Skip this weapon entirely to preserve TP for toxin
                            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] reserveForChip skipWeapon=" + getWeaponName(wDOT._id) + " chip=" + getChipName(topPoisonChip._id) + " cost=" + topPoisonCost)
                            continue
                        }
                        if (maxWeaponUses2 < recW['weapon']._maxUse) {
                            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] reserveForChip reduceUses weapon=" + getWeaponName(wDOT._id) + " newUses=" + maxWeaponUses2 + " chipCost=" + topPoisonCost + " chip=" + getChipName(topPoisonChip._id))
                        }
                    }
                    var weaponContribution2 = maxWeaponUses2 * bdW2['total']
                    score += weaponContribution2
                    push(weaponPlan, ['weapon': wDOT, 'swap': swapNeededW, 'uses': maxWeaponUses2])
                    remainingTP -= swapCostW + maxWeaponUses2 * wDOT._cost
                    if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] +Weapon(per-cell) " + getWeaponName(wDOT._id) + " uses=" + maxWeaponUses2 + (swapNeededW ? " swapCost=1" : "") + " add=" + floor(weaponContribution2) + " TP_left=" + remainingTP)
                }
            }
            // If we require a weapon cell and none was scheduled, skip entirely (hard preference for flamethrower cells)
            if (weaponPreferred && requireWeaponIfAvailable && count(weaponPlan) == 0) {
                if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipNoWeapon (weaponPreferred=true) id=" + c._id)
                continue
            }
            // CHIP FOLLOW-UP: spend remaining TP on poison chips
            if (c._chipsList != null) {
                // Filter poison chips via damage breakdown (dot > 0) and sort by total damage per use desc
                var localPoisonChips = []
                for (var lc = 0; lc < count(c._chipsList); lc++) {
                    var chipObj = c._chipsList[lc]
                    if (chipObj == null) continue
                    var bdChip = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, chipObj._id)
                    if (bdChip['dot'] <= 0) continue
                    push(localPoisonChips, ['chip': chipObj, 'total': bdChip['total'], 'bd': bdChip])
                }
                for (var ci = 0; ci < count(localPoisonChips); ci++) {
                    var bestIdxC = ci
                    for (var cj = ci + 1; cj < count(localPoisonChips); cj++) {
                        if (localPoisonChips[cj]['total'] > localPoisonChips[bestIdxC]['total']) bestIdxC = cj
                    }
                    if (bestIdxC != ci) {
                        var tmpC = localPoisonChips[ci]
                        localPoisonChips[ci] = localPoisonChips[bestIdxC]
                        localPoisonChips[bestIdxC] = tmpC
                    }
                }
                // Ensure topPoisonChip (highest dot) is first if present (to guarantee scheduling)
                if (topPoisonChip != null && count(localPoisonChips) > 1) {
                    var topIndex = -1
                    for (var tpi = 0; tpi < count(localPoisonChips); tpi++) {
                        if (localPoisonChips[tpi]['chip']._id == topPoisonChip._id) { topIndex = tpi; break }
                    }
                    if (topIndex > 0) {
                        var hold = localPoisonChips[topIndex]
                        remove(localPoisonChips, topIndex)
                        insert(localPoisonChips, 0, hold)
                    }
                }
                for (var lpc = 0; lpc < count(localPoisonChips); lpc++) {
                    if (remainingTP <= 0) break
                    var recC = localPoisonChips[lpc]
                    var pc = recC['chip']
                    if (getCooldown(pc._id, player._id) > 0) { if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipCD=" + getChipName(pc._id)); continue }
                    if (remainingTP < pc._cost) { if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipTP=" + getChipName(pc._id)); continue }
                    // Range/LOS sanity
                    var distChip = getCellDistance(c._id, target._cellPos)
                    if (distChip < pc._minRange || distChip > pc._maxRange) { if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipRange=" + getChipName(pc._id)); continue }
                    if (!lineOfSight(c._id, target._cellPos)) { if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipLOS=" + getChipName(pc._id)); continue }
                    var bdC2 = recC['bd']
                    var maxUsesChip2 = min(pc._maxUse, floor(remainingTP / pc._cost))
                    if (maxUsesChip2 <= 0) { if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipZeroUses=" + getChipName(pc._id)); continue }
                    score += maxUsesChip2 * bdC2['total']
                    push(chipPlan, pc)
                    remainingTP -= maxUsesChip2 * pc._cost
                    if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] +Chip(per-cell) " + getChipName(pc._id) + " uses=" + maxUsesChip2 + " add=" + floor(maxUsesChip2 * bdC2['total']) + " TP_left=" + remainingTP)
                }
            }
            // If weapons were globally preferred but this cell ended with only chips (should not happen if skip above worked) apply penalty safeguard.
            if (weaponPreferred && count(weaponPlan) == 0 && count(chipPlan) > 0) {
                var penaltySafe = score * penaltyNoWeaponFactor
                score -= penaltySafe
                if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] penaltyNoWeaponFallback cell=" + c._id + " penalty=" + floor(penaltySafe))
            }
            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] finalScore=" + floor(score) + " chips=" + count(chipPlan) + " weapons=" + count(weaponPlan) + " TP_rem=" + remainingTP)
            // Distance penalty: discourage moving if current cell already viable (pathLen * small factor relative to damage scale)
            // Dynamic distance penalty: heavier if staying cell already offers a high-dot weapon
            var distFactor = stayHighDot ? 7 : 5
            var distancePenalty = pathLen * distFactor
            var adjustedScore = score - distancePenalty
            if ((count(chipPlan) > 0 || (count(chipPlan) == 0 && count(weaponPlan) > 0))) {
                if (adjustedScore > bestAdjustedScore || (adjustedScore == bestAdjustedScore && pathLen < bestPathLen)) {
                    bestAdjustedScore = adjustedScore
                    bestCell = c
                    bestChips = chipPlan
                    bestWeapons = weaponPlan
                    bestRemainingTP = remainingTP
                    bestPathLen = pathLen
                    debug("[DoT-KITE][PLAN][BEST] cell=" + c._id + " rawScore=" + floor(score) + " adjScore=" + floor(adjustedScore) + " pathLen=" + pathLen + " penalty=" + distancePenalty + " stayHighDot=" + stayHighDot)
                }
            }
        }
        if (bestCell == -1) return null
        if (bestCell != null) {
            debug("[DoT-KITE][PLAN][CHOICE] cell=" + bestCell._id + " adjScore=" + floor(bestAdjustedScore) + " chips=" + count(bestChips) + " weapons=" + count(bestWeapons) + " pathLen=" + bestPathLen)
            // Summarize all available weapons & chips (poison) on chosen cell with per-use damage and planned uses
            var weaponSummary = ""
            if (bestCell._weaponsList != null) {
                for (var ws = 0; ws < count(bestCell._weaponsList); ws++) {
                    var wSum = bestCell._weaponsList[ws]
                    var bdWsum = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, wSum._id)
                    var usesPlan = 0
                    for (var pwL = 0; pwL < count(bestWeapons); pwL++) {
                        if (bestWeapons[pwL]['weapon']._id == wSum._id) { usesPlan = bestWeapons[pwL]['uses']; break }
                    }
                    weaponSummary += (ws > 0 ? ", " : "") + getWeaponName(wSum._id) + ":d=" + floor(bdWsum['direct']) + "/p=" + floor(bdWsum['dot']) + "/t=" + floor(bdWsum['total']) + (usesPlan > 0 ? "x" + usesPlan : "")
                }
            }
            var chipSummary = ""
            if (bestCell._chipsList != null) {
                for (var cs = 0; cs < count(bestCell._chipsList); cs++) {
                    var cSum = bestCell._chipsList[cs]
                    var bdCsum = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, cSum._id)
                    if (bdCsum['dot'] <= 0) {
                        // show skipped non-poison chips for transparency
                        chipSummary += (chipSummary != "" ? ", " : "") + getChipName(cSum._id) + "(no-dot d=" + floor(bdCsum['direct']) + ")"
                        continue
                    }
                    chipSummary += (chipSummary != "" ? ", " : "") + getChipName(cSum._id) + ":d=" + floor(bdCsum['direct']) + "/p=" + floor(bdCsum['dot']) + "/t=" + floor(bdCsum['total'])
                }
            }
            debug("[DoT-KITE][PLAN][CHOICE-DETAIL] cell=" + bestCell._id + " TP_rem_est=" + bestRemainingTP + " weapons={" + weaponSummary + "} chips={" + chipSummary + "}")
        } else {
            debug("[DoT-KITE][PLAN][CHOICE] bestCell null (no valid poison plan)")
        }
        return ['cell': bestCell, 'chips': bestChips, 'weapons': bestWeapons]
    }
}

