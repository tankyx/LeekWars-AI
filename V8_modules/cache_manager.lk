
include('operation_tracker.lk')

global __reachableCellsCache = [:]      
global __damageCache = [:]               
global __chipCostCache = [:]             
global __weaponCostCache = [:]           
global __pathLengthCache = [:]           

function hashTwoCells(cell1, cell2) {
    return cell1 * 1024 + cell2
}

function clearCaches() {
    __reachableCellsCache = [:]
    __damageCache = [:]
    __chipCostCache = [:]
    __weaponCostCache = [:]
    __pathLengthCache = [:]
}

function buildReachableCellsCache(fromCell, mp) {
    if (mp <= 0) return [:]

    var reachable = [:]
    var queue = []
    var visited = [:]
    var queueIndex = 0

    push(queue, ['cell': fromCell, 'cost': 0])
    mapPut(visited, fromCell, true)
    mapPut(reachable, fromCell, 0)

    while (queueIndex < count(queue)) {
        if (getOperations() > 5500000) {
            break
        }

        var current = queue[queueIndex]
        queueIndex++

        var currentCell = current['cell']
        var currentCost = current['cost']

        var neighbors = [
            currentCell + 1,
            currentCell - 1,
            currentCell + 18,
            currentCell - 18,
            currentCell + 17,
            currentCell - 17,
            currentCell + 19,
            currentCell - 19
        ]

        for (var neighbor in neighbors) {
            if (neighbor < 0 || neighbor >= 613) continue
            if (mapContainsKey(visited, neighbor)) continue

            var pathLen = getPathLength(currentCell, neighbor)
            if (pathLen == null || pathLen < 0) continue

            var newCost = currentCost + pathLen
            if (newCost > mp) continue

            mapPut(visited, neighbor, true)
            mapPut(reachable, neighbor, newCost)
            push(queue, ['cell': neighbor, 'cost': newCost])
        }
    }

    var cacheKey = fromCell * 1000 + mp
    __reachableCellsCache[cacheKey] = reachable
    return reachable
}

function isCachedReachableCell(fromCell, toCell, mp) {
    var cacheKey = fromCell * 1000 + mp

    if (!mapContainsKey(__reachableCellsCache, cacheKey)) {

        buildReachableCellsCache(fromCell, mp)
    }

    var reachable = __reachableCellsCache[cacheKey]
    return mapContainsKey(reachable, toCell)
}

function getCachedPathLength(fromCell, toCell) {
    var hash = hashTwoCells(fromCell, toCell)

    if (mapContainsKey(__pathLengthCache, hash)) {
        return __pathLengthCache[hash]
    }

    var pathLen = getPathLength(fromCell, toCell)
    __pathLengthCache[hash] = pathLen
    return pathLen
}

function buildDamageCache(arsenal, player, target) {
    var str = player._strength
    var mag = player._magic
    var wis = player._wisdom
    var sci = player._science

    for (var weaponId in mapKeys(arsenal.playerEquippedWeapons)) {
        var bd = arsenal.getDamageBreakdown(str, mag, wis, sci, weaponId)
        var netDmg = arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, weaponId, target)
        __damageCache[weaponId] = ['breakdown': bd, 'net': netDmg]
    }

    for (var chipId in mapKeys(arsenal.playerEquippedChips)) {
        var bd = arsenal.getDamageBreakdown(str, mag, wis, sci, chipId)
        var netDmg = arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, chipId, target)
        __damageCache[chipId] = ['breakdown': bd, 'net': netDmg]
    }
}

function getCachedDamageBreakdown(itemId) {
    if (mapContainsKey(__damageCache, itemId)) {
        return __damageCache[itemId]['breakdown']
    }
    return null
}

function getCachedNetDamage(itemId) {
    if (mapContainsKey(__damageCache, itemId)) {
        return __damageCache[itemId]['net']
    }
    return null
}

function buildCostCache(arsenal) {
    
    for (var chipId in mapKeys(arsenal.playerEquippedChips)) {
        __chipCostCache[chipId] = getChipCost(chipId)
    }

    for (var weaponId in mapKeys(arsenal.playerEquippedWeapons)) {
        var weapon = arsenal.playerEquippedWeapons[weaponId]
        __weaponCostCache[weaponId] = weapon._cost  
    }
}

function getCachedChipCost(chipId) {
    if (mapContainsKey(__chipCostCache, chipId)) {
        return __chipCostCache[chipId]
    }
    
    var cost = getChipCost(chipId)
    __chipCostCache[chipId] = cost
    return cost
}

function getCachedWeaponCost(weaponId, arsenal) {
    if (mapContainsKey(__weaponCostCache, weaponId)) {
        return __weaponCostCache[weaponId]
    }
    
    var weapon = null
    if (mapContainsKey(arsenal.playerEquippedWeapons, weaponId)) {
        weapon = arsenal.playerEquippedWeapons[weaponId]
    } else if (mapContainsKey(arsenal.weaponsList, weaponId)) {
        weapon = arsenal.weaponsList[weaponId]
    }
    if (weapon != null) {
        __weaponCostCache[weaponId] = weapon._cost
        return weapon._cost
    }
    return null
}

function initializeCaches(player, target, arsenal) {
    startOp()
    clearCaches()
    stopOp("Clear caches")

    startOp()
    buildDamageCache(arsenal, player, target)
    stopOp("Build damage cache")

    startOp()
    buildCostCache(arsenal)
    stopOp("Build cost cache")
}
