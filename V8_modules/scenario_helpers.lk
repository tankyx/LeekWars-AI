// REMOVED: include('tactical_awareness.lk')
// Phase 2 features not needed - TP/MP reset each turn

include('cooldown_tracker.lk')

class ScenarioParams {
    buffStrategy = 0
    healThreshold = -1
    movementFraction = 1.0
    attackFraction = 1.0
    repositioning = "hide"

    constructor(buffStrat, healThr, moveFrac, attackFrac, reposition) {
        this.buffStrategy = buffStrat
        this.healThreshold = healThr
        this.movementFraction = moveFrac
        this.attackFraction = attackFrac
        this.repositioning = reposition
    }
}

class ScenarioHelpers {
    _arsenal = null
    _player = null
    _target = null
    _fieldMap = null
    _strategy = null

    _moveCache = [:]
    _hideCache = null
    _kiteCache = null

    static USE_STATE_BASED_SCENARIOS = true

    constructor(arsenal, player, target, fieldMap, strategy) {
        this._arsenal = arsenal
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
        this._strategy = strategy
        this._moveCache = [:]
    }

    // =========================================================================
    // === State Detection ===
    // =========================================================================

    determineStrategicState() {
        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth

        var playerHPPercent = (playerHP * 100) / playerMaxHP
        var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

        var currentTurn = getTurn()
        var availableTP = getTP()

        // Battle Royale: Phase-based state override
        var isBattleRoyale = (getFightType() == FIGHT_TYPE_BATTLE_ROYALE)
        if (isBattleRoyale) {
            var aliveEnemies = getAliveEnemies()
            var enemyCount = count(aliveEnemies)

            if (enemyCount > 4) {
                // EARLY PHASE: Edge positioning, opportunistic only
                if (playerHPPercent < 30) return "FLEE"
                if (enemyHPPercent < 40) {
                    var dmgEstimate = this.estimateMaxDamageThisTurn(availableTP)
                    // KILL requires immediate damage only (poison lands next turn, can't OTKO)
                    if (dmgEstimate['immediate'] / enemyHP >= 0.85) return "KILL"
                }
                return "ATTRITION"  // Conservative play, no aggressive buffs
            }
            else if (enemyCount >= 3) {
                // MID PHASE: Tighten toward weaker targets
                if (playerHPPercent < 35) return "FLEE"
                if (enemyHPPercent < 50) {
                    var dmgEstimate = this.estimateMaxDamageThisTurn(availableTP)
                    if (dmgEstimate['immediate'] / enemyHP >= 0.75) return "KILL"
                }
                return "ATTRITION"
            }
            else {
                // LATE PHASE: Full aggressive 1v1
                // Fall through to standard 1v1 logic
            }
        }

        // Standard 1v1 logic
        // PRIORITY: Check if enemy is killable BEFORE fleeing
        var dmgEstimate = this.estimateMaxDamageThisTurn(availableTP)
        // Use IMMEDIATE damage for KILL check (poison DoT lands turn N+1, cannot OTKO)
        var estimatedDamage = dmgEstimate['immediate']

        // estimatedDamage already accounts for shields, TP budget, AND weapon range
        // Use 95% threshold to account for minor variance/rounding
        // Also require estimatedDamage > 0 (prevents false KILL when out of range)
        // KILL only triggers when already in weapon range (not just after theoretical movement)
        // Otherwise AGGRO/ATTRITION handle approach + attack properly
        var killSuppressed = false
        if (estimatedDamage > 0 && estimatedDamage >= enemyHP * 0.95) {
            var inWeaponRange = this.isInAnyWeaponRange()
            if (inWeaponRange) {
                return "KILL"
            }
            // Can kill after moving - force ATTRITION (has approach logic) instead of SUSTAIN/FLEE
            killSuppressed = true
            debugInfo("[STATE] KILL suppressed: need to approach first (estDmg=" + floor(estimatedDamage) + ")")
        }

        // If we can kill after approaching, skip FLEE/SUSTAIN - go straight to ATTRITION
        if (killSuppressed) {
            return "ATTRITION"
        }

        // Only flee if we can't kill the enemy
        if (playerHPPercent < 40) {
            return "FLEE"
        }

        if (playerHPPercent >= 40 && playerHPPercent <= 60 && enemyHPPercent > 40) {
            return "SUSTAIN"
        }

        var earlyGame = (currentTurn >= 1 && currentTurn <= 4)
        var buffsExpired = this.checkCriticalBuffsExpired()

        if ((earlyGame || buffsExpired) && playerHPPercent > 50 && enemyHPPercent > 60) {
            return "AGGRO"
        }

        return "ATTRITION"
    }

    checkCriticalBuffsExpired() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Bruiser/Reflect: triggers AGGRO when EITHER Steroid OR damage return expires
        if (str > 400 && agi > 400 &&
            (mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR) ||
             mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN) ||
             mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE))) {
            // Check Steroid
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
                var steroidActive = getCooldown(CHIP_STEROID, this._player._id) > 0
                if (!steroidActive) return true
            }
            // Check Warm Up
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_WARM_UP)) {
                var warmUpActive = getCooldown(CHIP_WARM_UP, this._player._id) > 0
                if (!warmUpActive) return true
            }
            // Check damage return
            var hasReturn = this._player.hasDamageReturn()
            if (!hasReturn) {
                var mirrorAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR) &&
                                     getCooldown(CHIP_MIRROR, this._player._id) == 0
                var thornAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN) &&
                                    getCooldown(CHIP_THORN, this._player._id) == 0
                var brambleAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE) &&
                                      getCooldown(CHIP_BRAMBLE, this._player._id) == 0
                if (mirrorAvailable || thornAvailable || brambleAvailable) return true
            }
        }

        else if (str > mag && str > agi) {
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
                var steroidActive = getCooldown(CHIP_STEROID, this._player._id) > 0
                if (!steroidActive) {
                    return true
                }
            } else if (mapContainsKey(arsenal.playerEquippedChips, CHIP_PRISM)) {
                // Fallback: PRISM for STR builds without STEROID
                var prismActive = getCooldown(CHIP_PRISM, this._player._id) > 0
                if (!prismActive) {
                    return true
                }
            }
        }

        else if (mag > str && mag > agi) {
            // Magic build: WIZARDRY is the primary offensive buff
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_WIZARDRY)) {
                var wizardryActive = getCooldown(CHIP_WIZARDRY, this._player._id) > 0
                if (!wizardryActive) {
                    return true
                }
            } else if (mapContainsKey(arsenal.playerEquippedChips, CHIP_PRISM)) {
                var prismActive = getCooldown(CHIP_PRISM, this._player._id) > 0
                if (!prismActive) {
                    return true
                }
            }
        }

        else if (agi > str && agi > mag) {
            var hasReturn = this._player.hasDamageReturn()
            if (!hasReturn) {

                var mirrorAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR) &&
                                     getCooldown(CHIP_MIRROR, this._player._id) == 0
                var thornAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN) &&
                                    getCooldown(CHIP_THORN, this._player._id) == 0
                var brambleAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE) &&
                                      getCooldown(CHIP_BRAMBLE, this._player._id) == 0

                if (mirrorAvailable || thornAvailable || brambleAvailable) {
                    return true
                }
            }
        }

        var hasShield = this._player.hasEffect(EFFECT_RELATIVE_SHIELD)
        if (!hasShield) {
            var fortressAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_FORTRESS) &&
                                   getCooldown(CHIP_FORTRESS, this._player._id) == 0
            var wallAvailable = mapContainsKey(arsenal.playerEquippedChips, CHIP_WALL) &&
                               getCooldown(CHIP_WALL, this._player._id) == 0

            if (fortressAvailable || wallAvailable) {
                return true
            }
        }

        return false
    }

    isInAnyWeaponRange() {
        var dist = getCellDistance(this._player._cellPos, this._target._cellPos)
        if (dist == null) return false

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]
            if (dist >= weapon._minRange && dist <= weapon._maxRange) {
                return true
            }
        }

        // Also check damage + poison chips (MAG builds rely on poison chips for damage)
        var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG,
                           CHIP_ARSENIC, CHIP_VENOM, CHIP_TOXIN, CHIP_PLAGUE, CHIP_COVID]
        for (var chipId in damageChips) {
            if (!mapContainsKey(this._arsenal.playerEquippedChips, chipId)) continue
            var chip = this._arsenal.playerEquippedChips[chipId]
            if (dist >= chip._minRange && dist <= chip._maxRange) {
                return true
            }
        }

        return false
    }

    checkOTKOOpportunity() {
        var enemyHP = this._target._currHealth
        var enemyMaxHP = this._target._maxHealth
        var hpPercent = (enemyHP * 100) / enemyMaxHP

        return (hpPercent < 35 || enemyHP < 500)
    }

    estimateMaxDamageThisTurn(availableTP) {
        var baseStr = this._player._strength
        var baseMag = this._player._magic
        var baseAgi = this._player._agility
        var baseWis = this._player._wisdom
        var baseSci = this._player._science

        // Calculate distance to enemy and available MP for range check
        var distToEnemy = getCellDistance(this._player._cellPos, this._target._cellPos)
        if (distToEnemy == null) distToEnemy = 99
        var availableMP = this._player._currMp

        // Helper: Calculate damage with given stats and TP budget, accounting for range
        // Returns ['immediate': X, 'total': Y] where immediate = direct + nova (this turn),
        // total = direct + nova + dot (dot lands on turn N+1, cannot OTKO)
        var calcDmg = function(str, mag, wis, sci, tpBudget, arsenal, target, playerId, dist, mp) {
            var immediateDamage = 0
            var totalDamage = 0

            for (var weaponId in mapKeys(arsenal.playerEquippedWeapons)) {
                var weapon = arsenal.playerEquippedWeapons[weaponId]

                // Range check: can we reach weapon range after moving?
                var closestDist = max(1, dist - mp)
                if (closestDist > weapon._maxRange) continue  // Can't reach even after full move

                var bd = arsenal.getDamageBreakdown(str, mag, wis, sci, weaponId)
                var directDmg = bd['direct']
                var novaDmg = bd['nova']
                var dotDmg = bd['dot']

                // Apply shield reduction to direct damage only
                var relShield = target._relShield / 100
                var absShield = target._absShield
                var netDirect = directDmg * (1 - relShield) - absShield
                if (netDirect < 0) netDirect = 0

                // Cap nova by HP deficit
                var hpDeficit = target._maxHealth - target._currHealth
                var cappedNova = novaDmg
                if (netDirect > 0 && novaDmg > 0) {
                    cappedNova = min(novaDmg, hpDeficit + netDirect)
                } else if (novaDmg > 0) {
                    cappedNova = min(novaDmg, hpDeficit)
                }

                var maxUses = min(weapon._maxUse, floor(tpBudget / weapon._cost))
                immediateDamage += (netDirect + cappedNova) * maxUses
                totalDamage += (netDirect + cappedNova + dotDmg) * maxUses
            }

            // Check damage chips (direct damage + poison chips + denial chips)
            var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG,
                               CHIP_ARSENIC, CHIP_VENOM, CHIP_TOXIN, CHIP_PLAGUE, CHIP_COVID,
                               CHIP_SOPORIFIC, CHIP_BALL_AND_CHAIN]
            var bestChipImmediate = 0
            var bestChipTotal = 0
            for (var chipId in damageChips) {
                if (!mapContainsKey(arsenal.playerEquippedChips, chipId)) continue
                if (getCooldown(chipId, playerId) > 0) continue

                // Range check for chips too
                var chip = arsenal.playerEquippedChips[chipId]
                var closestDist = max(1, dist - mp)
                if (closestDist > chip._maxRange) continue

                var cbd = arsenal.getDamageBreakdown(str, mag, wis, sci, chipId)
                var chipImmediate = cbd['direct'] + cbd['nova']
                var chipTotal = cbd['direct'] + cbd['nova'] + cbd['dot']
                if (chipTotal > bestChipTotal) {
                    bestChipImmediate = chipImmediate
                    bestChipTotal = chipTotal
                }
            }
            immediateDamage += bestChipImmediate
            totalDamage += bestChipTotal

            return ['immediate': immediateDamage, 'total': totalDamage]
        }

        // 1. Baseline: No buffs
        var bestResult = calcDmg(baseStr, baseMag, baseWis, baseSci, availableTP, this._arsenal, this._target, this._player._id, distToEnemy, availableMP)
        var maxImmediate = bestResult['immediate']
        var maxTotal = bestResult['total']

        // 2. Consider ADRENALINE (net +4 TP for 1 TP cost)
        var hasAdrenaline = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)
        var adrenalineReady = hasAdrenaline && getCooldown(CHIP_ADRENALINE, this._player._id) == 0
        var adrenalineBonus = adrenalineReady ? 4 : 0  // Net TP gain

        // 3. Strength buff: STEROID (+150 STR, 7 TP)
        var hasSteroid = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)
        var steroidReady = hasSteroid && getCooldown(CHIP_STEROID, this._player._id) == 0
        if (steroidReady && availableTP >= 7) {
            var buffedStr = baseStr + 150
            var tpAfterBuff = availableTP - 7 + adrenalineBonus
            if (tpAfterBuff > 0) {
                var r = calcDmg(buffedStr, baseMag, baseWis, baseSci, tpAfterBuff, this._arsenal, this._target, this._player._id, distToEnemy, availableMP)
                if (r['total'] > maxTotal) { maxImmediate = r['immediate']; maxTotal = r['total'] }
            }
        }

        // 4. Magic buff: WIZARDRY (+150 MAG, 6 TP)
        var hasWizardry = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WIZARDRY)
        var wizardryReady = hasWizardry && getCooldown(CHIP_WIZARDRY, this._player._id) == 0
        if (wizardryReady && availableTP >= 6) {
            var buffedMag = baseMag + 150
            var tpAfterBuff = availableTP - 6 + adrenalineBonus
            if (tpAfterBuff > 0) {
                var r = calcDmg(baseStr, buffedMag, baseWis, baseSci, tpAfterBuff, this._arsenal, this._target, this._player._id, distToEnemy, availableMP)
                if (r['total'] > maxTotal) { maxImmediate = r['immediate']; maxTotal = r['total'] }
            }
        }

        // 5. Science buff: KNOWLEDGE (+250 SCI, 5 TP)
        var hasKnowledge = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_KNOWLEDGE)
        var knowledgeReady = hasKnowledge && getCooldown(CHIP_KNOWLEDGE, this._player._id) == 0
        if (knowledgeReady && availableTP >= 5) {
            var buffedSci = baseSci + 250
            var tpAfterBuff = availableTP - 5 + adrenalineBonus
            if (tpAfterBuff > 0) {
                var r = calcDmg(baseStr, baseMag, baseWis, buffedSci, tpAfterBuff, this._arsenal, this._target, this._player._id, distToEnemy, availableMP)
                if (r['total'] > maxTotal) { maxImmediate = r['immediate']; maxTotal = r['total'] }
            }
        }

        // 6. Universal buff: PRISM (+60 all stats, 6 TP)
        var hasPrism = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_PRISM)
        var prismReady = hasPrism && getCooldown(CHIP_PRISM, this._player._id) == 0
        if (prismReady && availableTP >= 6) {
            var tpAfterBuff = availableTP - 6 + adrenalineBonus
            if (tpAfterBuff > 0) {
                var r = calcDmg(baseStr + 60, baseMag + 60, baseWis + 60, baseSci + 60, tpAfterBuff, this._arsenal, this._target, this._player._id, distToEnemy, availableMP)
                if (r['total'] > maxTotal) { maxImmediate = r['immediate']; maxTotal = r['total'] }
            }
        }

        return ['immediate': maxImmediate, 'total': maxTotal]
    }

    hasPoisonCapability() {
        // Check for poison weapons
        for (var wid in mapKeys(this._arsenal.playerEquippedWeapons)) {
            if (isPoisonWeapon(wid)) return true
        }

        // Check for poison chips
        for (var cid in mapKeys(this._arsenal.playerEquippedChips)) {
            if (isPoisonChip(cid)) return true
        }

        return false
    }

    // =========================================================================
    // === Buff Helpers ===
    // =========================================================================

    getOffensiveBuff() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Bruiser/Reflect build: alternate Steroid and Warm Up (both benefit the build)
        if (str > 400 && agi > 400 &&
            mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID) &&
            mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WARM_UP)) {
            // Prefer whichever is off cooldown; Steroid first (damage primary)
            if (getCooldown(CHIP_STEROID, this._player._id) == 0) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player)
            }
            if (getCooldown(CHIP_WARM_UP, this._player._id) == 0) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_WARM_UP, -1, this._player)
            }
        }

        if (str > mag && str > agi) {
            // Strength build: CHIP_STEROID (+160 STR)
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_STEROID, -1, this._player)
            }
        } else if (mag > str && mag > agi) {
            // Magic build: CHIP_WIZARDRY (+150-170 MAG)
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WIZARDRY) &&
                getCooldown(CHIP_WIZARDRY, this._player._id) == 0) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_WIZARDRY, -1, this._player)
            }
        } else if (agi > str && agi > mag) {
            // Agility build: CHIP_WARM_UP (+125 AGI)
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WARM_UP)) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_WARM_UP, -1, this._player)
            }
        }

        // Fallback: CHIP_PRISM (+60 all stats) — universal buff for any build without primary buff
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_PRISM) &&
            getCooldown(CHIP_PRISM, this._player._id) == 0) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_PRISM, -1, this._player)
        }

        return null
    }

    getDefensiveBuff() {
        var currentTP = getTP()
        var resistance = this._player._resistance

        // Proactive refresh: higher threshold for high-Resistance builds
        var refreshThreshold = (resistance >= 200) ? 2 : 1

        var hasShield = this._player.hasEffect(EFFECT_RELATIVE_SHIELD)
        var shieldRemaining = hasShield ? this._player.getEffectRemaining(EFFECT_RELATIVE_SHIELD) : 0

        if (hasShield && shieldRemaining > refreshThreshold) {
            return null  // Shield still active, no need to refresh
        }

        var hasFortress = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_FORTRESS)
        var hasWall = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WALL)

        var fortressCd = hasFortress ? getCooldown(CHIP_FORTRESS, this._player._id) : 999
        var wallCd = hasWall ? getCooldown(CHIP_WALL, this._player._id) : 999

        // Lower TP gates to allow buffing earlier
        if (hasFortress && fortressCd == 0 && currentTP >= 6) {  // Was 9, now 6
            return new Action(Action.ACTION_BUFF, -1, CHIP_FORTRESS, -1, this._player)
        }

        if (hasWall && wallCd == 0 && currentTP >= 3) {  // Was 6, now 3
            return new Action(Action.ACTION_BUFF, -1, CHIP_WALL, -1, this._player)
        }

        return null
    }

    getLeatherBootsBuff() {
        var baseMP = getTotalMP()

        if (baseMP >= 10) {
            return null
        }

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS)) {
            return null
        }

        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            var adrenalineCd = getCooldown(CHIP_ADRENALINE, this._player._id)
            if (adrenalineCd > 0) {

                return null
            }
        }

        var currentTP = getTP()

        var hasMPBuff = this._player.hasEffect(EFFECT_BUFF_MP)
        var buffRemaining = hasMPBuff ? this._player.getEffectRemaining(EFFECT_BUFF_MP) : 0

        if (hasMPBuff && buffRemaining > 1) {
            return null
        }

        var bootsCd = getCooldown(CHIP_LEATHER_BOOTS, this._player._id)
        if (bootsCd == 0 && currentTP >= 6) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_LEATHER_BOOTS, -1, this._player)
        }

        return null
    }

    getAdrenalineBuff() {
        var baseMP = getTotalMP()

        if (baseMP >= 10) {
            return null
        }

        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
            return null
        }

        var currentTP = getTP()

        var adrenalineCd = getCooldown(CHIP_ADRENALINE, this._player._id)
        if (adrenalineCd > 0) {
            return null
        }

        if (currentTP >= 3) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, -1, this._player)
        }

        return null
    }

    getDamageReturnBuff() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // Check if damage return chips are equipped
        var hasMirror = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_MIRROR)
        var hasThorn = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_THORN)
        var hasBramble = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_BRAMBLE)
        var hasAnyDamageReturn = hasMirror || hasThorn || hasBramble

        // New condition: High AGI (>=300) + damage return chips equipped = AGI build
        if (agi < 300 || !hasAnyDamageReturn) {
            return null  // Not an AGI build or no damage return chips
        }

        var currentTP = getTP()

        // Proactive refresh: higher threshold for high-Agility builds
        var refreshThreshold = (agi >= 200) ? 2 : 1

        var hasReturn = this._player.hasDamageReturn()
        var returnRemaining = hasReturn ? this._player.getDamageReturnRemaining() : 0

        if (hasReturn && returnRemaining > refreshThreshold) {
            return null  // Return buff still active, no need to refresh
        }

        var distToEnemy = getCellDistance(this._player._cellPos, this._target._cellPos)
        if (distToEnemy == null) distToEnemy = 99
        var inCloseCombat = distToEnemy <= 8

        var mirrorCd = hasMirror ? getCooldown(CHIP_MIRROR, this._player._id) : 999
        var thornCd = hasThorn ? getCooldown(CHIP_THORN, this._player._id) : 999
        var brambleCd = hasBramble ? getCooldown(CHIP_BRAMBLE, this._player._id) : 999

        var mirrorReady = mirrorCd == 0 && hasMirror && currentTP >= 5
        var thornReady = thornCd == 0 && hasThorn && currentTP >= 4
        var brambleReady = brambleCd == 0 && hasBramble && currentTP >= 4

        // BRAMBLE: Tactical-only usage (never for proactive maintenance)
        // Only use if: high incoming damage + close combat + spare TP
        var expectedThreat = this._fieldMap.getThreatAtCell(this._player._cellPos)
        if (brambleReady && inCloseCombat && currentTP >= 15 && expectedThreat > 300) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_BRAMBLE, -1, this._player)
        }

        // Lower TP gates for MIRROR/THORN to ensure uptime
        if (currentTP < 10) {
            if (thornReady) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_THORN, -1, this._player)  // Was currentTP check, now just readiness
            }
            if (mirrorReady) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)  // Was currentTP >= 10, now just readiness
            }
            return null
        }

        // Priority: MIRROR > THORN when both available
        if (mirrorReady && thornReady && currentTP >= 10) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)
        }

        if (mirrorReady) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_MIRROR, -1, this._player)
        }

        if (thornReady) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_THORN, -1, this._player)
        }

        return null
    }

    // =========================================================================
    // === Healing Helpers ===
    // =========================================================================

    getHealingAction(tpBudget, hpThreshold = 0.7) {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP
        var missingHP = maxHP - currentHP

        // Smart REGENERATION: Use when missing meaningful HP
        // REGENERATION is one-time (CD=-1), so don't be too conservative — better to heal early than die with it unused
        if (getCooldown(CHIP_REGENERATION, this._player._id) == 0 &&
            mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION) &&
            tpBudget >= 8) {

            var expectedHeal = this._arsenal.getExpectedHeal(CHIP_REGENERATION, this._player._wisdom)
            // Use if missing HP >= 40% of heal amount (generous threshold for one-time heal)
            // Cap expected heal comparison at maxHP to prevent absurd thresholds with high wisdom
            var healCap = min(expectedHeal, maxHP * 0.5)
            if (missingHP >= healCap * 0.40) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, -1, this._player)
            }
        }

        // Smart healing for HP < 80%
        if (hpRatio < 0.80 && tpBudget >= 5) {
            var healAction = this.getSmartHealingAction()
            if (healAction != null) {
                return healAction
            }
        }

        return null
    }

    getRemissionAction() {
        // Smart healing: prefer ENHANCED_LIGHTNINGER for high-wisdom builds
        return this.getSmartHealingAction()
    }

    getSmartHealingAction() {
        var wisdom = this._player._wisdom
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var missingHP = maxHP - currentHP

        // High wisdom (>= 400): ENHANCED_LIGHTNINGER (9 TP) gives lifesteal + 100 HP bonus
        // Low wisdom (< 400): REMISSION (5 TP) gives fixed ~400 HP
        if (wisdom >= 400 && mapContainsKey(this._arsenal.playerEquippedWeapons, WEAPON_ENHANCED_LIGHTNINGER)) {
            // Check if we have enough TP and weapon is usable
            if (getTP() >= 9) {
                // Check if target is in range
                var dist = getCellDistance(this._player._cellPos, this._target._cellPos)
                if (dist != null && dist >= 1 && dist <= 8) {
                    // ENHANCED_LIGHTNINGER: Estimate ~100-200 HP lifesteal
                    var estimatedLifesteal = 150  // Conservative estimate
                    if (missingHP >= estimatedLifesteal * 0.85) {
                        debugInfo("[SMART-HEAL] Using ENHANCED_LIGHTNINGER for wisdom lifesteal (WIS=" + wisdom + ")")
                        return new Action(Action.ACTION_DIRECT, WEAPON_ENHANCED_LIGHTNINGER, -1, this._target._cellPos, this._target)
                    }
                }
            }
        }

        // Fallback to REMISSION for low wisdom or when ENHANCED_LIGHTNINGER unavailable
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION) &&
            getCooldown(CHIP_REMISSION, this._player._id) == 0) {

            var expectedHeal = this._arsenal.getExpectedHeal(CHIP_REMISSION, wisdom)
            // Use if missing HP >= 85% of heal amount (allows 15% overheal tolerance)
            if (missingHP >= expectedHeal * 0.85) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, -1, this._player)
            }
        }

        return null
    }

    getRegenerationAction() {
        if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION) &&
            getCooldown(CHIP_REGENERATION, this._player._id) == 0) {

            // Smart REGENERATION: Only use when missing HP justifies it
            var currentHP = this._player._currHealth
            var maxHP = this._player._maxHealth
            var missingHP = maxHP - currentHP
            var expectedHeal = this._arsenal.getExpectedHeal(CHIP_REGENERATION, this._player._wisdom)

            // Use if missing HP >= 85% of heal amount (allows 15% overheal tolerance)
            if (missingHP >= expectedHeal * 0.85) {
                return new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, -1, this._player)
            }
        }
        return null
    }

    // =========================================================================
    // === Movement Helpers ===
    // =========================================================================

    getMoveToOptimalCell(mpBudget) {
        if (mpBudget <= 0) return null

        var otkoCells = this._fieldMap.getAllOTKOCells()
        if (count(otkoCells) > 0) {

            var bestOTKO = null
            var bestOTKOScore = -999999

            for (var otkoCell in otkoCells) {
                var pathLen = getGraphMPCost(otkoCell._id)
                if (pathLen < 999 && pathLen <= mpBudget) {

                    var score = otkoCell._otkoKillProbability * 10000 + otkoCell._otkoDamage - pathLen * 10
                    if (score > bestOTKOScore) {
                        bestOTKOScore = score
                        bestOTKO = otkoCell
                    }
                }
            }

            if (bestOTKO != null) {
                return new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, bestOTKO._id, this._target)
            }
        }

        var playerHP = this._player._currHealth
        var playerMaxHP = this._player._maxHealth
        var hpPercent = (playerHP * 100) / playerMaxHP

        var threatWeight = 0.3
        if (hpPercent < 40) {
            threatWeight = 0.8
        } else if (hpPercent < 70) {
            threatWeight = 0.5
        }

        var bestCell = this._fieldMap.findBestTacticalCell(mpBudget, threatWeight)
        if (bestCell == null || bestCell == -1) {

            bestCell = this._fieldMap.getBestWeaponOrChipCell()
            if (bestCell == null || bestCell == -1) {
                // Fallback: no attack cells available, just move toward enemy
                var approachCell = this.getApproachEnemyCell(mpBudget)
                if (approachCell != null && approachCell != -1) {
                    return new Action(Action.MOVEMENT_APPROACH, -1, -1, approachCell, this._target)
                }
                return null
            }

            var pathLength = getGraphMPCost(bestCell._id)
            if (pathLength >= 999 || pathLength > mpBudget) {
                if (this._strategy != null) {
                    bestCell = this._strategy.findBestReachableDamageCell(mpBudget)
                } else {
                    bestCell = null
                }
                if (bestCell == null || bestCell == -1) {
                    // Fallback: no reachable damage cells, just move toward enemy
                    var approachCell = this.getApproachEnemyCell(mpBudget)
                    if (approachCell != null && approachCell != -1) {
                        return new Action(Action.MOVEMENT_APPROACH, -1, -1, approachCell, this._target)
                    }
                    return null
                }
            }
        }

        var action = new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, bestCell._id, this._target)
        return action
    }

    getHideAndSeekAction(mpBudget) {
        if (mpBudget <= 0) return null

        if (this._hideCache != null) {
            return this._hideCache
        }

        var hideCell = this._fieldMap.findHideAndSeekCell("defensive")
        if (hideCell != null) {
            this._hideCache = new Action(Action.MOVEMENT_HNS, -1, -1, hideCell['cell'], this._target)
            return this._hideCache
        }

        return null
    }

    getKiteAwayAction(mpBudget) {
        if (mpBudget <= 0) return null

        if (this._kiteCache != null) {
            return this._kiteCache
        }

        this._kiteCache = new Action(Action.MOVEMENT_FLEE, -1, -1, -1, this._target)
        return this._kiteCache
    }

    getApproachEnemyCell(mpBudget) {
        if (mpBudget <= 0) return null

        // Get all reachable cells within MP budget
        var reachableCells = getReachableCells()
        if (reachableCells == null || count(reachableCells) == 0) return null

        var enemyPos = this._target._cellPos
        var currentDist = getCellDistance(this._player._cellPos, enemyPos)
        if (currentDist == null) return null

        // Find the reachable cell that gets us closest to the enemy
        var bestCell = null
        var bestDist = currentDist

        for (var cellId in reachableCells) {
            var cellDist = getCellDistance(cellId, enemyPos)
            if (cellDist == null) continue

            // Only consider cells that get us closer
            if (cellDist < bestDist) {
                var pathCost = getGraphMPCost(cellId)
                if (pathCost < 999 && pathCost <= mpBudget) {
                    bestDist = cellDist
                    bestCell = cellId
                }
            }
        }

        if (bestCell != null) {
            return bestCell
        }

        // Fallback: No cell gets us closer, but we're stuck (e.g., in a corner)
        // Return any reachable cell to at least try to move
        var fallbackCell = null
        var fallbackDist = 999
        for (var cellId in reachableCells) {
            var cellDist = getCellDistance(cellId, enemyPos)
            if (cellDist == null) continue

            // Pick the cell that's least far from enemy (minimize damage)
            if (cellDist < fallbackDist) {
                var pathCost = getGraphMPCost(cellId)
                if (pathCost < 999 && pathCost <= mpBudget) {
                    fallbackDist = cellDist
                    fallbackCell = cellId
                }
            }
        }

        if (fallbackCell != null) {
            return fallbackCell
        }

        return null
    }

    // =========================================================================
    // === Attack Helpers ===
    // =========================================================================

    getWeaponSpamActions(tpBudget, fraction, simPos = -1) {
        var actions = []
        var tpToUse = floor(tpBudget * fraction)

        var checkPos = (simPos == -1) ? this._player._cellPos : simPos

        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]
            if (tpToUse < weapon._cost) continue

            var dist = getCellDistance(checkPos, this._target._cellPos)
            if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue
            if (!lineOfSight(checkPos, this._target._cellPos)) continue

            var uses = min(weapon._maxUse, floor(tpToUse / weapon._cost))
            for (var i = 0; i < uses; i++) {
                push(actions, new Action(Action.ACTION_DIRECT, weapon._id, -1, this._target._cellPos, this._target))
                tpToUse -= weapon._cost
            }
        }

        return actions
    }

    getAntidoteAction(tpBudget) {
        if (!this._player.hasEffect(EFFECT_POISON)) return null
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_ANTIDOTE)) return null
        if (getCooldown(CHIP_ANTIDOTE, this._player._id) != 0) return null
        if (tpBudget < 3) return null

        var poisonRemaining = this._player.getEffectRemaining(EFFECT_POISON)
        if (poisonRemaining < 2) return null

        var poisonDamagePerTurn = this._player.getEffectValue(EFFECT_POISON)
        if (poisonDamagePerTurn == null) poisonDamagePerTurn = 0

        var totalPoisonDamage = poisonDamagePerTurn * poisonRemaining

        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP

        if (totalPoisonDamage > 200) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_ANTIDOTE, -1, this._player)
        }

        if (poisonDamagePerTurn > 50 && poisonRemaining >= 3) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_ANTIDOTE, -1, this._player)
        }

        if (hpRatio < 0.5 && totalPoisonDamage > 100) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_ANTIDOTE, -1, this._player)
        }

        if (totalPoisonDamage > currentHP) {
            return new Action(Action.ACTION_BUFF, -1, CHIP_ANTIDOTE, -1, this._player)
        }

        return null
    }

    getDebuffAction() {
        if (!mapContainsKey(this._arsenal.playerEquippedChips, CHIP_LIBERATION)) return null
        if (getCooldown(CHIP_LIBERATION, this._player._id) != 0) return null

        var targetBuffs = 0
        if (this._target.hasEffect(EFFECT_ABSOLUTE_SHIELD)) targetBuffs++
        if (this._target.hasEffect(EFFECT_RELATIVE_SHIELD)) targetBuffs++
        if (this._target.hasEffect(EFFECT_DAMAGE_RETURN)) targetBuffs++
        if (this._target.hasEffect(EFFECT_BUFF_RESISTANCE)) targetBuffs++
        if (this._target.hasEffect(EFFECT_BUFF_STRENGTH)) targetBuffs++

        if (targetBuffs > 0) {
            return new Action(Action.ACTION_DEBUFF, -1, CHIP_LIBERATION, this._target._cellPos, this._target)
        }

        return null
    }

    getAttackActions(tpBudget, fraction, simPos) {
        var actions = []

        var tpToUse = tpBudget
        var weaponUses = [:]
        var chipCooldowns = [:]

        while (tpToUse >= 4) {
            var bestAttack = this.findBestAvailableAttack(simPos, weaponUses, chipCooldowns)
            if (bestAttack == null) break

            var attackCost = bestAttack['cost']
            if (tpToUse < attackCost) break

            var attackType = bestAttack['type']
            var attackId = bestAttack['id']
            var attackTargetCell = bestAttack['targetCell']
            if (attackTargetCell == null) attackTargetCell = this._target._cellPos

            // Check if we need to reposition for AoE safety
            var repositionCell = bestAttack['repositionCell']
            if (repositionCell != null && repositionCell != -1 && repositionCell != simPos) {
                var moveAction = new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, repositionCell, this._target)
                push(actions, moveAction)
                // Note: Simulator will update simPos after this movement
            }

            if (attackType == 'weapon') {
                var weaponAction = new Action(Action.ACTION_DIRECT, attackId, -1, attackTargetCell, this._target)
                weaponAction.isSplash = bestAttack['isSplash']
                push(actions, weaponAction)
                var currentUses = weaponUses[attackId]
                if (currentUses == null) currentUses = 0
                weaponUses[attackId] = currentUses + 1
            } else {
                var chipAction = new Action(Action.ACTION_DIRECT, -1, attackId, attackTargetCell, this._target)
                chipAction.isSplash = bestAttack['isSplash']
                push(actions, chipAction)
                chipCooldowns[attackId] = true
            }

            tpToUse -= attackCost
        }

        return actions
    }

    findSafeAoEWeaponCell(weaponId, targetCell, currentPos, weaponUses, chipCooldowns) {
        // Find a nearby cell where we can safely use this AoE weapon
        var reachableCells = getReachableCells()
        if (reachableCells == null || count(reachableCells) == 0) return -1

        var weapon = this._arsenal.playerEquippedWeapons[weaponId]
        if (weapon == null) return -1

        var bestCell = -1
        var bestDist = 999

        for (var cellId in reachableCells) {
            // Check if we can attack from this cell
            var dist = getCellDistance(cellId, this._target._cellPos)
            if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue

            // Check if we have LOS from this cell
            if (!lineOfSight(cellId, targetCell)) continue

            // Check if attack from this cell would be safe
            if (this._strategy != null) {
                var aoeCheck = this._strategy.checkAoEWeaponSafety(weaponId, targetCell, cellId)
                if (aoeCheck['safe']) {
                    // Prefer closest cell to current position (minimize MP cost)
                    var moveDist = getCellDistance(currentPos, cellId)
                    if (moveDist != null && moveDist < bestDist) {
                        bestDist = moveDist
                        bestCell = cellId
                    }
                }
            }
        }

        return bestCell
    }

    findSafeAoEAttackCell(chipId, targetCell, currentPos, weaponUses, chipCooldowns) {
        // Find a nearby cell where we can safely use this AoE chip/weapon
        var reachableCells = getReachableCells()
        if (reachableCells == null || count(reachableCells) == 0) return -1

        var chip = this._arsenal.playerEquippedChips[chipId]
        if (chip == null) return -1

        var bestCell = -1
        var bestDist = 999

        for (var cellId in reachableCells) {
            // Check if we can attack from this cell
            var dist = getCellDistance(cellId, this._target._cellPos)
            if (dist == null || dist < chip._minRange || dist > chip._maxRange) continue

            // Check if we have LOS from this cell
            if (!lineOfSight(cellId, targetCell)) continue

            // Check if attack from this cell would be safe
            if (this._strategy != null) {
                var aoeCheck = this._strategy.checkAoESafetyFromCell(chipId, targetCell, cellId)
                if (aoeCheck['safe']) {
                    // Prefer closest cell to current position (minimize MP cost)
                    var moveDist = getCellDistance(currentPos, cellId)
                    if (moveDist != null && moveDist < bestDist) {
                        bestDist = moveDist
                        bestCell = cellId
                    }
                }
            }
        }

        return bestCell
    }

    findBestAvailableAttack(simPos, weaponUses, chipCooldowns) {
        var str = this._player._strength
        var mag = this._player._magic
        var wis = this._player._wisdom
        var sci = this._player._science
        var bestAttack = null
        var bestDamage = 0

        // Magic builds: apply penalty to weapon damage so chips win when MAG > STR
        // At 0 STR / 600 MAG, weapons still do base damage (~40-60) but chips do 300+
        // This ensures chips are always preferred when magic is the primary stat
        var weaponDamageMultiplier = 1.0
        if (mag > str + 100) {
            // Heavy magic build: penalize weapons proportionally to stat gap
            weaponDamageMultiplier = 0.3  // Weapons score at 30% of actual damage
        }

        for (var weaponId in mapKeys(this._arsenal.playerEquippedWeapons)) {
            var weapon = this._arsenal.playerEquippedWeapons[weaponId]

            var currentUses = weaponUses[weaponId]
            if (currentUses == null) currentUses = 0
            if (currentUses >= weapon._maxUse) continue

            var targetCell = this._target._cellPos
            var isSplashAttack = false

            if (mapContainsKey(this._fieldMap.weaponHitmap, weaponId)) {
                var shooterCells = this._fieldMap.weaponHitmap[weaponId]
                var canShootFromHere = false
                for (var cell in shooterCells) {
                    if (cell == simPos) {
                        canShootFromHere = true
                        break
                    }
                }
                if (!canShootFromHere) continue

                // Check if we actually have LOS from simPos (hitmap may be outdated)
                if (!lineOfSight(simPos, this._target._cellPos)) {
                    if (this._strategy != null) {
                        var splashResult = this._strategy.findAoEWeaponSplashCell(weaponId, this._target._cellPos, simPos)
                        if (splashResult != null) {
                            targetCell = splashResult['cell']
                            isSplashAttack = true
                        } else {
                            continue
                        }
                    } else {
                        continue
                    }
                }
            } else {
                var dist = getCellDistance(simPos, this._target._cellPos)
                if (dist == null || dist < weapon._minRange || dist > weapon._maxRange) continue

                if (!lineOfSight(simPos, this._target._cellPos)) {
                    if (this._strategy != null) {
                        var splashResult = this._strategy.findAoEWeaponSplashCell(weaponId, this._target._cellPos, simPos)
                        if (splashResult != null) {
                            targetCell = splashResult['cell']
                            isSplashAttack = true
                        } else {
                            continue
                        }
                    } else {
                        continue
                    }
                }
            }

            var rawDamage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, weaponId, this._target)
            // Apply magic build weapon penalty (poison weapons exempt - they scale with MAG)
            var damage = isPoisonWeapon(weaponId) ? rawDamage : rawDamage * weaponDamageMultiplier
            if (damage > bestDamage) {
                var isSafe = true
                var needsReposition = false
                var repositionCell = -1

                if (this._strategy != null) {
                    // Check AoE safety for ALL weapons (including poison)
                    var aoeCheck = this._strategy.checkAoEWeaponSafety(weaponId, targetCell, simPos)
                    isSafe = aoeCheck['safe']
                    needsReposition = aoeCheck['needsRepositioning']

                    // If unsafe but can reposition, find a safe cell to attack from
                    if (!isSafe && needsReposition) {
                        repositionCell = this.findSafeAoEWeaponCell(weaponId, targetCell, simPos, weaponUses, chipCooldowns)
                        if (repositionCell != -1) {
                            isSafe = true  // Found safe position
                        } else {
                            // Fallback: Allow attack if damage is high enough
                            if (damage >= 200) {
                                isSafe = true
                            }
                        }
                    }
                }

                if (isSafe) {
                    bestDamage = damage
                    bestAttack = ["type": "weapon", "id": weaponId, "cost": weapon._cost, "damage": damage, "targetCell": targetCell, "isSplash": isSplashAttack, "repositionCell": repositionCell]
                }
            }
        }

        var damageChips = [CHIP_LIGHTNING, CHIP_PLASMA, CHIP_METEORITE, CHIP_ICEBERG,
                           CHIP_FIRE_BALL, CHIP_ROCK, CHIP_FLAME, CHIP_STALACTITE, CHIP_ARSENIC,
                           CHIP_VENOM, CHIP_TOXIN, CHIP_PLAGUE, CHIP_COVID,
                           CHIP_SOPORIFIC, CHIP_BALL_AND_CHAIN]

        for (var chipId in damageChips) {
            if (!mapContainsKey(this._arsenal.playerEquippedChips, chipId)) continue
            if (chipCooldowns[chipId] != null) continue
            if (getCooldown(chipId, this._player._id) > 0) continue

            var chip = this._arsenal.playerEquippedChips[chipId]
            var dist = getCellDistance(simPos, this._target._cellPos)
            if (dist == null || dist < chip._minRange || dist > chip._maxRange) continue

            var chipTargetCell = this._target._cellPos
            var isChipSplash = false

            if (!lineOfSight(simPos, this._target._cellPos)) {
                if (this._strategy != null) {
                    var chipSplashResult = this._strategy.findAoESplashCell(chipId, this._target._cellPos, simPos)
                    if (chipSplashResult != null) {
                        chipTargetCell = chipSplashResult['cell']
                        isChipSplash = true
                    } else {
                        continue
                    }
                } else {
                    continue
                }
            }

            var damage = this._arsenal.getNetDamageAgainstTarget(str, mag, wis, sci, chipId, this._target)
            if (damage > bestDamage) {
                var isSafe = true
                var needsReposition = false
                var repositionCell = -1

                if (this._strategy != null) {
                    // Check AoE safety for ALL chips (including poison/denial)
                    var aoeCheck = this._strategy.checkAoESafetyFromCell(chipId, chipTargetCell, simPos)
                    isSafe = aoeCheck['safe']
                    needsReposition = aoeCheck['needsRepositioning']

                    // If unsafe but can reposition, find a safe cell to attack from
                    if (!isSafe && needsReposition) {
                        repositionCell = this.findSafeAoEAttackCell(chipId, chipTargetCell, simPos, weaponUses, chipCooldowns)
                        if (repositionCell != -1) {
                            isSafe = true  // Found safe position
                        } else {
                            // Fallback: Allow attack if damage is high enough
                            if (damage >= 300) {
                                isSafe = true
                            }
                        }
                    }
                }

                if (isSafe) {
                    bestDamage = damage
                    bestAttack = ["type": "chip", "id": chipId, "cost": getCachedChipCost(chipId), "damage": damage, "targetCell": chipTargetCell, "isSplash": isChipSplash, "repositionCell": repositionCell]
                }
            }
        }

        return bestAttack
    }

    // =========================================================================
    // === Utilities ===
    // =========================================================================

    isDiagonal(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        var dx = abs(x2 - x1)
        var dy = abs(y2 - y1)
        return dx == dy && dx > 0
    }

    isOnSameLine(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        return (x1 == x2 || y1 == y2)
    }

    calculateLifestealHealing(damage) {
        // Lifesteal formula: Heal = Damage * Wisdom / 1000
        var wisdom = this._player._wisdom
        return (damage * wisdom) / 1000
    }
}
