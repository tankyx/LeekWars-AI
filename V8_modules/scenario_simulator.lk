include('game_entity.lk')

class SimulationResult {
    damageDealt = 0
    dotDamageQueued = 0
    novaDamageQueued = 0
    hpGained = 0
    lifestealHealing = 0
    shieldsGained = 0
    relativeShieldGained = 0
    tpSpent = 0
    mpSpent = 0
    finalPosition = -1
    buffsApplied = []
    debuffsApplied = []
    actionsExecuted = 0
    vulnerabilityApplied = 0

    // Battle Royale multi-target tracking
    totalLobbyDamage = 0      // Sum of damage to all enemies
    enemiesHit = 0            // Number of enemies hit (AoE)
    killsSecured = 0          // Estimated kills from this scenario

    // Bulb targeting system
    bulbDamage = 0            // Damage dealt to bulbs
    leekDamage = 0            // Damage dealt to leeks
    bulbsHit = 0              // Number of bulbs hit
    bulbKillsSecured = 0      // Estimated bulb kills

    // Poison source tracking for multi-stack scoring
    poisonSourcesUsed = 0     // Count of distinct poison-applying actions

    // Boss PUZZLE crystal tracking
    crystalAxisReduction = 0  // Cells of alignment improvement
    crystalSolved = false      // Crystal reached goal axis with LOS

    constructor() {
        this.buffsApplied = []
        this.debuffsApplied = []
    }
}

class ScenarioSimulator {
    _arsenal = null
    _player = null
    _target = null
    _fieldMap = null

    constructor(arsenal, player, target, fieldMap) {
        this._arsenal = arsenal
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
    }

    simulate(actions) {
        var result = new SimulationResult()

        var simPos = this._player._cellPos
        var simTP = getTP()
        var simMP = getMP()
        var simWeapon = getWeapon()
        var simStrength = this._player._strength
        var simMagic = this._player._magic
        var simWisdom = this._player._wisdom
        var simScience = this._player._science
        var simWeaponUses = [:]

        var simEnemyCurrHP = 1
        var simEnemyMaxHP = 1
        if (this._target != null) {
            simEnemyCurrHP = this._target._currHealth
            simEnemyMaxHP = this._target._maxHealth
        }

        // Detect if target is a bulb
        var targetIsBulb = (this._target != null) ? isBulb(this._target) : false

        result.finalPosition = simPos

        for (var action in actions) {
            
            if (!this.canExecuteAction(action, simPos, simTP, simMP, simWeapon)) {
                continue
            }

            if (action.type == Action.ACTION_DIRECT || action.type == Action.ACTION_DOT || action.type == Action.ACTION_DEBUFF) {
                if (action.chip != -1) {

                    var chipCost = getChipCost(action.chip)
                    var chipDmg = (this._target != null) ? this._arsenal.getNetDamageAgainstTarget(simStrength, simMagic, simWisdom, simScience, action.chip, this._target) : 0
                    var breakdown = this._arsenal.getDamageBreakdown(simStrength, simMagic, simWisdom, simScience, action.chip)

                    // Use net damage (post-shield) for accurate scenario ranking
                    var rawDirect = breakdown['direct']
                    var relShield = (this._target != null) ? this._target._relShield / 100 : 0
                    var absShield = (this._target != null) ? this._target._absShield : 0
                    var directDmg = rawDirect * (1 - relShield) - absShield
                    if (directDmg < 0) directDmg = 0
                    result.damageDealt += directDmg
                    simEnemyCurrHP -= directDmg
                    if (simEnemyCurrHP < 0) simEnemyCurrHP = 0

                    // Calculate lifesteal healing
                    var lifesteal = (directDmg * simWisdom) / 1000
                    result.lifestealHealing += lifesteal

                    // Track bulb vs leek damage
                    if (targetIsBulb) {
                        result.bulbDamage += directDmg
                    } else {
                        result.leekDamage += directDmg
                    }

                    var chipDot = breakdown['dot']
                    result.dotDamageQueued += chipDot
                    if (chipDot > 0) result.poisonSourcesUsed++

                    var hpDeficit = simEnemyMaxHP - simEnemyCurrHP
                    var uncappedNova = breakdown['nova']
                    var cappedNova = uncappedNova
                    if (hpDeficit < uncappedNova) {
                        cappedNova = hpDeficit
                    }
                    var currentNova = result.novaDamageQueued != null ? result.novaDamageQueued : 0
                    result.novaDamageQueued = currentNova + cappedNova

                    simEnemyMaxHP -= cappedNova
                    if (simEnemyMaxHP < simEnemyCurrHP) simEnemyMaxHP = simEnemyCurrHP

                    result.tpSpent += chipCost
                    simTP -= chipCost

                    if (action.type == Action.ACTION_DEBUFF) {
                        push(result.debuffsApplied, action.chip)
                    }

                    result.actionsExecuted++
                } else if (action.weaponId != -1) {
                    
                    var weaponObj = null
                    if (mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                        weaponObj = this._arsenal.playerEquippedWeapons[action.weaponId]
                    }

                    if (weaponObj != null) {
                        
                        var currentUses = simWeaponUses[action.weaponId]
                        if (currentUses == null) currentUses = 0

                        if (currentUses >= weaponObj._maxUse) {
                            continue
                        }

                        var swapCost = (simWeapon != action.weaponId) ? 1 : 0
                        var weaponCost = weaponObj._cost
                        var weaponDmg = (this._target != null) ? this._arsenal.getNetDamageAgainstTarget(simStrength, simMagic, simWisdom, simScience, action.weaponId, this._target) : 0
                        var weaponBreakdown = this._arsenal.getDamageBreakdown(simStrength, simMagic, simWisdom, simScience, action.weaponId)

                        // Use net damage (post-shield) for accurate scenario ranking
                        var rawDirect = weaponBreakdown['direct']
                        var relShield = (this._target != null) ? this._target._relShield / 100 : 0
                        var absShield = (this._target != null) ? this._target._absShield : 0
                        var directDmg = rawDirect * (1 - relShield) - absShield
                        if (directDmg < 0) directDmg = 0
                        result.damageDealt += directDmg
                        simEnemyCurrHP -= directDmg
                        if (simEnemyCurrHP < 0) simEnemyCurrHP = 0

                        // Calculate lifesteal healing
                        var lifesteal = (directDmg * simWisdom) / 1000
                        result.lifestealHealing += lifesteal

                        // ENHANCED_LIGHTNINGER bonus: +100 HP healing
                        if (action.weaponId == WEAPON_ENHANCED_LIGHTNINGER) {
                            result.lifestealHealing += 100
                        }

                        // WEAPON_UNSTABLE_DESTROYER crit-heal passive: 50-150 HP on critical hit
                        // Estimate: critChance * avgHeal = (agi/2000) * 100
                        if (action.weaponId == WEAPON_UNSTABLE_DESTROYER) {
                            var agi = this._player._agility
                            var critChance = min(0.5, agi / 2000.0)
                            var avgCritHeal = 100  // Average of 50-150 passive heal
                            result.lifestealHealing += critChance * avgCritHeal
                        }

                        // Track bulb vs leek damage
                        if (targetIsBulb) {
                            result.bulbDamage += directDmg
                        } else {
                            result.leekDamage += directDmg
                        }

                        var weaponDot = weaponBreakdown['dot']
                        result.dotDamageQueued += weaponDot
                        if (weaponDot > 0) result.poisonSourcesUsed++

                        var hpDeficit = simEnemyMaxHP - simEnemyCurrHP
                        var uncappedNova = weaponBreakdown['nova']
                        var cappedNova = uncappedNova
                        if (hpDeficit < uncappedNova) {
                            cappedNova = hpDeficit
                        }
                        var currentNova = result.novaDamageQueued != null ? result.novaDamageQueued : 0
                        result.novaDamageQueued = currentNova + cappedNova

                        simEnemyMaxHP -= cappedNova
                        if (simEnemyMaxHP < simEnemyCurrHP) simEnemyMaxHP = simEnemyCurrHP

                        result.tpSpent += swapCost + weaponCost
                        simTP -= swapCost + weaponCost
                        simWeapon = action.weaponId
                        simWeaponUses[action.weaponId] = currentUses + 1

                        if (action.weaponId == WEAPON_NEUTRINO) {
                            result.vulnerabilityApplied += 8  
                        } else if (action.weaponId == WEAPON_HEAVY_SWORD) {
                            result.vulnerabilityApplied += 60  
                        }

                        result.actionsExecuted++
                    }
                }
            }
            else if (action.type == Action.ACTION_BUFF) {

                var buffCost = getChipCost(action.chip)
                result.tpSpent += buffCost
                simTP -= buffCost
                push(result.buffsApplied, action.chip)

                if (action.chip == CHIP_HELMET || action.chip == CHIP_SHIELD) {
                    // Absolute shields (flat HP reduction)
                    var shieldAmount = this.estimateShieldAmount(action.chip, simWisdom)
                    result.shieldsGained += shieldAmount
                } else if (action.chip == CHIP_WALL || action.chip == CHIP_FORTRESS) {
                    // Relative shields (percentage damage reduction)
                    var relShieldPercent = this.estimateRelativeShield(action.chip)
                    result.relativeShieldGained += relShieldPercent
                } else if (action.chip == CHIP_PROTEIN) {
                    result.relativeShieldGained += this.estimateRelativeShield(action.chip)
                } else if (action.chip == CHIP_LEATHER_BOOTS) {
                    // LEATHER_BOOTS: +2 MP resource, not a shield
                    simMP += 2
                } else if (action.chip == CHIP_REGENERATION || action.chip == CHIP_REMISSION || action.chip == CHIP_CURE || action.chip == CHIP_DRIP) {
                    result.hpGained += this.estimateHealing(action.chip, simWisdom)
                } else if (action.chip == CHIP_STEROID || action.chip == CHIP_DOPING) {

                    simStrength += this.estimateStrengthBuff(action.chip)
                } else if (action.chip == CHIP_PRISM) {
                    // PRISM: +60 all stats (STR, MAG, WIS, SCI, AGI, RES)
                    simStrength += 60
                    simMagic += 60
                    simWisdom += 60
                    simScience += 60
                } else if (action.chip == CHIP_WIZARDRY) {
                    // WIZARDRY: +150-170 Magic for 2 turns (avg 160)
                    simMagic += 160
                } else if (action.chip == CHIP_KNOWLEDGE) {
                    // KNOWLEDGE: +250-270 Wisdom for 2 turns (avg 260)
                    simWisdom += 260
                } else if (action.chip == CHIP_ELEVATION) {
                    // ELEVATION: +80 Max HP (one-time, also heals)
                    result.hpGained += 80
                } else if (action.chip == CHIP_WARM_UP) {
                    // WARM_UP: +170-190 AGI for 3 turns (avg 180)
                    // AGI boosts crit chance and damage return % but isn't tracked in sim
                    // (crit-heal uses base _agility which is acceptable approximation)
                } else if (action.chip == CHIP_ADRENALINE) {

                    simTP += 5
                } else if (action.chip == CHIP_MIRROR || action.chip == CHIP_THORN || action.chip == CHIP_BRAMBLE) {
                    // Damage return buffs (tracked for scoring, not simulated in combat)
                    // No simulation changes needed - these are defensive passives
                }

                result.actionsExecuted++
            }
            else if (action.type == Action.ACTION_WEAPON_SWAP) {
                if (mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                    var swapCost = 1
                    result.tpSpent += swapCost
                    simTP -= swapCost
                    simWeapon = action.weaponId
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.MOVEMENT_APPROACH || action.type == Action.MOVEMENT_OFFENSIVE ||
                     action.type == Action.MOVEMENT_DEFENSIVE || action.type == Action.MOVEMENT_OTKO ||
                     action.type == Action.MOVEMENT_DOT_OFFENSIVE || action.type == Action.MOVEMENT_DEBUFF ||
                     action.type == Action.MOVEMENT_HNS || action.type == Action.MOVEMENT_PAB) {
                
                var pathLength = getCachedPathLength(simPos, action.targetCell)
                if (pathLength != null && pathLength <= simMP) {
                    result.mpSpent += pathLength
                    simMP -= pathLength
                    simPos = action.targetCell
                    result.finalPosition = simPos
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.MOVEMENT_FLEE) {
                
                var estimatedMP = min(simMP, 3)  
                result.mpSpent += estimatedMP
                simMP -= estimatedMP
                result.actionsExecuted++
            }
            else if (action.type == Action.ACTION_TELEPORT) {
                var tpCost = getChipCost(CHIP_TELEPORTATION)
                var dist = getCellDistance(simPos, action.targetCell)
                if (dist != null && dist >= 1 && dist <= 12 && simTP >= tpCost) {
                    result.tpSpent += tpCost
                    simTP -= tpCost
                    simPos = action.targetCell
                    result.finalPosition = simPos
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.ACTION_SUMMON) {
                // Summon costs TP but contributes future value (not simulated in detail)
                if (action.chip != -1) {
                    var summonCost = getChipCost(action.chip)
                    result.tpSpent += summonCost
                    simTP -= summonCost
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.ACTION_CHECKPOINT) {

                result.actionsExecuted++

            }
        }

        // Track bulb targeting metrics
        if (targetIsBulb && result.bulbDamage > 0) {
            result.bulbsHit = 1

            // Estimate if we secured a bulb kill
            var totalDamageToTarget = result.damageDealt + result.dotDamageQueued + (result.novaDamageQueued != null ? result.novaDamageQueued : 0)
            if (totalDamageToTarget >= simEnemyCurrHP) {
                result.bulbKillsSecured = 1
            }
        }

        // Boss PUZZLE: simulate crystal movement from grapple/boxing_glove actions
        if (_isBossFight && _bossPhase == "PUZZLE" && _bossTargetEID != null) {
            var simCX = _myCrystalX
            var simCY = _myCrystalY
            var gX = _graalX
            var gY = _graalY
            var initialDist = getDistanceToAxis(null)

            for (var action in actions) {
                if (action.chip == CHIP_GRAPPLE && action.targetCell == _myCrystalCell) {
                    // Grapple pulls crystal 1 cell toward simPos along line
                    var pullDir = computePullDirection(simCX, simCY, simPos)
                    simCX += pullDir[0]
                    simCY += pullDir[1]
                }
                if (action.chip == CHIP_BOXING_GLOVE && action.targetCell == _myCrystalCell) {
                    // Boxing glove pushes crystal 1 cell away from simPos
                    var pushDir = computePushDirection(simCX, simCY, simPos)
                    simCX += pushDir[0]
                    simCY += pushDir[1]
                }
            }

            var finalDist = computeAxisDist(simCX, simCY, gX, gY, _myCrystalGoalAxis)
            result.crystalAxisReduction = initialDist - finalDist
            result.crystalSolved = checkOnAxis(simCX, simCY, gX, gY, _myCrystalGoalAxis)

            // Zero out damage during PUZZLE (enemies are invulnerable)
            result.damageDealt = 0
            result.dotDamageQueued = 0
            result.novaDamageQueued = 0
        }

        return result
    }

    canExecuteAction(action, simPos, simTP, simMP, simWeapon) {
        if (action.type == Action.ACTION_DIRECT || action.type == Action.ACTION_DOT ||
            action.type == Action.ACTION_DEBUFF || action.type == Action.ACTION_BUFF) {
            if (action.chip != -1) {
                var cost = getChipCost(action.chip)
                if (simTP < cost) return false
                // Range validation for chips
                if (mapContainsKey(this._arsenal.playerEquippedChips, action.chip)) {
                    var chipObj = this._arsenal.playerEquippedChips[action.chip]
                    var tCell = action.targetCell
                    if (tCell == -1 && action.targetEntity != null && action.targetEntity != -1) {
                        tCell = action.targetEntity._cellPos
                    }
                    if (tCell != -1 && tCell != simPos) {
                        var dist = getCellDistance(simPos, tCell)
                        if (dist == null || dist < chipObj._minRange || dist > chipObj._maxRange) {
                            return false
                        }
                    }
                }
                return true
            } else if (action.weaponId != -1) {
                    var weaponCost = null
                    var weaponObj = null
                    if (mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                        weaponObj = this._arsenal.playerEquippedWeapons[action.weaponId]
                        weaponCost = weaponObj._cost
                    }
                if (weaponCost == null) return false
                var swapCost = (simWeapon != action.weaponId) ? 1 : 0
                if (simTP < swapCost + weaponCost) return false
                // Range validation for weapons
                var tCell = action.targetCell
                if (tCell == -1 && action.targetEntity != null && action.targetEntity != -1) {
                    tCell = action.targetEntity._cellPos
                }
                if (tCell != -1 && tCell != simPos) {
                    var dist = getCellDistance(simPos, tCell)
                    if (dist == null || dist < weaponObj._minRange || dist > weaponObj._maxRange) {
                        return false
                    }
                }
                return true
            }
        }
        else if (action.type == Action.ACTION_WEAPON_SWAP) {
            if (!mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                return false
            }
            return simTP >= 1
        }
        else if (action.type == Action.MOVEMENT_APPROACH || action.type == Action.MOVEMENT_OFFENSIVE ||
                 action.type == Action.MOVEMENT_DEFENSIVE || action.type == Action.MOVEMENT_OTKO ||
                 action.type == Action.MOVEMENT_DOT_OFFENSIVE || action.type == Action.MOVEMENT_DEBUFF ||
                 action.type == Action.MOVEMENT_HNS || action.type == Action.MOVEMENT_PAB) {
            var pathLength = getCachedPathLength(simPos, action.targetCell)
            return pathLength != null && pathLength <= simMP
        }
        else if (action.type == Action.MOVEMENT_FLEE) {
            return simMP >= 1  
        }
        else if (action.type == Action.ACTION_SUMMON) {
            if (action.chip == -1) return false
            var summonCost = getChipCost(action.chip)
            return simTP >= summonCost
        }
        else if (action.type == Action.ACTION_TELEPORT) {
            var tpCost = getChipCost(CHIP_TELEPORTATION)
            return simTP >= tpCost
        }

        return true
    }

    estimateShieldAmount(chip, wisdom) {
        // Absolute shields only (flat HP reduction)
        if (!isAbsoluteShieldChip(chip)) return 0
        if (chip == CHIP_HELMET) return 50 + wisdom * 0.5
        if (chip == CHIP_SHIELD) return 100 + wisdom * 1.0
        return 0
    }

    estimateRelativeShield(chip) {
        // Relative shields (percentage damage reduction, scales with Resistance)
        if (!isRelativeShieldChip(chip)) return 0

        var resistance = this._player._resistance
        var scalingMultiplier = 1 + (resistance / 100.0)

        if (chip == CHIP_WALL) {
            var basePercent = 4.5  // 4-5% base at max level
            return basePercent * scalingMultiplier
        }
        if (chip == CHIP_FORTRESS) {
            var basePercent = 7.5  // 7-8% base at max level
            return basePercent * scalingMultiplier
        }
        if (chip == CHIP_PROTEIN) {
            return 10  // Fixed 10% (does not scale)
        }
        return 0
    }

    estimateHealing(chip, wisdom) {
        if (isHealingChip(chip)) {
            return arsenal.getExpectedHeal(chip, wisdom)
        }
        return 0
    }

    estimateStrengthBuff(chip) {
        if (!isOffensiveBuff(chip)) return 0
        if (chip == CHIP_STEROID) return 100
        if (chip == CHIP_DOPING) return 50
        return 0
    }
}
