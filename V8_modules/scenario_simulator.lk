include('game_entity.lk')

class SimulationResult {
    damageDealt = 0
    dotDamageQueued = 0
    novaDamageQueued = 0
    hpGained = 0
    lifestealHealing = 0
    shieldsGained = 0
    relativeShieldGained = 0
    tpSpent = 0
    mpSpent = 0
    finalPosition = -1
    buffsApplied = []
    debuffsApplied = []
    actionsExecuted = 0
    vulnerabilityApplied = 0

    // Battle Royale multi-target tracking
    totalLobbyDamage = 0      // Sum of damage to all enemies
    enemiesHit = 0            // Number of enemies hit (AoE)
    killsSecured = 0          // Estimated kills from this scenario

    // Bulb targeting system
    bulbDamage = 0            // Damage dealt to bulbs
    leekDamage = 0            // Damage dealt to leeks
    bulbsHit = 0              // Number of bulbs hit
    bulbKillsSecured = 0      // Estimated bulb kills

    constructor() {
        this.buffsApplied = []
        this.debuffsApplied = []
    }
}

class ScenarioSimulator {
    _arsenal = null
    _player = null
    _target = null
    _fieldMap = null

    constructor(arsenal, player, target, fieldMap) {
        this._arsenal = arsenal
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
    }

    simulate(actions) {
        var result = new SimulationResult()

        var simPos = this._player._cellPos
        var simTP = getTP()
        var simMP = getMP()
        var simWeapon = getWeapon()
        var simStrength = this._player._strength
        var simMagic = this._player._magic
        var simWisdom = this._player._wisdom
        var simScience = this._player._science
        var simWeaponUses = [:]

        var simEnemyCurrHP = this._target._currHealth
        var simEnemyMaxHP = this._target._maxHealth

        // Detect if target is a bulb
        var targetIsBulb = isBulb(this._target)

        result.finalPosition = simPos

        for (var action in actions) {
            
            if (!this.canExecuteAction(action, simPos, simTP, simMP, simWeapon)) {
                continue
            }

            if (action.type == Action.ACTION_DIRECT || action.type == Action.ACTION_DOT || action.type == Action.ACTION_DEBUFF) {
                if (action.chip != -1) {

                    var chipCost = getChipCost(action.chip)
                    var chipDmg = this._arsenal.getNetDamageAgainstTarget(simStrength, simMagic, simWisdom, simScience, action.chip, this._target)
                    var breakdown = this._arsenal.getDamageBreakdown(simStrength, simMagic, simWisdom, simScience, action.chip)

                    var directDmg = breakdown['direct']
                    result.damageDealt += directDmg
                    simEnemyCurrHP -= directDmg
                    if (simEnemyCurrHP < 0) simEnemyCurrHP = 0

                    // Calculate lifesteal healing
                    var lifesteal = (directDmg * simWisdom) / 1000
                    result.lifestealHealing += lifesteal

                    // Track bulb vs leek damage
                    if (targetIsBulb) {
                        result.bulbDamage += directDmg
                    } else {
                        result.leekDamage += directDmg
                    }

                    result.dotDamageQueued += breakdown['dot']

                    var hpDeficit = simEnemyMaxHP - simEnemyCurrHP
                    var uncappedNova = breakdown['nova']
                    var cappedNova = uncappedNova
                    if (hpDeficit < uncappedNova) {
                        cappedNova = hpDeficit
                    }
                    var currentNova = result.novaDamageQueued != null ? result.novaDamageQueued : 0
                    result.novaDamageQueued = currentNova + cappedNova

                    simEnemyMaxHP -= cappedNova
                    if (simEnemyMaxHP < simEnemyCurrHP) simEnemyMaxHP = simEnemyCurrHP

                    result.tpSpent += chipCost
                    simTP -= chipCost

                    if (action.type == Action.ACTION_DEBUFF) {
                        push(result.debuffsApplied, action.chip)
                    }

                    result.actionsExecuted++
                } else if (action.weaponId != -1) {
                    
                    var weaponObj = null
                    if (mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                        weaponObj = this._arsenal.playerEquippedWeapons[action.weaponId]
                    }

                    if (weaponObj != null) {
                        
                        var currentUses = simWeaponUses[action.weaponId]
                        if (currentUses == null) currentUses = 0

                        if (currentUses >= weaponObj._maxUse) {
                            continue
                        }

                        var swapCost = (simWeapon != action.weaponId) ? 1 : 0
                        var weaponCost = weaponObj._cost
                        var weaponDmg = this._arsenal.getNetDamageAgainstTarget(simStrength, simMagic, simWisdom, simScience, action.weaponId, this._target)
                        var weaponBreakdown = this._arsenal.getDamageBreakdown(simStrength, simMagic, simWisdom, simScience, action.weaponId)

                        var directDmg = weaponBreakdown['direct']
                        result.damageDealt += directDmg
                        simEnemyCurrHP -= directDmg
                        if (simEnemyCurrHP < 0) simEnemyCurrHP = 0

                        // Calculate lifesteal healing
                        var lifesteal = (directDmg * simWisdom) / 1000
                        result.lifestealHealing += lifesteal

                        // ENHANCED_LIGHTNINGER bonus: +100 HP healing
                        if (action.weaponId == WEAPON_ENHANCED_LIGHTNINGER) {
                            result.lifestealHealing += 100
                        }

                        // Track bulb vs leek damage
                        if (targetIsBulb) {
                            result.bulbDamage += directDmg
                        } else {
                            result.leekDamage += directDmg
                        }

                        result.dotDamageQueued += weaponBreakdown['dot']

                        var hpDeficit = simEnemyMaxHP - simEnemyCurrHP
                        var uncappedNova = weaponBreakdown['nova']
                        var cappedNova = uncappedNova
                        if (hpDeficit < uncappedNova) {
                            cappedNova = hpDeficit
                        }
                        var currentNova = result.novaDamageQueued != null ? result.novaDamageQueued : 0
                        result.novaDamageQueued = currentNova + cappedNova

                        simEnemyMaxHP -= cappedNova
                        if (simEnemyMaxHP < simEnemyCurrHP) simEnemyMaxHP = simEnemyCurrHP

                        result.tpSpent += swapCost + weaponCost
                        simTP -= swapCost + weaponCost
                        simWeapon = action.weaponId
                        simWeaponUses[action.weaponId] = currentUses + 1

                        if (action.weaponId == WEAPON_NEUTRINO) {
                            result.vulnerabilityApplied += 8  
                        } else if (action.weaponId == WEAPON_HEAVY_SWORD) {
                            result.vulnerabilityApplied += 60  
                        }

                        result.actionsExecuted++
                    }
                }
            }
            else if (action.type == Action.ACTION_BUFF) {

                var buffCost = getChipCost(action.chip)
                result.tpSpent += buffCost
                simTP -= buffCost
                push(result.buffsApplied, action.chip)

                if (action.chip == CHIP_HELMET || action.chip == CHIP_SHIELD) {
                    // Absolute shields (flat HP reduction)
                    var shieldAmount = this.estimateShieldAmount(action.chip, simWisdom)
                    result.shieldsGained += shieldAmount
                } else if (action.chip == CHIP_WALL || action.chip == CHIP_FORTRESS) {
                    // Relative shields (percentage damage reduction)
                    var relShieldPercent = this.estimateRelativeShield(action.chip)
                    result.relativeShieldGained += relShieldPercent
                } else if (action.chip == CHIP_PROTEIN) {
                    result.relativeShieldGained += this.estimateRelativeShield(action.chip)
                } else if (action.chip == CHIP_LEATHER_BOOTS) {
                    result.relativeShieldGained += this.estimateRelativeShield(action.chip)
                    simMP += 2
                } else if (action.chip == CHIP_REGENERATION || action.chip == CHIP_REMISSION || action.chip == CHIP_CURE || action.chip == CHIP_DRIP) {
                    result.hpGained += this.estimateHealing(action.chip, simWisdom)
                } else if (action.chip == CHIP_STEROID || action.chip == CHIP_DOPING) {

                    simStrength += this.estimateStrengthBuff(action.chip)
                } else if (action.chip == CHIP_PRISM) {
                    // PRISM: +60 all stats (STR, MAG, WIS, SCI, AGI, RES)
                    simStrength += 60
                    simMagic += 60
                    simWisdom += 60
                    simScience += 60
                } else if (action.chip == CHIP_WIZARDRY) {
                    // WIZARDRY: +150-170 Magic for 2 turns (avg 160)
                    simMagic += 160
                } else if (action.chip == CHIP_KNOWLEDGE) {
                    // KNOWLEDGE: +250-270 Wisdom for 2 turns (avg 260)
                    simWisdom += 260
                } else if (action.chip == CHIP_ELEVATION) {
                    // ELEVATION: +80 Max HP (one-time, also heals)
                    result.hpGained += 80
                } else if (action.chip == CHIP_WARM_UP) {

                } else if (action.chip == CHIP_ADRENALINE) {

                    simTP += 5
                } else if (action.chip == CHIP_MIRROR || action.chip == CHIP_THORN || action.chip == CHIP_BRAMBLE) {
                    // Damage return buffs (tracked for scoring, not simulated in combat)
                    // No simulation changes needed - these are defensive passives
                }

                result.actionsExecuted++
            }
            else if (action.type == Action.ACTION_WEAPON_SWAP) {
                if (mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                    var swapCost = 1
                    result.tpSpent += swapCost
                    simTP -= swapCost
                    simWeapon = action.weaponId
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.MOVEMENT_APPROACH || action.type == Action.MOVEMENT_OFFENSIVE ||
                     action.type == Action.MOVEMENT_DEFENSIVE || action.type == Action.MOVEMENT_OTKO ||
                     action.type == Action.MOVEMENT_DOT_OFFENSIVE || action.type == Action.MOVEMENT_DEBUFF ||
                     action.type == Action.MOVEMENT_HNS || action.type == Action.MOVEMENT_PAB) {
                
                var pathLength = getCachedPathLength(simPos, action.targetCell)
                if (pathLength != null && pathLength <= simMP) {
                    result.mpSpent += pathLength
                    simMP -= pathLength
                    simPos = action.targetCell
                    result.finalPosition = simPos
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.MOVEMENT_FLEE) {
                
                var estimatedMP = min(simMP, 3)  
                result.mpSpent += estimatedMP
                simMP -= estimatedMP
                result.actionsExecuted++
            }
            else if (action.type == Action.ACTION_TELEPORT) {
                var tpCost = getChipCost(CHIP_TELEPORTATION)
                var dist = getCellDistance(simPos, action.targetCell)
                if (dist != null && dist >= 1 && dist <= 12 && simTP >= tpCost) {
                    result.tpSpent += tpCost
                    simTP -= tpCost
                    simPos = action.targetCell
                    result.finalPosition = simPos
                    result.actionsExecuted++
                }
            }
            else if (action.type == Action.ACTION_CHECKPOINT) {
                
                result.actionsExecuted++
                
            }
        }

        // Track bulb targeting metrics
        if (targetIsBulb && result.bulbDamage > 0) {
            result.bulbsHit = 1

            // Estimate if we secured a bulb kill
            var totalDamageToTarget = result.damageDealt + result.dotDamageQueued + (result.novaDamageQueued != null ? result.novaDamageQueued : 0)
            if (totalDamageToTarget >= simEnemyCurrHP) {
                result.bulbKillsSecured = 1
            }
        }

        return result
    }

    canExecuteAction(action, simPos, simTP, simMP, simWeapon) {
        if (action.type == Action.ACTION_DIRECT || action.type == Action.ACTION_DOT ||
            action.type == Action.ACTION_DEBUFF || action.type == Action.ACTION_BUFF) {
            if (action.chip != -1) {
                var cost = getChipCost(action.chip)
                return simTP >= cost
            } else if (action.weaponId != -1) {
                    var weaponCost = null
                    if (mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                        var weaponObj = this._arsenal.playerEquippedWeapons[action.weaponId]
                        weaponCost = weaponObj._cost
                    }
                if (weaponCost == null) return false
                var swapCost = (simWeapon != action.weaponId) ? 1 : 0
                return simTP >= swapCost + weaponCost
            }
        }
        else if (action.type == Action.ACTION_WEAPON_SWAP) {
            if (!mapContainsKey(this._arsenal.playerEquippedWeapons, action.weaponId)) {
                return false
            }
            return simTP >= 1
        }
        else if (action.type == Action.MOVEMENT_APPROACH || action.type == Action.MOVEMENT_OFFENSIVE ||
                 action.type == Action.MOVEMENT_DEFENSIVE || action.type == Action.MOVEMENT_OTKO ||
                 action.type == Action.MOVEMENT_DOT_OFFENSIVE || action.type == Action.MOVEMENT_DEBUFF ||
                 action.type == Action.MOVEMENT_HNS || action.type == Action.MOVEMENT_PAB) {
            var pathLength = getCachedPathLength(simPos, action.targetCell)
            return pathLength != null && pathLength <= simMP
        }
        else if (action.type == Action.MOVEMENT_FLEE) {
            return simMP >= 1  
        }
        else if (action.type == Action.ACTION_TELEPORT) {
            var tpCost = getChipCost(CHIP_TELEPORTATION)
            return simTP >= tpCost
        }

        return true
    }

    estimateShieldAmount(chip, wisdom) {
        // Absolute shields only (flat HP reduction)
        if (!isAbsoluteShieldChip(chip)) return 0
        if (chip == CHIP_HELMET) return 50 + wisdom * 0.5
        if (chip == CHIP_SHIELD) return 100 + wisdom * 1.0
        return 0
    }

    estimateRelativeShield(chip) {
        // Relative shields (percentage damage reduction, scales with Resistance)
        if (!isRelativeShieldChip(chip)) return 0

        var resistance = this._player._resistance
        var scalingMultiplier = 1 + (resistance / 100.0)

        if (chip == CHIP_WALL) {
            var basePercent = 4.5  // 4-5% base at max level
            return basePercent * scalingMultiplier
        }
        if (chip == CHIP_FORTRESS) {
            var basePercent = 7.5  // 7-8% base at max level
            return basePercent * scalingMultiplier
        }
        if (chip == CHIP_PROTEIN) {
            return 10  // Fixed 10% (does not scale)
        }
        if (chip == CHIP_LEATHER_BOOTS) {
            return 20  // Fixed 20% (does not scale)
        }
        return 0
    }

    estimateHealing(chip, wisdom) {
        if (isHealingChip(chip)) {
            return arsenal.getExpectedHeal(chip, wisdom)
        }
        return 0
    }

    estimateStrengthBuff(chip) {
        if (!isOffensiveBuff(chip)) return 0
        if (chip == CHIP_STEROID) return 100
        if (chip == CHIP_DOPING) return 50
        return 0
    }
}
