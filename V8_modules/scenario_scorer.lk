include('game_entity.lk')
include('cooldown_tracker.lk')

class ScenarioScorer {
    _player = null
    _target = null
    _fieldMap = null
    _weights = null

    constructor(player, target, fieldMap, weights) {
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
        this._weights = weights != null ? weights : [:]
    }

    getWeight(key, defaultValue) {
        if (mapContainsKey(this._weights, key)) {
            return this._weights[key]
        }
        return defaultValue
    }

    score(simResult, scenario) {
        var score = 0

        var enemyHP = this._target._currHealth
        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg
        var killProbability = totalDamage / enemyHP

        // Bulb detection and classification
        var targetIsBulb = isBulb(this._target)
        var bulbType = targetIsBulb ? getBulbType(this._target) : BULB_TYPE_UNKNOWN

        // Battle Royale mode: prioritize total lobby damage over single-target damage
        var isBattleRoyale = (getFightType() == FIGHT_TYPE_BATTLE_ROYALE)
        var effectiveDamage = totalDamage
        if (isBattleRoyale && simResult.totalLobbyDamage > 0) {
            effectiveDamage = simResult.totalLobbyDamage
        }

        // Bulb Race Clock: decide whether to kill bulbs or race to kill summoner
        var bulbRaceState = "BULB_CLEAR"  // Default: kill bulbs
        if (targetIsBulb) {
            // Find the main enemy (non-bulb, the summoner) from enemy submap
            var enemies = this._fieldMap.getEnemySubMap()
            var summonerHP = 0
            for (var eid in mapKeys(enemies)) {
                if (!isDead(eid) && !isBulb(enemies[eid])) {
                    summonerHP = enemies[eid]._currHealth
                    break
                }
            }

            if (summonerHP > 0) {
                var playerDPS = max(1, this._player._strength + this._player._magic)
                var turnsToKill = summonerHP / playerDPS

                // Estimate enemy DPS from threat at our position
                var playerPos = this._player._cellPos
                var enemyDPS = max(1, this._fieldMap.getThreatAtCell(playerPos))
                var bulbDamagePerTurn = 50  // Estimate: bulb chip/attack adds ~50/turn
                var turnsTodie = this._player._currHealth / (enemyDPS + bulbDamagePerTurn)

                if (turnsToKill < turnsTodie) {
                    bulbRaceState = "RACE"  // Ignore bulbs, rush summoner
                }
            }
        }

        // Bulb damage multiplier: configurable via weights
        var bulbDamageMultiplier = 1.0
        if (targetIsBulb) {
            if (bulbRaceState == "RACE") {
                bulbDamageMultiplier = 0.3  // De-prioritize bulb damage in race mode
            } else {
                bulbDamageMultiplier = this.getWeight('bulbDamageMultiplier', 1.2)
            }
        }

        var damageWeight = this.getWeight('burstDamage', this.calculateDamageWeight())

        if (killProbability >= 0.70) {
            damageWeight *= 5.0
        } else if (killProbability >= 0.50) {
            damageWeight *= 2.5
        }

        // Kill-Reserve: penalize scenarios that waste TP on buffs when kill is near
        if (killProbability >= 0.85 && killProbability < 1.1 && scenario != null && count(scenario) > 0) {
            var buffCount = 0
            var attackCount = 0
            for (var action in scenario) {
                if (action.type == Action.ACTION_BUFF) buffCount++
                if (action.type == Action.ACTION_DIRECT || action.type == Action.ACTION_DOT) attackCount++
            }
            // Too many buffs, not enough attacks when kill is close
            if (buffCount > 1 && attackCount < 2) {
                score -= 800 * buffCount
            }
        }

        // Apply bulb damage multiplier
        var damageScore = effectiveDamage * damageWeight * bulbDamageMultiplier
        score += damageScore

        // Lifesteal healing bonus: Use pre-calculated healing from simulator
        // (includes ENHANCED_LIGHTNINGER +100 HP bonus)
        var lifestealHealing = simResult.lifestealHealing
        if (lifestealHealing > 0) {
            // Bonus scaling: lifesteal is valuable when HP is low
            var hpPercent = (this._player._currHealth * 100) / this._player._maxHealth
            var lifestealMultiplier = 1.0
            if (hpPercent < 50) {
                lifestealMultiplier = 2.0  // Double value when HP < 50%
            } else if (hpPercent < 70) {
                lifestealMultiplier = 1.5  // 1.5x value when HP < 70%
            }
            var lifestealScore = lifestealHealing * lifestealMultiplier * 2.0  // Base multiplier
            score += lifestealScore
        }

        // Bulb kill bonus: massive score for killing high-value bulbs (configurable via weights)
        var bulbKillBonus = 0
        if (targetIsBulb && killProbability >= 0.70) {
            if (bulbType == BULB_TYPE_HEALER) {
                bulbKillBonus = this.getWeight('bulbKillBonusHealer', 2500)
            } else if (bulbType == BULB_TYPE_BUFFER) {
                bulbKillBonus = this.getWeight('bulbKillBonusBuffer', 1500)
            } else if (bulbType == BULB_TYPE_ATTACKER) {
                bulbKillBonus = this.getWeight('bulbKillBonusAttacker', 800)
            }
        }
        score += bulbKillBonus

        // Battle Royale: massive bonus for reducing lobby size (any kill)
        if (isBattleRoyale && simResult.killsSecured > 0) {
            var lobbySizeBonus = simResult.killsSecured * 5000
            score += lobbySizeBonus
        }

        // Battle Royale: bonus for hitting multiple enemies with AoE
        if (isBattleRoyale && simResult.enemiesHit >= 2) {
            var aoeBonus = (simResult.enemiesHit - 1) * 1000
            score += aoeBonus
        }

        var playerHPPercent = (this._player._currHealth * 100) / this._player._maxHealth
        if (totalDamage == 0 && playerHPPercent > 30) {
            var currentTurn = getTurn()
            var noDamagePenalty = this.getWeight('noDamagePenalty', -2000)

            // Reduce penalty for early turns (turn 1-3) when positioning is expected
            if (currentTurn <= 3) {
                noDamagePenalty = noDamagePenalty / 4  // -500 instead of -2000
            } else if (currentTurn >= 5) {
                // Increase penalty on later turns - standing still dealing 0 damage
                // must not be masked by shield/buff value
                noDamagePenalty = noDamagePenalty * 3  // -6000 on turn 5+
            }

            score += noDamagePenalty
        }

        var dotWeight = this.getWeight('dotEffects', this.calculateDotWeight())

        // Dynamic DoT weight: scale by Antidote availability
        var antidoteMultiplier = this.calculateAntidoteMultiplier()
        var adjustedDotWeight = dotWeight * antidoteMultiplier

        var dotScore = simResult.dotDamageQueued * adjustedDotWeight
        score += dotScore

        if (dotScore > 0 && antidoteMultiplier != 1.0) {
            // Antidote multiplier applied
        }

        var novaWeight = this.getWeight('novaEffects', (dotWeight + damageWeight) / 2.0)
        var novaDamageQueued = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var novaScore = novaDamageQueued * novaWeight
        score += novaScore
        if (novaScore > 0) {
        }

        var ehpWeight = this.calculateEhpWeight()
        var shieldScore = simResult.shieldsGained * ehpWeight
        var relShieldScore = this.calculateRelativeShieldValue(simResult.relativeShieldGained) * ehpWeight

        // Healing score: Penalize for low wisdom builds (agility/strength)
        var wisdom = this._player._wisdom
        var wisdomMultiplier = 1.0
        if (wisdom < 200) {
            // Low wisdom: healing is 50% effective
            wisdomMultiplier = 0.5
        } else if (wisdom < 400) {
            // Medium wisdom: healing is 75% effective
            wisdomMultiplier = 0.75
        }
        // High wisdom (>=400): full healing value (multiplier = 1.0)

        var healScore = simResult.hpGained * ehpWeight * wisdomMultiplier

        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP
        var healingUrgencyBonus = 0
        if (simResult.hpGained > 0) {
            if (hpRatio < 0.3) healingUrgencyBonus = simResult.hpGained * 3.0 * wisdomMultiplier
            else if (hpRatio < 0.5) healingUrgencyBonus = simResult.hpGained * 1.5 * wisdomMultiplier
            else if (hpRatio < 0.8) healingUrgencyBonus = simResult.hpGained * 0.5 * wisdomMultiplier
        }

        score += shieldScore + relShieldScore + healScore + healingUrgencyBonus

        var positionWeight = this.calculatePositionWeight()
        var positionScore = this.evaluatePosition(simResult.finalPosition) * positionWeight
        score += positionScore

        var efficiencyWeight = this.getWeight('tpEfficiency', this.calculateEfficiencyWeight())
        var efficiencyScore = this.calculateEfficiency(simResult) * efficiencyWeight
        score += efficiencyScore

        var buffWeight = this.getWeight('buffs', this.calculateBuffWeight())
        var buffScore = this.evaluateBuffs(simResult.buffsApplied, simResult) * buffWeight
        var debuffScore = this.evaluateDebuffs(simResult.debuffsApplied) * buffWeight
        score += buffScore + debuffScore

        var critBonus = this.calculateCritBonus(simResult.damageDealt)
        score += critBonus

        var otkoBonus = 0
        var finalPos = simResult.finalPosition
        if (finalPos != -1 && mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cell = this._fieldMap.damageMap[finalPos]
            if (cell._isOTKOCell) {
                otkoBonus = this.getWeight('otkoBonus', 5000)
            }
        }
        score += otkoBonus

        var checkpointBonus = 0
        var poisonDumpBonus = 0
        if (scenario != null && count(scenario) > 0) {
            for (var action in scenario) {
                if (action.type == 15) {
                    if (action.checkpointType == "POISON_DUMP") {
                        // Poison dump scenario - ALWAYS prioritize (must-use at all cost)
                        poisonDumpBonus = 10000  // Massive bonus to guarantee selection
                    } else {
                        checkpointBonus = this.getWeight('checkpointBonus', 2500)
                    }
                    break
                }
            }
        }
        score += checkpointBonus + poisonDumpBonus

        // Synergy matrix: bonus for recognized combo patterns in the scenario
        var synergyBonus = this.evaluateSynergyBonus(scenario)
        score += synergyBonus

        // WEAPON_DESTROYER synergy: bonus when shredding high-Strength enemies
        var destroyerBonus = 0
        if (scenario != null && count(scenario) > 0 && this._target._strength > 150) {
            var destroyerUses = 0
            for (var action in scenario) {
                if (action.weaponId == WEAPON_DESTROYER) {
                    destroyerUses++
                }
            }
            if (destroyerUses > 0) {
                // Each use applies -17 STR debuff (stackable), protecting player from counterattacks
                destroyerBonus = destroyerUses * 400
            }
        }
        score += destroyerBonus

        // Battle Royale: Center avoidance penalty (EARLY phase only)
        var centerPenalty = 0
        if (isBattleRoyale) {
            var aliveEnemies = getAliveEnemies()
            var enemyCount = count(aliveEnemies)

            if (enemyCount > 4) {
                // EARLY PHASE: Penalize moving toward center
                var centerCell = getCellFromXY(0, 0)  // Map center at (0, 0)
                if (centerCell != null && simResult.finalPosition != -1) {
                    var currentDistToCenter = getCellDistance(this._player._cellPos, centerCell)
                    var finalDistToCenter = getCellDistance(simResult.finalPosition, centerCell)

                    if (finalDistToCenter != null && currentDistToCenter != null) {
                        if (finalDistToCenter < currentDistToCenter) {
                            // Moving closer to center = bad
                            var movementTowardCenter = currentDistToCenter - finalDistToCenter
                            centerPenalty = movementTowardCenter * 150  // Heavy penalty
                        }
                    }
                }
                score -= centerPenalty
            }
        }

        var survivalMultiplier = 1.0
        if (simResult.hpGained > 0) {
            var playerPos = this._player._cellPos
            var threatAtPos = this._fieldMap.getThreatAtCell(playerPos)
            var hasShield = this._player.hasEffect(EFFECT_ABSOLUTE_SHIELD) || this._player.hasEffect(EFFECT_RELATIVE_SHIELD)

            if (hpRatio < 0.45 && (threatAtPos > 800 || !hasShield)) {
                if (hpRatio < 0.30) {
                    survivalMultiplier = 50.0
                } else if (hpRatio < 0.40) {
                    survivalMultiplier = 25.0
                } else {
                    survivalMultiplier = 10.0
                }
            }
        }

        score *= survivalMultiplier

        // Debug: Score breakdown removed for compilation

        return score
    }

    calculateDamageWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (str > mag && str > agi) {
            return 3.0 + (str / 500.0)  
        }
        
        else if (mag > str && mag > agi) {
            return 1.6 + (mag / 1000.0)
        }
        
        else if (agi > str && agi > mag) {
            return 2.6 + (agi / 750.0)
        }

        return 2.0  
    }

    calculateDotWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (mag > str && mag > agi) {
            return 2.0 + (mag / 1000.0)
        }

        return 0.3
    }

    calculateAntidoteMultiplier() {
        // Calculate DoT value multiplier based on enemy Antidote cooldown status
        var enemyId = this._target._id
        var tracker = new CooldownTracker(this._target)
        var antidoteCd = tracker.getCooldownRemaining(enemyId, CooldownTracker.CHIP_ANTIDOTE)

        if (antidoteCd == 0) {
            // Antidote READY → enemy will cleanse next turn
            // Use cheap poison to bait (Venom, Toxin, Gazor)
            return 0.2
        } else if (antidoteCd == 1) {
            // 1 turn remaining → light poison OK
            return 1.7
        } else if (antidoteCd == 2) {
            // 2 turns remaining → medium investment
            return 1.9
        } else if (antidoteCd >= 3) {
            // 3+ turns remaining → full dump window
            return 2.1 + (antidoteCd * 0.2)
        }

        // Default: no tracking data → assume Antidote available
        return 1.0
    }

    calculateEhpWeight() {
        var resistance = this._player._resistance
        var wisdom = this._player._wisdom
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth

        var hpRatio = currentHP / maxHP
        var urgencyMultiplier = 1.0
        if (hpRatio < 0.3) urgencyMultiplier = 5.0
        else if (hpRatio < 0.5) urgencyMultiplier = 3.5
        else if (hpRatio < 0.7) urgencyMultiplier = 2.0
        else if (hpRatio < 0.8) urgencyMultiplier = 1.3

        var baseWeight = 0.5 + (resistance / 500.0) + (wisdom / 1000.0)

        var knowledgeActive = (getCooldown(CHIP_KNOWLEDGE, this._player._id) > 0)
        var elevationActive = (getCooldown(CHIP_ELEVATION, this._player._id) > 0)

        if (knowledgeActive || elevationActive) {
            baseWeight *= 1.5
        }

        var playerPos = this._player._cellPos
        var threatAtPos = this._fieldMap.getThreatAtCell(playerPos)
        if (threatAtPos > 200) {
            urgencyMultiplier *= 1.5
        }

        return baseWeight * urgencyMultiplier
    }

    calculatePositionWeight() {
        var agi = this._player._agility
        var str = this._player._strength
        var mag = this._player._magic

        if (agi > str && agi > mag) {
            return 0.8 + (agi / 1000.0)
        }
        
        else if (mag > str && mag > agi) {
            return 0.5 + (mag / 2000.0)
        }
        
        return 0.2
    }

    calculateEfficiencyWeight() {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var targetHP = this._target._currHealth

        var fightLengthEstimate = targetHP / max(1, this._player._strength + this._player._magic)

        if (fightLengthEstimate > 3) return 0.3  
        else if (fightLengthEstimate > 1.5) return 0.15  
        return 0.05  
    }

    calculateBuffWeight() {
        return 2.0  
    }

    evaluatePosition(finalPos) {
        if (finalPos == -1 || finalPos == this._player._cellPos) return 0

        var offensiveValue = 0
        if (mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cellObj = this._fieldMap.damageMap[finalPos]
            offensiveValue = cellObj._totalDamage
        }

        var distToTarget = getCellDistance(finalPos, this._target._cellPos)
        var kitingValue = 0
        if (distToTarget != null) {
            // Check if we're out of all attack range (damageMap empty = no cells in range)
            var outOfRange = (count(mapKeys(this._fieldMap.damageMap)) == 0)

            if (outOfRange) {
                // Out of range: reward approaching (closer = better) for ALL builds
                var currentDist = getCellDistance(this._player._cellPos, this._target._cellPos)
                if (currentDist != null && distToTarget < currentDist) {
                    kitingValue = (currentDist - distToTarget) * 50  // Strong approach bonus
                }
            } else if (this._player._magic > this._player._strength) {
                kitingValue = distToTarget * 10
            } else {
                kitingValue = max(0, (10 - distToTarget)) * 10
            }
        }

        var threatPenalty = 0
        var threatAtPos = this._fieldMap.getThreatAtCell(finalPos)

        var hpPercent = (this._player._currHealth * 100) / this._player._maxHealth

        if (threatAtPos > 0) {
            threatPenalty = -threatAtPos * 0.5

            if (hpPercent < 50) {
                threatPenalty *= 2.0
            }
        }

        // HNS: Threat-aware cover bonus for cells that break LoS to enemies
        var coverBonus = 0
        var enemies = this._fieldMap.getEnemySubMap()
        var exposureCount = 0
        for (var eid in mapKeys(enemies)) {
            if (!isDead(eid)) {
                var enemyCell = enemies[eid]._cellPos
                if (enemyCell != null && lineOfSight(finalPos, enemyCell)) {
                    exposureCount++
                }
            }
        }

        // Reward cover: fewer enemies with LoS = better
        var totalEnemies = count(mapKeys(enemies))
        if (totalEnemies > 0 && exposureCount < totalEnemies) {
            var coverRatio = 1.0 - (exposureCount / totalEnemies)
            // Weight tuning by HP: low HP values cover much more
            var W1  // Threat weight
            var W2  // Exposure weight
            if (hpPercent < 40) {
                W1 = 3.0
                W2 = 2.0
            } else if (hpPercent < 70) {
                W1 = 2.0
                W2 = 1.5
            } else {
                W1 = 1.0
                W2 = 1.0
            }
            coverBonus = (coverRatio * W2 * 200) + (max(0, threatAtPos) * coverRatio * W1 * 0.3)
        }

        // Full cover (0 exposure) gets flat bonus
        if (exposureCount == 0 && totalEnemies > 0) {
            coverBonus += 400
        }

        var totalScore = offensiveValue + kitingValue + threatPenalty + coverBonus
        return totalScore
    }

    calculateEfficiency(simResult) {
        var tpEfficiency = 0
        var mpEfficiency = 0

        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg

        var healingTPCost = 0
        for (var buff in simResult.buffsApplied) {
            if (isHealingChip(buff)) healingTPCost += getCachedChipCost(buff)
        }

        var offensiveTPSpent = simResult.tpSpent - healingTPCost
        if (offensiveTPSpent < 0) offensiveTPSpent = 0

        if (offensiveTPSpent > 0 && totalDamage > 0) {
            var damagePerTP = totalDamage / offensiveTPSpent
            tpEfficiency = damagePerTP * 10
        }

        if (simResult.mpSpent > 0 && totalDamage > 0) {
            var damagePerMP = totalDamage / simResult.mpSpent
            mpEfficiency = damagePerMP * 5
        }

        return tpEfficiency + mpEfficiency
    }

    evaluateBuffs(buffsApplied, simResult) {
        var value = 0

        // Estimate expected incoming damage for defensive buff valuation
        var playerPos = simResult.finalPosition != -1 ? simResult.finalPosition : this._player._cellPos
        var expectedDamage = this._fieldMap.getThreatAtCell(playerPos)
        if (expectedDamage == null || expectedDamage < 0) expectedDamage = 0

        // Kill margin check: reduce buff value if kill is guaranteed
        var enemyHP = this._target._currHealth
        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg
        var killMargin = totalDamage / enemyHP
        var buffMultiplier = 1.0

        if (killMargin >= 1.1) {
            // Kill is guaranteed with 10% safety margin - heavily de-prioritize buffs
            buffMultiplier = 0.1
        } else if (killMargin < 0.7 && expectedDamage > 200) {
            // No kill possible + high threat - force buffs
            buffMultiplier = 5.0
        }

        for (var buffChip in buffsApplied) {

            // Offensive buffs: fixed values (not threat-dependent)
            if (buffChip == CHIP_STEROID) value += 200
            if (buffChip == CHIP_DOPING) value += 100
            if (buffChip == CHIP_WARM_UP) value += 150
            if (buffChip == CHIP_WIZARDRY) value += 200  // MAG offensive buff
            if (buffChip == CHIP_KNOWLEDGE) value += 150  // WIS buff (healing power)
            if (buffChip == CHIP_ELEVATION) value += 120  // RES buff (damage reduction)
            if (buffChip == CHIP_PRISM) value += 180  // +60 all stats, strong universal buff
            if (buffChip == CHIP_ADRENALINE) value += 100

            // Absolute shield buffs: flat HP value
            if (isAbsoluteShieldChip(buffChip)) {
                value += 80  // Base value
            }

            if (buffChip == CHIP_WALL) {
                // Relative shield: scales with Resistance
                var resistance = this._player._resistance
                var reductionPercent = 4.5 * (1 + resistance / 100.0)
                var duration = 2  // 2 turns
                var effectiveHP = (expectedDamage * duration) * (reductionPercent / 100.0)
                var wallValue = effectiveHP * 0.5  // Scale down to reasonable scorer range
                if (wallValue < 80) wallValue = 80  // Minimum value
                value += wallValue
            }

            if (buffChip == CHIP_FORTRESS) {
                // Relative shield: scales with Resistance
                var resistance = this._player._resistance
                var reductionPercent = 7.5 * (1 + resistance / 100.0)
                var duration = 3  // 3 turns
                var effectiveHP = (expectedDamage * duration) * (reductionPercent / 100.0)
                var fortressValue = effectiveHP * 0.5  // Scale down to reasonable scorer range
                if (fortressValue < 150) fortressValue = 150  // Minimum value
                value += fortressValue
            }

            if (isRelativeShieldChip(buffChip) && buffChip != CHIP_WALL && buffChip != CHIP_FORTRESS) value += 100

            // Healing buffs: fixed values
            if (buffChip == CHIP_REGENERATION) value += 80
            if (buffChip == CHIP_CURE) value += 120
            if (buffChip == CHIP_DRIP) value += 100
            if (buffChip == CHIP_LIBERATION) value += 120
            if (buffChip == CHIP_REMISSION) value += 100

            // Damage return buffs: dynamic threat-aware valuation
            if (buffChip == CHIP_MIRROR) {
                var agility = this._player._agility
                var returnPercent = 5.5 * (1 + agility / 100.0)
                var duration = 3  // 3 turns
                var returnDamage = (expectedDamage * duration) * (returnPercent / 100.0)
                var mirrorValue = returnDamage * 0.8  // Scale down to reasonable scorer range
                if (mirrorValue < 100) mirrorValue = 100  // Minimum value
                value += mirrorValue
            }

            if (buffChip == CHIP_THORN) {
                var agility = this._player._agility
                var returnPercent = 3.5 * (1 + agility / 100.0)
                var duration = 2  // 2 turns
                var returnDamage = (expectedDamage * duration) * (returnPercent / 100.0)
                var thornValue = returnDamage * 0.8  // Scale down to reasonable scorer range
                if (thornValue < 80) thornValue = 80  // Minimum value
                value += thornValue
            }

            if (buffChip == CHIP_BRAMBLE) {
                // BRAMBLE: Tactical burst only (1 turn, 25% return, 8 turn cooldown)
                var agility = this._player._agility
                var returnPercent = 25.0 * (1 + agility / 100.0)
                var duration = 1  // 1 turn only
                var returnDamage = expectedDamage * (returnPercent / 100.0)

                // Only valuable in high-threat scenarios
                var brambleValue = 0
                if (expectedDamage > 300) {
                    brambleValue = returnDamage * 1.5  // Higher multiplier for burst value
                } else {
                    brambleValue = 50  // Minimal value if no threat (discourage usage)
                }

                value += brambleValue
            }
        }

        // Apply kill margin multiplier to ALL buff values
        value *= buffMultiplier

        return value
    }

    evaluateDebuffs(debuffsApplied) {
        var value = 0

        for (var debuffChip in debuffsApplied) {
            if (isPoisonChip(debuffChip)) value += 100
            if (debuffChip == CHIP_STALACTITE || debuffChip == CHIP_ICEBERG) value += 120
            if (debuffChip == CHIP_ARMOR || debuffChip == CHIP_SOLIDIFICATION) value += 150
            if (debuffChip == CHIP_SLOW_DOWN || debuffChip == CHIP_BALL_AND_CHAIN) value += 80
        }

        return value
    }

    calculateCritBonus(damageDealt) {
        var agi = this._player._agility

        if (agi > this._player._strength && agi > this._player._magic) {
            var critChance = min(0.5, agi / 2000.0)  
            var critMultiplier = 1.3
            var expectedCritBonus = damageDealt * critChance * (critMultiplier - 1.0)
            return expectedCritBonus * 0.5  
        }

        return 0
    }

    calculateRelativeShieldValue(relativeShieldPercent) {
        var maxHP = this._player._maxHealth
        return (relativeShieldPercent / 100.0) * maxHP
    }

    evaluateSynergyBonus(scenario) {
        if (scenario == null || count(scenario) == 0) return 0

        var bonus = 0
        var hasGrapple = false
        var hasMelee = false      // HEAVY_SWORD or close-range weapon
        var hasWizardry = false
        var hasPoison = false
        var hasTeleport = false
        var hasSteroid = false
        var hasNeutrino = false
        var hasPrism = false
        var hasNova = false
        var hasShield = false
        var hasDenial = false     // Soporific, Ball and Chain

        for (var action in scenario) {
            if (action.chip == CHIP_GRAPPLE) hasGrapple = true
            if (action.chip == CHIP_WIZARDRY) hasWizardry = true
            if (action.chip == CHIP_STEROID) hasSteroid = true
            if (action.chip == CHIP_TELEPORTATION) hasTeleport = true
            if (action.chip == CHIP_PRISM) hasPrism = true
            if (action.chip == CHIP_FORTRESS || action.chip == CHIP_WALL) hasShield = true
            if (action.chip == CHIP_SOPORIFIC || action.chip == CHIP_BALL_AND_CHAIN) hasDenial = true
            if (action.weaponId == WEAPON_HEAVY_SWORD) hasMelee = true
            if (action.weaponId == WEAPON_NEUTRINO) hasNeutrino = true
            if (action.chip != -1 && isPoisonChip(action.chip)) hasPoison = true
            if (action.type == Action.ACTION_DOT) hasPoison = true
        }

        // Grapple + Melee: pull enemy in + heavy strike
        if (hasGrapple && hasMelee) bonus += 300

        // Wizardry + Poison: magic buff amplifies DoT
        if (hasWizardry && hasPoison) bonus += 400

        // Wizardry + Denial: magic buff amplifies TP/MP removal
        if (hasWizardry && hasDenial) bonus += 350

        // Steroid + Teleport: buff then gap-close for OTKO
        if (hasSteroid && hasTeleport) bonus += 250

        // Grapple + Neutrino: pull + multi-hit
        if (hasGrapple && hasNeutrino) bonus += 200

        // Wizardry + Neutrino: magic buff + magic weapon
        if (hasWizardry && hasNeutrino) bonus += 350

        // Prism + Shield: all-stat buff with tank sustain
        if (hasPrism && hasShield) bonus += 300

        // Poison + Denial: poison stacking + enemy can't act
        if (hasPoison && hasDenial) bonus += 300

        return bonus
    }
}
