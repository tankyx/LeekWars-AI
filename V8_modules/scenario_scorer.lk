
class ScenarioScorer {
    _player = null
    _target = null
    _fieldMap = null
    _weights = null

    constructor(player, target, fieldMap, weights) {
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
        this._weights = weights != null ? weights : [:]
    }

    getWeight(key, defaultValue) {
        if (mapContainsKey(this._weights, key)) {
            return this._weights[key]
        }
        return defaultValue
    }

    score(simResult, scenario) {
        var score = 0

        var enemyHP = this._target._currHealth
        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg
        var killProbability = totalDamage / enemyHP

        var damageWeight = this.getWeight('burstDamage', this.calculateDamageWeight())

        if (killProbability >= 0.70) {
            damageWeight *= 5.0
            debug("[SCORER-BOOST] Kill opportunity: dmg=" + floor(totalDamage) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 5x damage weight")
        } else if (killProbability >= 0.50) {
            damageWeight *= 2.5
            debug("[SCORER-BOOST] Near-kill: dmg=" + floor(totalDamage) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 2.5x damage weight")
        }

        var damageScore = simResult.damageDealt * damageWeight
        score += damageScore

        var playerHPPercent = (this._player._currHealth * 100) / this._player._maxHealth
        if (totalDamage == 0 && playerHPPercent > 30) {
            var currentTurn = getTurn()
            var noDamagePenalty = this.getWeight('noDamagePenalty', -2000)

            // Reduce penalty for early turns (turn 1-3) when positioning is expected
            if (currentTurn <= 3) {
                noDamagePenalty = noDamagePenalty / 4  // -500 instead of -2000
                debug("[SCORER-PENALTY] No damage dealt (early turn " + currentTurn + ") - reduced penalty: " + noDamagePenalty)
            } else {
                debug("[SCORER-PENALTY] No damage dealt (turn " + currentTurn + ") - full penalty: " + noDamagePenalty)
            }

            score += noDamagePenalty
        }

        var dotWeight = this.getWeight('dotEffects', this.calculateDotWeight())
        var dotScore = simResult.dotDamageQueued * dotWeight
        score += dotScore

        var novaWeight = this.getWeight('novaEffects', (dotWeight + damageWeight) / 2.0)
        var novaDamageQueued = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var novaScore = novaDamageQueued * novaWeight
        score += novaScore
        if (novaScore > 0) {
            debug("[SCORER-NOVA] Nova damage: " + floor(novaDamageQueued) + " × " + novaWeight + " = " + floor(novaScore))
        }

        var ehpWeight = this.calculateEhpWeight()
        var shieldScore = simResult.shieldsGained * ehpWeight
        var relShieldScore = this.calculateRelativeShieldValue(simResult.relativeShieldGained) * ehpWeight
        var healScore = simResult.hpGained * ehpWeight

        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP
        var healingUrgencyBonus = 0
        if (simResult.hpGained > 0) {
            if (hpRatio < 0.3) healingUrgencyBonus = simResult.hpGained * 3.0
            else if (hpRatio < 0.5) healingUrgencyBonus = simResult.hpGained * 1.5
            else if (hpRatio < 0.8) healingUrgencyBonus = simResult.hpGained * 0.5
            debug("[SCORER][HEAL] Healing urgency bonus: HP=" + floor(currentHP) + "/" + maxHP +
                  " (" + floor(hpRatio * 100) + "%), heal=" + floor(simResult.hpGained) +
                  ", bonus=" + floor(healingUrgencyBonus))
        }

        score += shieldScore + relShieldScore + healScore + healingUrgencyBonus

        var positionWeight = this.calculatePositionWeight()
        var positionScore = this.evaluatePosition(simResult.finalPosition) * positionWeight
        score += positionScore

        var efficiencyWeight = this.getWeight('tpEfficiency', this.calculateEfficiencyWeight())
        var efficiencyScore = this.calculateEfficiency(simResult) * efficiencyWeight
        score += efficiencyScore

        var buffWeight = this.getWeight('buffs', this.calculateBuffWeight())
        var buffScore = this.evaluateBuffs(simResult.buffsApplied, simResult) * buffWeight
        var debuffScore = this.evaluateDebuffs(simResult.debuffsApplied) * buffWeight
        score += buffScore + debuffScore

        var critBonus = this.calculateCritBonus(simResult.damageDealt)
        score += critBonus

        var otkoBonus = 0
        var finalPos = simResult.finalPosition
        if (finalPos != -1 && mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cell = this._fieldMap.damageMap[finalPos]
            if (cell._isOTKOCell) {
                otkoBonus = this.getWeight('otkoBonus', 5000)
                debug("[SCORER-OTKO] +" + otkoBonus + " bonus: Final position cell " + finalPos +
                      " is OTKO cell (kill prob=" + floor(cell._otkoKillProbability * 100) +
                      "%, damage=" + floor(cell._otkoDamage) + ")")
            }
        }
        score += otkoBonus

        var checkpointBonus = 0
        if (scenario != null && count(scenario) > 0) {
            for (var action in scenario) {
                if (action.type == 15) {
                    checkpointBonus = this.getWeight('checkpointBonus', 2500)
                    debug("[SCORER-CHECKPOINT] +" + checkpointBonus + " bonus: Two-phase adaptive scenario (type=" + action.checkpointType + ")")
                    break
                }
            }
        }
        score += checkpointBonus

        var survivalMultiplier = 1.0
        if (simResult.hpGained > 0) {
            var playerPos = this._player._cellPos
            var threatAtPos = this._fieldMap.getThreatAtCell(playerPos)
            var hasShield = this._player.hasEffect(EFFECT_ABSOLUTE_SHIELD) || this._player.hasEffect(EFFECT_RELATIVE_SHIELD)

            if (hpRatio < 0.45 && (threatAtPos > 800 || !hasShield)) {
                if (hpRatio < 0.30) {
                    survivalMultiplier = 50.0
                    debug("[SCORER][SURVIVAL-CRITICAL] Extreme danger (HP=" + floor(hpRatio * 100) + "%, threat=" + floor(threatAtPos) + ") - 50x multiplier")
                } else if (hpRatio < 0.40) {
                    survivalMultiplier = 25.0
                    debug("[SCORER][SURVIVAL-CRITICAL] Critical danger (HP=" + floor(hpRatio * 100) + "%, threat=" + floor(threatAtPos) + ") - 25x multiplier")
                } else {
                    survivalMultiplier = 10.0
                    debug("[SCORER][SURVIVAL-CRITICAL] High danger (HP=" + floor(hpRatio * 100) + "%, threat=" + floor(threatAtPos) + ") - 10x multiplier")
                }
            }
        }

        score *= survivalMultiplier

        debug("[SCORE] Total=" + floor(score) + " (×" + survivalMultiplier + ") | dmg=" + floor(damageScore) + " dot=" + floor(dotScore) +
              " eHP=" + floor(shieldScore + relShieldScore + healScore) +
              " pos=" + floor(positionScore) + " eff=" + floor(efficiencyScore) +
              " buff=" + floor(buffScore + debuffScore) + " crit=" + floor(critBonus) +
              " otko=" + floor(otkoBonus) + " ckpt=" + floor(checkpointBonus))

        return score
    }

    calculateDamageWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (str > mag && str > agi) {
            return 3.0 + (str / 500.0)  
        }
        
        else if (mag > str && mag > agi) {
            return 1.6 + (mag / 1000.0)
        }
        
        else if (agi > str && agi > mag) {
            return 2.6 + (agi / 750.0)
        }

        return 2.0  
    }

    calculateDotWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (mag > str && mag > agi) {
            return 2.0 + (mag / 1000.0)
        }
        
        return 0.3
    }

    calculateEhpWeight() {
        var resistance = this._player._resistance
        var wisdom = this._player._wisdom
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth

        var hpRatio = currentHP / maxHP
        var urgencyMultiplier = 1.0
        if (hpRatio < 0.3) urgencyMultiplier = 5.0
        else if (hpRatio < 0.5) urgencyMultiplier = 3.5
        else if (hpRatio < 0.7) urgencyMultiplier = 2.0
        else if (hpRatio < 0.8) urgencyMultiplier = 1.3

        var baseWeight = 0.5 + (resistance / 500.0) + (wisdom / 1000.0)

        var knowledgeActive = (getCooldown(CHIP_KNOWLEDGE, this._player._id) > 0)
        var elevationActive = (getCooldown(CHIP_ELEVATION, this._player._id) > 0)

        if (knowledgeActive || elevationActive) {
            baseWeight *= 1.5
        }

        var playerPos = this._player._cellPos
        var threatAtPos = this._fieldMap.getThreatAtCell(playerPos)
        if (threatAtPos > 200) {
            urgencyMultiplier *= 1.5
            debug("[SCORER][EHP] High threat (" + floor(threatAtPos) + ") - boosting eHP weight by 1.5x")
        }

        return baseWeight * urgencyMultiplier
    }

    calculatePositionWeight() {
        var agi = this._player._agility
        var str = this._player._strength
        var mag = this._player._magic

        if (agi > str && agi > mag) {
            return 0.8 + (agi / 1000.0)
        }
        
        else if (mag > str && mag > agi) {
            return 0.5 + (mag / 2000.0)
        }
        
        return 0.2
    }

    calculateEfficiencyWeight() {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var targetHP = this._target._currHealth

        var fightLengthEstimate = targetHP / max(1, this._player._strength + this._player._magic)

        if (fightLengthEstimate > 3) return 0.3  
        else if (fightLengthEstimate > 1.5) return 0.15  
        return 0.05  
    }

    calculateBuffWeight() {
        return 2.0  
    }

    evaluatePosition(finalPos) {
        if (finalPos == -1 || finalPos == this._player._cellPos) return 0

        var offensiveValue = 0
        if (mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cellObj = this._fieldMap.damageMap[finalPos]
            offensiveValue = cellObj._totalDamage
        }

        var distToTarget = getCellDistance(finalPos, this._target._cellPos)
        var kitingValue = 0
        if (distToTarget != null) {
            
            if (this._player._magic > this._player._strength) {
                kitingValue = distToTarget * 10  
            } else {
                kitingValue = max(0, (10 - distToTarget)) * 10  
            }
        }

        var threatPenalty = 0
        var threatAtPos = this._fieldMap.getThreatAtCell(finalPos)
        if (threatAtPos > 0) {
            
            threatPenalty = -threatAtPos * 0.5  

            var hpPercent = (this._player._currHealth * 100) / this._player._maxHealth
            if (hpPercent < 50) {
                threatPenalty *= 2.0  
                debug("[SCORER][THREAT] Low HP + high threat cell " + finalPos + ": threat=" + floor(threatAtPos) + ", penalty=" + floor(threatPenalty))
            }
        }

        var totalScore = offensiveValue + kitingValue + threatPenalty
        return totalScore
    }

    calculateEfficiency(simResult) {
        var tpEfficiency = 0
        var mpEfficiency = 0

        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg

        var healingTPCost = 0
        for (var buff in simResult.buffsApplied) {
            if (buff == CHIP_REMISSION) healingTPCost += 5
            if (buff == CHIP_REGENERATION) healingTPCost += 8
            if (buff == CHIP_CURE) healingTPCost += 6
            if (buff == CHIP_DRIP) healingTPCost += 8
        }

        var offensiveTPSpent = simResult.tpSpent - healingTPCost
        if (offensiveTPSpent < 0) offensiveTPSpent = 0

        if (offensiveTPSpent > 0 && totalDamage > 0) {
            var damagePerTP = totalDamage / offensiveTPSpent
            tpEfficiency = damagePerTP * 10
        }

        if (simResult.mpSpent > 0 && totalDamage > 0) {
            var damagePerMP = totalDamage / simResult.mpSpent
            mpEfficiency = damagePerMP * 5
        }

        return tpEfficiency + mpEfficiency
    }

    evaluateBuffs(buffsApplied, simResult) {
        var value = 0

        for (var buffChip in buffsApplied) {
            
            if (buffChip == CHIP_STEROID) value += 200
            if (buffChip == CHIP_DOPING) value += 100
            if (buffChip == CHIP_WARM_UP) value += 150
            if (buffChip == CHIP_ADRENALINE) value += 100

            if (buffChip == CHIP_HELMET || buffChip == CHIP_SHIELD) value += 80
            if (buffChip == CHIP_WALL || buffChip == CHIP_FORTRESS) value += 150
            if (buffChip == CHIP_PROTEIN || buffChip == CHIP_LEATHER_BOOTS) value += 100

            if (buffChip == CHIP_REGENERATION) value += 80
            if (buffChip == CHIP_CURE) value += 120
            if (buffChip == CHIP_DRIP) value += 100

            if (buffChip == CHIP_LIBERATION) value += 120
            if (buffChip == CHIP_REMISSION) value += 100

            if (buffChip == CHIP_MIRROR || buffChip == CHIP_THORN) {
                if (this._player._agility > this._player._strength) value += 180
                else value += 80
            }

            if (buffChip == CHIP_BRAMBLE) {
                var brambleValue = 100  

                if (this._player._agility > this._player._strength && this._player._agility > this._player._magic) {
                    brambleValue = 150  
                }

                var finalPos = simResult.finalPosition
                var distToTarget = getCellDistance(finalPos, this._target._cellPos)

                if (simResult.damageDealt > 0 && distToTarget != null && distToTarget <= 6) {
                    brambleValue *= 2.5  
                    debug("[SCORER][BRAMBLE] Active combat bonus: dist=" + distToTarget + ", dmg=" + floor(simResult.damageDealt) + ", value=" + floor(brambleValue))
                }

                value += brambleValue
            }
        }

        return value
    }

    evaluateDebuffs(debuffsApplied) {
        var value = 0

        for (var debuffChip in debuffsApplied) {
            
            if (debuffChip == CHIP_VENOM || debuffChip == CHIP_TOXIN) value += 100
            if (debuffChip == CHIP_STALACTITE || debuffChip == CHIP_ICEBERG) value += 120
            if (debuffChip == CHIP_ARMOR || debuffChip == CHIP_SOLIDIFICATION) value += 150

            if (debuffChip == CHIP_SLOW_DOWN || debuffChip == CHIP_BALL_AND_CHAIN) value += 80
        }

        return value
    }

    calculateCritBonus(damageDealt) {
        var agi = this._player._agility

        if (agi > this._player._strength && agi > this._player._magic) {
            var critChance = min(0.5, agi / 2000.0)  
            var critMultiplier = 1.3
            var expectedCritBonus = damageDealt * critChance * (critMultiplier - 1.0)
            return expectedCritBonus * 0.5  
        }

        return 0
    }

    calculateRelativeShieldValue(relativeShieldPercent) {
        var maxHP = this._player._maxHealth
        return (relativeShieldPercent / 100.0) * maxHP
    }
}
