/** Scenario Scorer - Scores simulation results with build-specific weights **/

class ScenarioScorer {
    _player = null
    _target = null
    _fieldMap = null

    constructor(player, target, fieldMap) {
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
    }

    // Score a simulation result based on player build and game state
    // Returns numerical score (higher = better scenario)
    // actions: Optional array of Action objects (used to detect checkpoint scenarios)
    score(simResult, actions) {
        var score = 0

        // Detect if this is a checkpoint scenario (contains ACTION_CHECKPOINT)
        var hasCheckpoint = false
        if (actions != null) {
            for (var action in actions) {
                if (action.type == Action.ACTION_CHECKPOINT) {
                    hasCheckpoint = true
                    break
                }
            }
        }

        // 1. DAMAGE WEIGHT - Based on STR and MAG stats
        var damageWeight = this.calculateDamageWeight()

        // KILL OPPORTUNITY BOOST: If we can kill enemy, MASSIVELY favor this scenario
        // Kills end the fight immediately → highest priority
        var enemyHP = this._target._currHealth
        var killProbability = simResult.damageDealt / enemyHP

        if (killProbability >= 0.85) {
            damageWeight *= 20.0  // 20x damage weight for high-confidence kills (85%+)
            debug("[SCORER-BOOST] HIGH-CONFIDENCE KILL: dmg=" + floor(simResult.damageDealt) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 20x damage weight")
        } else if (killProbability >= 0.70) {
            damageWeight *= 12.0  // 12x damage weight for likely kills (70-85%)
            debug("[SCORER-BOOST] Kill opportunity: dmg=" + floor(simResult.damageDealt) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 12x damage weight")
        } else if (killProbability >= 0.50) {
            damageWeight *= 5.0  // 5x for near-kill (50-70%)
            debug("[SCORER-BOOST] Near-kill: dmg=" + floor(simResult.damageDealt) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 5x damage weight")
        }

        var damageScore = simResult.damageDealt * damageWeight
        score += damageScore

        // 2. DOT DAMAGE WEIGHT - Heavily favored by MAG builds
        var dotWeight = this.calculateDotWeight()
        var dotScore = simResult.dotDamageQueued * dotWeight
        score += dotScore

        // 3. eHP WEIGHT - Value of shields and healing (RESISTANCE/WISDOM)
        var ehpWeight = this.calculateEhpWeight()
        var shieldScore = simResult.shieldsGained * ehpWeight
        var relShieldScore = this.calculateRelativeShieldValue(simResult.relativeShieldGained) * ehpWeight
        var healScore = simResult.hpGained * ehpWeight
        score += shieldScore + relShieldScore + healScore

        // 4. POSITIONING WEIGHT - Safety and threat avoidance (AGI builds value positioning)
        var positionWeight = this.calculatePositionWeight()
        var positionScore = this.evaluatePosition(simResult.finalPosition) * positionWeight
        score += positionScore

        // 5. EFFICIENCY WEIGHT - TP/MP economy (longer fights favor efficiency)
        var efficiencyWeight = this.calculateEfficiencyWeight()
        var efficiencyScore = this.calculateEfficiency(simResult) * efficiencyWeight
        score += efficiencyScore

        // 6. BUFF/DEBUFF WEIGHT - Strategic value of buffs
        var buffWeight = this.calculateBuffWeight()
        var buffScore = this.evaluateBuffs(simResult.buffsApplied) * buffWeight
        var debuffScore = this.evaluateDebuffs(simResult.debuffsApplied) * buffWeight
        score += buffScore + debuffScore

        // 7. CRITICAL HIT BONUS - AGI builds benefit from crit chance
        var critBonus = this.calculateCritBonus(simResult.damageDealt)
        score += critBonus

        // 8. OTKO CELL BONUS - Massive bonus for positioning on kill-opportunity cells
        var otkoBonus = 0
        var finalPos = simResult.finalPosition
        if (finalPos != -1 && mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cell = this._fieldMap.damageMap[finalPos]
            if (cell._isOTKOCell) {
                // Huge bonus: 5000 points for OTKO positioning
                otkoBonus = 5000
                debug("[SCORER-OTKO] +5000 bonus: Final position cell " + finalPos +
                      " is OTKO cell (kill prob=" + floor(cell._otkoKillProbability * 100) +
                      "%, damage=" + floor(cell._otkoDamage) + ")")
            }
        }
        score += otkoBonus

        // 9. VULNERABILITY BONUS - Massive value for damage amplification combos
        var vulnBonus = this.calculateVulnerabilityValue(simResult.vulnerabilityApplied, simResult.damageDealt)
        score += vulnBonus

        // 10. ZERO-DAMAGE PENALTY - Massive penalty for buff-only scenarios
        // Prevents useless scenarios (buffs only, no attacks) from winning selection
        // EXCEPTION: Checkpoint scenarios get evaluated dynamically, skip penalty
        var zeroDamagePenalty = 0
        if (simResult.damageDealt == 0 && simResult.dotDamageQueued == 0 && !hasCheckpoint) {
            zeroDamagePenalty = -10000
            debug("[SCORER-PENALTY] Zero damage scenario: -10000 penalty (buff-only rejected)")
        }
        score += zeroDamagePenalty

        // 11. CHECKPOINT BONUS - Compensate for inability to simulate continuations
        // Checkpoint scenarios will generate high-value continuations at execution time
        var checkpointBonus = 0
        if (hasCheckpoint) {
            // Give checkpoint scenarios a fighting chance against regular scenarios
            // Bonus should be enough to compete with typical damage scenarios (~1000-3000 score)
            checkpointBonus = 2000
            debug("[SCORER-CHECKPOINT] +2000 bonus for adaptive checkpoint scenario")
        }
        score += checkpointBonus

        // Debug scoring breakdown
        debug("[SCORE] Total=" + floor(score) + " | dmg=" + floor(damageScore) + " dot=" + floor(dotScore) +
              " eHP=" + floor(shieldScore + relShieldScore + healScore) +
              " pos=" + floor(positionScore) + " eff=" + floor(efficiencyScore) +
              " buff=" + floor(buffScore + debuffScore) + " crit=" + floor(critBonus) +
              " otko=" + floor(otkoBonus) + " vuln=" + floor(vulnBonus) +
              " checkpoint=" + floor(checkpointBonus) + " penalty=" + floor(zeroDamagePenalty))

        return score
    }

    // DAMAGE WEIGHT: STR builds favor direct damage, MAG builds moderate
    calculateDamageWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // STR builds: high weight (1.5-2.5)
        if (str > mag && str > agi) {
            return 1.5 + (str / 1000.0)  // Scale with strength
        }
        // MAG builds: moderate weight (0.8-1.2)
        else if (mag > str && mag > agi) {
            return 0.8 + (mag / 2000.0)
        }
        // AGI builds: high weight (similar to STR, benefits from crits)
        else if (agi > str && agi > mag) {
            return 1.3 + (agi / 1500.0)
        }

        return 1.0  // Default
    }

    // DOT WEIGHT: MAG builds heavily favor DoT damage
    calculateDotWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        // MAG builds: very high weight (2.0-3.0)
        if (mag > str && mag > agi) {
            return 2.0 + (mag / 1000.0)
        }
        // Other builds: low weight (0.3-0.5)
        return 0.3
    }

    // eHP WEIGHT: RESISTANCE/WISDOM based (tank value)
    calculateEhpWeight() {
        var resistance = this._player._resistance
        var wisdom = this._player._wisdom
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth

        // Low HP situations: increase eHP value
        // BOOSTED urgency multipliers to favor proactive healing (prevents dying despite winning damage race)
        var hpRatio = currentHP / maxHP
        var urgencyMultiplier = 1.0
        if (hpRatio < 0.3) urgencyMultiplier = 4.0        // Emergency: 4x (was 3.0x)
        else if (hpRatio < 0.5) urgencyMultiplier = 3.0   // Critical: 3x (was 2.0x)
        else if (hpRatio < 0.7) urgencyMultiplier = 2.0   // Proactive: 2x (was 1.5x)
        else if (hpRatio < 0.8) urgencyMultiplier = 1.5   // Early warning: 1.5x (new tier)

        // Base weight from RESISTANCE/WISDOM
        var baseWeight = 0.5 + (resistance / 500.0) + (wisdom / 1000.0)

        // KNOWLEDGE/ELEVATION wisdom buffs active: healing is more valuable
        // Check if wisdom buffs were used recently (cooldown > 0 means still active)
        var knowledgeActive = (getCooldown(CHIP_KNOWLEDGE, this._player._id) > 0)
        var elevationActive = (getCooldown(CHIP_ELEVATION, this._player._id) > 0)

        if (knowledgeActive || elevationActive) {
            baseWeight *= 1.5  // 50% bonus to healing value with wisdom buff active
        }

        return baseWeight * urgencyMultiplier
    }

    // POSITION WEIGHT: AGI builds value positioning more
    calculatePositionWeight() {
        var agi = this._player._agility
        var str = this._player._strength
        var mag = this._player._magic

        // AGI builds: high weight (0.8-1.5)
        if (agi > str && agi > mag) {
            return 0.8 + (agi / 1000.0)
        }
        // MAG builds: moderate weight (kiting)
        else if (mag > str && mag > agi) {
            return 0.5 + (mag / 2000.0)
        }
        // STR builds: low weight (prefer standing and fighting)
        return 0.2
    }

    // EFFICIENCY WEIGHT: Longer fights favor efficiency
    calculateEfficiencyWeight() {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var targetHP = this._target._currHealth

        // Long fight expected: increase efficiency weight
        var fightLengthEstimate = targetHP / max(1, this._player._strength + this._player._magic)

        if (fightLengthEstimate > 3) return 0.3  // Long fight
        else if (fightLengthEstimate > 1.5) return 0.15  // Medium fight
        return 0.05  // Short fight (OTKO scenarios)
    }

    // BUFF WEIGHT: Strategic value of buffs
    calculateBuffWeight() {
        return 5.0  // Fixed weight for buff/debuff strategic value (reduced from 50 to balance with damage)
    }

    // Evaluate position safety/threat (IMPROVED: Now accounts for enemy threat at position)
    evaluatePosition(finalPos) {
        if (finalPos == -1 || finalPos == this._player._cellPos) return 0

        // Check if position is in damage map (good for offense)
        var offensiveValue = 0
        if (mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cellObj = this._fieldMap.damageMap[finalPos]
            offensiveValue = cellObj._totalDamage
        }

        // Check distance to target (kiting value)
        var distToTarget = getCellDistance(finalPos, this._target._cellPos)
        var kitingValue = 0
        if (distToTarget != null) {
            // MAG builds prefer distance, STR builds prefer close range
            if (this._player._magic > this._player._strength) {
                kitingValue = distToTarget * 10  // Reward distance
            } else {
                kitingValue = max(0, (10 - distToTarget)) * 10  // Reward closeness
            }
        }

        // NEW: Threat-based safety evaluation (reduce damage taken)
        // Check how much threat (potential damage) enemy has at this position
        var threatPenalty = 0
        var threatAtPos = this._fieldMap.getThreatAtCell(finalPos)
        if (threatAtPos > 0) {
            // Heavy penalty for high-threat positions
            // Threat is enemy's potential damage at this cell
            threatPenalty = -threatAtPos * 0.5  // Penalty = 50% of threat value

            // Extra penalty if we're low HP (prioritize safety more)
            var hpPercent = (this._player._currHealth * 100) / this._player._maxHealth
            if (hpPercent < 50) {
                threatPenalty *= 2.0  // Double penalty when low HP
                debug("[SCORER][THREAT] Low HP + high threat cell " + finalPos + ": threat=" + floor(threatAtPos) + ", penalty=" + floor(threatPenalty))
            }
        }

        var totalScore = offensiveValue + kitingValue + threatPenalty
        return totalScore
    }

    // Calculate TP/MP efficiency score
    calculateEfficiency(simResult) {
        var tpEfficiency = 0
        var mpEfficiency = 0

        // Reward high damage per TP
        if (simResult.tpSpent > 0) {
            var damagePerTP = (simResult.damageDealt + simResult.dotDamageQueued) / simResult.tpSpent
            tpEfficiency = damagePerTP * 10
        }

        // Penalize excessive MP usage (unless it leads to high damage)
        if (simResult.mpSpent > 0) {
            var damagePerMP = (simResult.damageDealt + simResult.dotDamageQueued) / simResult.mpSpent
            mpEfficiency = damagePerMP * 5
        }

        return tpEfficiency + mpEfficiency
    }

    // Evaluate buff strategic value
    evaluateBuffs(buffsApplied) {
        var value = 0

        for (var buffChip in buffsApplied) {
            // Offensive buffs
            if (buffChip == CHIP_STEROID) value += 200
            if (buffChip == CHIP_DOPING) value += 100
            if (buffChip == CHIP_WARM_UP) value += 150
            if (buffChip == CHIP_ADRENALINE) value += 100

            // Defensive buffs
            if (buffChip == CHIP_HELMET || buffChip == CHIP_SHIELD) value += 80
            if (buffChip == CHIP_WALL || buffChip == CHIP_FORTRESS) value += 150
            if (buffChip == CHIP_PROTEIN || buffChip == CHIP_LEATHER_BOOTS) value += 100

            // Healing
            if (buffChip == CHIP_REGENERATION) value += 80
            if (buffChip == CHIP_CURE) value += 120
            if (buffChip == CHIP_DRIP) value += 100

            // Utility
            if (buffChip == CHIP_LIBERATION) value += 120
            if (buffChip == CHIP_REMISSION) value += 100

            // Damage return (AGI builds)
            if (buffChip == CHIP_MIRROR || buffChip == CHIP_THORN) {
                if (this._player._agility > this._player._strength) value += 180
                else value += 80
            }
        }

        return value
    }

    // Evaluate debuff strategic value
    evaluateDebuffs(debuffsApplied) {
        var value = 0

        for (var debuffChip in debuffsApplied) {
            // High-value debuffs
            if (debuffChip == CHIP_VENOM || debuffChip == CHIP_TOXIN) value += 100
            if (debuffChip == CHIP_STALACTITE || debuffChip == CHIP_ICEBERG) value += 120
            if (debuffChip == CHIP_ARMOR || debuffChip == CHIP_SOLIDIFICATION) value += 150

            // Movement debuffs
            if (debuffChip == CHIP_SLOW_DOWN || debuffChip == CHIP_BALL_AND_CHAIN) value += 80
        }

        return value
    }

    // Calculate critical hit bonus (AGI builds)
    calculateCritBonus(damageDealt) {
        var agi = this._player._agility

        // AGI builds have crit chance
        if (agi > this._player._strength && agi > this._player._magic) {
            var critChance = min(0.5, agi / 2000.0)  // ~25% crit at 500 AGI
            var critMultiplier = 1.3
            var expectedCritBonus = damageDealt * critChance * (critMultiplier - 1.0)
            return expectedCritBonus * 0.5  // Weight expected crit value
        }

        return 0
    }

    // Calculate relative shield value (converts % shield to absolute value)
    calculateRelativeShieldValue(relativeShieldPercent) {
        var maxHP = this._player._maxHealth
        return (relativeShieldPercent / 100.0) * maxHP
    }

    // Calculate vulnerability value - estimates future damage amplification
    // Vulnerability amplifies ALL future damage for multiple turns
    // Example: 24% vulnerability (3x Neutrino) = 1.24x damage multiplier
    calculateVulnerabilityValue(vulnPercent, currentDamage) {
        if (vulnPercent <= 0) return 0

        // Calculate amplification multiplier
        var multiplier = 1.0 + (vulnPercent / 100.0)

        // Estimate future attacks benefiting from vulnerability
        var enemyHP = this._target._currHealth
        var currentTP = getTP()
        var avgWeaponDamage = 180  // Conservative estimate

        // STR builds deal more damage per attack
        if (this._player._strength > this._player._magic && this._player._strength > this._player._agility) {
            avgWeaponDamage = 240
        }

        // Estimate attacks this turn + next 2-3 turns (vulnerability duration)
        var futureAttacks = floor(currentTP / 8) + 6  // Current turn + future turns
        var futureBaseDamage = futureAttacks * avgWeaponDamage

        // Calculate amplification benefit (how much extra damage vulnerability provides)
        var amplificationBenefit = futureBaseDamage * (multiplier - 1.0)

        // HUGE BONUS for vulnerability stacking
        // Weight: 3.0x (vulnerability is core damage multiplier for STR builds)
        var vulnerabilityScore = amplificationBenefit * 3.0

        // Extra bonus for HEAVY_SWORD (60% vuln = 1.6x damage multiplier, massive value)
        if (vulnPercent >= 60) {
            vulnerabilityScore *= 1.5  // 50% extra bonus for HEAVY_SWORD
            debug("[SCORER-VULN] HEAVY_SWORD detected: 60% vuln → 1.6x damage multiplier")
        }
        // Extra bonus for 3x Neutrino stacks (24% vuln = 1.24x damage multiplier)
        else if (vulnPercent >= 24) {
            vulnerabilityScore *= 1.3  // 30% extra bonus for full Neutrino stacking
            debug("[SCORER-VULN] Full Neutrino stack detected: 24% vuln → 1.24x damage multiplier")
        }

        debug("[SCORER-VULN] Vulnerability " + floor(vulnPercent) + "% → multiplier " + multiplier + "x → score +" + floor(vulnerabilityScore))
        debug("[SCORER-VULN] Estimated amplification: " + floor(amplificationBenefit) + " damage over next turns")

        return vulnerabilityScore
    }
}
