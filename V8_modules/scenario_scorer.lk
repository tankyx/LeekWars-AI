include('game_entity.lk')

class ScenarioScorer {
    _player = null
    _target = null
    _fieldMap = null
    _weights = null

    constructor(player, target, fieldMap, weights) {
        this._player = player
        this._target = target
        this._fieldMap = fieldMap
        this._weights = weights != null ? weights : [:]
    }

    getWeight(key, defaultValue) {
        if (mapContainsKey(this._weights, key)) {
            return this._weights[key]
        }
        return defaultValue
    }

    score(simResult, scenario) {
        var score = 0

        var enemyHP = this._target._currHealth
        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg
        var killProbability = totalDamage / enemyHP

        // Bulb detection and classification
        var targetIsBulb = isBulb(this._target)
        var bulbType = targetIsBulb ? getBulbType(this._target) : BULB_TYPE_UNKNOWN

        // Battle Royale mode: prioritize total lobby damage over single-target damage
        var isBattleRoyale = (getFightType() == FIGHT_TYPE_BATTLE_ROYALE)
        var effectiveDamage = totalDamage
        if (isBattleRoyale && simResult.totalLobbyDamage > 0) {
            effectiveDamage = simResult.totalLobbyDamage
            debug("[SCORER-BR] Lobby damage: " + floor(simResult.totalLobbyDamage) +
                  " (primary=" + floor(totalDamage) + ", enemies hit=" + simResult.enemiesHit + ")")
        }

        // Bulb damage multiplier: configurable via weights
        var bulbDamageMultiplier = targetIsBulb ? this.getWeight('bulbDamageMultiplier', 1.2) : 1.0
        if (targetIsBulb) {
            debug("[SCORER-BULB] Target is bulb (type=" + bulbType + ") - damage multiplier: " + bulbDamageMultiplier + "×")
        }

        var damageWeight = this.getWeight('burstDamage', this.calculateDamageWeight())

        if (killProbability >= 0.70) {
            damageWeight *= 5.0
            debug("[SCORER-BOOST] Kill opportunity: dmg=" + floor(totalDamage) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 5x damage weight")
        } else if (killProbability >= 0.50) {
            damageWeight *= 2.5
            debug("[SCORER-BOOST] Near-kill: dmg=" + floor(totalDamage) +
                  " vs HP=" + enemyHP + " (" + floor(killProbability * 100) + "%) - 2.5x damage weight")
        }

        // Apply bulb damage multiplier
        var damageScore = effectiveDamage * damageWeight * bulbDamageMultiplier
        score += damageScore

        // Bulb kill bonus: massive score for killing high-value bulbs (configurable via weights)
        var bulbKillBonus = 0
        if (targetIsBulb && killProbability >= 0.70) {
            if (bulbType == BULB_TYPE_HEALER) {
                bulbKillBonus = this.getWeight('bulbKillBonusHealer', 2500)
                debug("[SCORER-BULB] HEALER bulb kill bonus: +" + bulbKillBonus)
            } else if (bulbType == BULB_TYPE_BUFFER) {
                bulbKillBonus = this.getWeight('bulbKillBonusBuffer', 1500)
                debug("[SCORER-BULB] BUFFER bulb kill bonus: +" + bulbKillBonus)
            } else if (bulbType == BULB_TYPE_ATTACKER) {
                bulbKillBonus = this.getWeight('bulbKillBonusAttacker', 800)
                debug("[SCORER-BULB] ATTACKER bulb kill bonus: +" + bulbKillBonus)
            }
        }
        score += bulbKillBonus

        // Battle Royale: massive bonus for reducing lobby size (any kill)
        if (isBattleRoyale && simResult.killsSecured > 0) {
            var lobbySizeBonus = simResult.killsSecured * 5000
            score += lobbySizeBonus
            debug("[SCORER-BR] Lobby size reduction: +" + lobbySizeBonus + " (" + simResult.killsSecured + " kills)")
        }

        // Battle Royale: bonus for hitting multiple enemies with AoE
        if (isBattleRoyale && simResult.enemiesHit >= 2) {
            var aoeBonus = (simResult.enemiesHit - 1) * 1000
            score += aoeBonus
            debug("[SCORER-BR] Multi-target AoE: +" + aoeBonus + " (" + simResult.enemiesHit + " enemies)")
        }

        var playerHPPercent = (this._player._currHealth * 100) / this._player._maxHealth
        if (totalDamage == 0 && playerHPPercent > 30) {
            var currentTurn = getTurn()
            var noDamagePenalty = this.getWeight('noDamagePenalty', -2000)

            // Reduce penalty for early turns (turn 1-3) when positioning is expected
            if (currentTurn <= 3) {
                noDamagePenalty = noDamagePenalty / 4  // -500 instead of -2000
                debug("[SCORER-PENALTY] No damage dealt (early turn " + currentTurn + ") - reduced penalty: " + noDamagePenalty)
            } else {
                debug("[SCORER-PENALTY] No damage dealt (turn " + currentTurn + ") - full penalty: " + noDamagePenalty)
            }

            score += noDamagePenalty
        }

        var dotWeight = this.getWeight('dotEffects', this.calculateDotWeight())
        var dotScore = simResult.dotDamageQueued * dotWeight
        score += dotScore

        var novaWeight = this.getWeight('novaEffects', (dotWeight + damageWeight) / 2.0)
        var novaDamageQueued = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var novaScore = novaDamageQueued * novaWeight
        score += novaScore
        if (novaScore > 0) {
            debug("[SCORER-NOVA] Nova damage: " + floor(novaDamageQueued) + " × " + novaWeight + " = " + floor(novaScore))
        }

        var ehpWeight = this.calculateEhpWeight()
        var shieldScore = simResult.shieldsGained * ehpWeight
        var relShieldScore = this.calculateRelativeShieldValue(simResult.relativeShieldGained) * ehpWeight
        var healScore = simResult.hpGained * ehpWeight

        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var hpRatio = currentHP / maxHP
        var healingUrgencyBonus = 0
        if (simResult.hpGained > 0) {
            if (hpRatio < 0.3) healingUrgencyBonus = simResult.hpGained * 3.0
            else if (hpRatio < 0.5) healingUrgencyBonus = simResult.hpGained * 1.5
            else if (hpRatio < 0.8) healingUrgencyBonus = simResult.hpGained * 0.5
            debug("[SCORER][HEAL] Healing urgency bonus: HP=" + floor(currentHP) + "/" + maxHP +
                  " (" + floor(hpRatio * 100) + "%), heal=" + floor(simResult.hpGained) +
                  ", bonus=" + floor(healingUrgencyBonus))
        }

        score += shieldScore + relShieldScore + healScore + healingUrgencyBonus

        var positionWeight = this.calculatePositionWeight()
        var positionScore = this.evaluatePosition(simResult.finalPosition) * positionWeight
        score += positionScore

        var efficiencyWeight = this.getWeight('tpEfficiency', this.calculateEfficiencyWeight())
        var efficiencyScore = this.calculateEfficiency(simResult) * efficiencyWeight
        score += efficiencyScore

        var buffWeight = this.getWeight('buffs', this.calculateBuffWeight())
        var buffScore = this.evaluateBuffs(simResult.buffsApplied, simResult) * buffWeight
        var debuffScore = this.evaluateDebuffs(simResult.debuffsApplied) * buffWeight
        score += buffScore + debuffScore

        var critBonus = this.calculateCritBonus(simResult.damageDealt)
        score += critBonus

        var otkoBonus = 0
        var finalPos = simResult.finalPosition
        if (finalPos != -1 && mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cell = this._fieldMap.damageMap[finalPos]
            if (cell._isOTKOCell) {
                otkoBonus = this.getWeight('otkoBonus', 5000)
                debug("[SCORER-OTKO] +" + otkoBonus + " bonus: Final position cell " + finalPos +
                      " is OTKO cell (kill prob=" + floor(cell._otkoKillProbability * 100) +
                      "%, damage=" + floor(cell._otkoDamage) + ")")
            }
        }
        score += otkoBonus

        var checkpointBonus = 0
        if (scenario != null && count(scenario) > 0) {
            for (var action in scenario) {
                if (action.type == 15) {
                    checkpointBonus = this.getWeight('checkpointBonus', 2500)
                    debug("[SCORER-CHECKPOINT] +" + checkpointBonus + " bonus: Two-phase adaptive scenario (type=" + action.checkpointType + ")")
                    break
                }
            }
        }
        score += checkpointBonus

        // Battle Royale: Center avoidance penalty (EARLY phase only)
        var centerPenalty = 0
        if (isBattleRoyale) {
            var aliveEnemies = getAliveEnemies()
            var enemyCount = count(aliveEnemies)

            if (enemyCount > 4) {
                // EARLY PHASE: Penalize moving toward center
                var centerCell = getCellFromXY(0, 0)  // Map center at (0, 0)
                if (centerCell != null && simResult.finalPosition != -1) {
                    var currentDistToCenter = getCellDistance(this._player._cellPos, centerCell)
                    var finalDistToCenter = getCellDistance(simResult.finalPosition, centerCell)

                    if (finalDistToCenter != null && currentDistToCenter != null) {
                        if (finalDistToCenter < currentDistToCenter) {
                            // Moving closer to center = bad
                            var movementTowardCenter = currentDistToCenter - finalDistToCenter
                            centerPenalty = movementTowardCenter * 150  // Heavy penalty
                            debug("[SCORER-BR] Center avoidance: moved " + movementTowardCenter + " cells closer, penalty=" + floor(centerPenalty))
                        }
                    }
                }
                score -= centerPenalty
            }
        }

        var survivalMultiplier = 1.0
        if (simResult.hpGained > 0) {
            var playerPos = this._player._cellPos
            var threatAtPos = this._fieldMap.getThreatAtCell(playerPos)
            var hasShield = this._player.hasEffect(EFFECT_ABSOLUTE_SHIELD) || this._player.hasEffect(EFFECT_RELATIVE_SHIELD)

            if (hpRatio < 0.45 && (threatAtPos > 800 || !hasShield)) {
                if (hpRatio < 0.30) {
                    survivalMultiplier = 50.0
                    debug("[SCORER][SURVIVAL-CRITICAL] Extreme danger (HP=" + floor(hpRatio * 100) + "%, threat=" + floor(threatAtPos) + ") - 50x multiplier")
                } else if (hpRatio < 0.40) {
                    survivalMultiplier = 25.0
                    debug("[SCORER][SURVIVAL-CRITICAL] Critical danger (HP=" + floor(hpRatio * 100) + "%, threat=" + floor(threatAtPos) + ") - 25x multiplier")
                } else {
                    survivalMultiplier = 10.0
                    debug("[SCORER][SURVIVAL-CRITICAL] High danger (HP=" + floor(hpRatio * 100) + "%, threat=" + floor(threatAtPos) + ") - 10x multiplier")
                }
            }
        }

        score *= survivalMultiplier

        debug("[SCORE] Total=" + floor(score) + " (×" + survivalMultiplier + ") | dmg=" + floor(damageScore) + " dot=" + floor(dotScore) +
              " eHP=" + floor(shieldScore + relShieldScore + healScore) +
              " pos=" + floor(positionScore) + " eff=" + floor(efficiencyScore) +
              " buff=" + floor(buffScore + debuffScore) + " crit=" + floor(critBonus) +
              " otko=" + floor(otkoBonus) + " ckpt=" + floor(checkpointBonus) +
              " bulb=" + floor(bulbKillBonus))

        return score
    }

    calculateDamageWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (str > mag && str > agi) {
            return 3.0 + (str / 500.0)  
        }
        
        else if (mag > str && mag > agi) {
            return 1.6 + (mag / 1000.0)
        }
        
        else if (agi > str && agi > mag) {
            return 2.6 + (agi / 750.0)
        }

        return 2.0  
    }

    calculateDotWeight() {
        var str = this._player._strength
        var mag = this._player._magic
        var agi = this._player._agility

        if (mag > str && mag > agi) {
            return 2.0 + (mag / 1000.0)
        }
        
        return 0.3
    }

    calculateEhpWeight() {
        var resistance = this._player._resistance
        var wisdom = this._player._wisdom
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth

        var hpRatio = currentHP / maxHP
        var urgencyMultiplier = 1.0
        if (hpRatio < 0.3) urgencyMultiplier = 5.0
        else if (hpRatio < 0.5) urgencyMultiplier = 3.5
        else if (hpRatio < 0.7) urgencyMultiplier = 2.0
        else if (hpRatio < 0.8) urgencyMultiplier = 1.3

        var baseWeight = 0.5 + (resistance / 500.0) + (wisdom / 1000.0)

        var knowledgeActive = (getCooldown(CHIP_KNOWLEDGE, this._player._id) > 0)
        var elevationActive = (getCooldown(CHIP_ELEVATION, this._player._id) > 0)

        if (knowledgeActive || elevationActive) {
            baseWeight *= 1.5
        }

        var playerPos = this._player._cellPos
        var threatAtPos = this._fieldMap.getThreatAtCell(playerPos)
        if (threatAtPos > 200) {
            urgencyMultiplier *= 1.5
            debug("[SCORER][EHP] High threat (" + floor(threatAtPos) + ") - boosting eHP weight by 1.5x")
        }

        return baseWeight * urgencyMultiplier
    }

    calculatePositionWeight() {
        var agi = this._player._agility
        var str = this._player._strength
        var mag = this._player._magic

        if (agi > str && agi > mag) {
            return 0.8 + (agi / 1000.0)
        }
        
        else if (mag > str && mag > agi) {
            return 0.5 + (mag / 2000.0)
        }
        
        return 0.2
    }

    calculateEfficiencyWeight() {
        var currentHP = this._player._currHealth
        var maxHP = this._player._maxHealth
        var targetHP = this._target._currHealth

        var fightLengthEstimate = targetHP / max(1, this._player._strength + this._player._magic)

        if (fightLengthEstimate > 3) return 0.3  
        else if (fightLengthEstimate > 1.5) return 0.15  
        return 0.05  
    }

    calculateBuffWeight() {
        return 2.0  
    }

    evaluatePosition(finalPos) {
        if (finalPos == -1 || finalPos == this._player._cellPos) return 0

        var offensiveValue = 0
        if (mapContainsKey(this._fieldMap.damageMap, finalPos)) {
            var cellObj = this._fieldMap.damageMap[finalPos]
            offensiveValue = cellObj._totalDamage
        }

        var distToTarget = getCellDistance(finalPos, this._target._cellPos)
        var kitingValue = 0
        if (distToTarget != null) {
            
            if (this._player._magic > this._player._strength) {
                kitingValue = distToTarget * 10  
            } else {
                kitingValue = max(0, (10 - distToTarget)) * 10  
            }
        }

        var threatPenalty = 0
        var threatAtPos = this._fieldMap.getThreatAtCell(finalPos)
        if (threatAtPos > 0) {
            
            threatPenalty = -threatAtPos * 0.5  

            var hpPercent = (this._player._currHealth * 100) / this._player._maxHealth
            if (hpPercent < 50) {
                threatPenalty *= 2.0  
                debug("[SCORER][THREAT] Low HP + high threat cell " + finalPos + ": threat=" + floor(threatAtPos) + ", penalty=" + floor(threatPenalty))
            }
        }

        var totalScore = offensiveValue + kitingValue + threatPenalty
        return totalScore
    }

    calculateEfficiency(simResult) {
        var tpEfficiency = 0
        var mpEfficiency = 0

        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg

        var healingTPCost = 0
        for (var buff in simResult.buffsApplied) {
            if (buff == CHIP_REMISSION) healingTPCost += 5
            if (buff == CHIP_REGENERATION) healingTPCost += 8
            if (buff == CHIP_CURE) healingTPCost += 6
            if (buff == CHIP_DRIP) healingTPCost += 8
        }

        var offensiveTPSpent = simResult.tpSpent - healingTPCost
        if (offensiveTPSpent < 0) offensiveTPSpent = 0

        if (offensiveTPSpent > 0 && totalDamage > 0) {
            var damagePerTP = totalDamage / offensiveTPSpent
            tpEfficiency = damagePerTP * 10
        }

        if (simResult.mpSpent > 0 && totalDamage > 0) {
            var damagePerMP = totalDamage / simResult.mpSpent
            mpEfficiency = damagePerMP * 5
        }

        return tpEfficiency + mpEfficiency
    }

    evaluateBuffs(buffsApplied, simResult) {
        var value = 0

        // Estimate expected incoming damage for defensive buff valuation
        var playerPos = simResult.finalPosition != -1 ? simResult.finalPosition : this._player._cellPos
        var expectedDamage = this._fieldMap.getThreatAtCell(playerPos)
        if (expectedDamage == null || expectedDamage < 0) expectedDamage = 0

        // Kill margin check: reduce buff value if kill is guaranteed
        var enemyHP = this._target._currHealth
        var dotDmg = simResult.dotDamageQueued != null ? simResult.dotDamageQueued : 0
        var novaDmg = simResult.novaDamageQueued != null ? simResult.novaDamageQueued : 0
        var totalDamage = simResult.damageDealt + dotDmg + novaDmg
        var killMargin = totalDamage / enemyHP
        var buffMultiplier = 1.0

        if (killMargin >= 1.1) {
            // Kill is guaranteed with 10% safety margin - heavily de-prioritize buffs
            buffMultiplier = 0.1
            debug("[SCORER-BUFF] Kill guaranteed (margin=" + killMargin + ") - 90% buff penalty")
        } else if (killMargin < 0.7 && expectedDamage > 200) {
            // No kill possible + high threat - force buffs
            buffMultiplier = 5.0
            debug("[SCORER-BUFF] No kill possible (margin=" + killMargin + ") + high threat - 5x buff bonus")
        }

        for (var buffChip in buffsApplied) {

            // Offensive buffs: fixed values (not threat-dependent)
            if (buffChip == CHIP_STEROID) value += 200
            if (buffChip == CHIP_DOPING) value += 100
            if (buffChip == CHIP_WARM_UP) value += 150
            if (buffChip == CHIP_ADRENALINE) value += 100

            // Shield buffs: dynamic threat-aware valuation
            if (buffChip == CHIP_HELMET || buffChip == CHIP_SHIELD) {
                // Absolute shields: flat HP value
                value += 80  // Base value
            }

            if (buffChip == CHIP_WALL) {
                // Relative shield: scales with Resistance
                var resistance = this._player._resistance
                var reductionPercent = 4.5 * (1 + resistance / 100.0)
                var duration = 2  // 2 turns
                var effectiveHP = (expectedDamage * duration) * (reductionPercent / 100.0)
                var wallValue = effectiveHP * 0.5  // Scale down to reasonable scorer range
                if (wallValue < 80) wallValue = 80  // Minimum value
                value += wallValue
                debug("[SCORER-BUFF] WALL value: reduction=" + floor(reductionPercent) + "%, threat=" + floor(expectedDamage) + ", value=" + floor(wallValue))
            }

            if (buffChip == CHIP_FORTRESS) {
                // Relative shield: scales with Resistance
                var resistance = this._player._resistance
                var reductionPercent = 7.5 * (1 + resistance / 100.0)
                var duration = 3  // 3 turns
                var effectiveHP = (expectedDamage * duration) * (reductionPercent / 100.0)
                var fortressValue = effectiveHP * 0.5  // Scale down to reasonable scorer range
                if (fortressValue < 150) fortressValue = 150  // Minimum value
                value += fortressValue
                debug("[SCORER-BUFF] FORTRESS value: reduction=" + floor(reductionPercent) + "%, threat=" + floor(expectedDamage) + ", value=" + floor(fortressValue))
            }

            if (buffChip == CHIP_PROTEIN || buffChip == CHIP_LEATHER_BOOTS) value += 100

            // Healing buffs: fixed values
            if (buffChip == CHIP_REGENERATION) value += 80
            if (buffChip == CHIP_CURE) value += 120
            if (buffChip == CHIP_DRIP) value += 100
            if (buffChip == CHIP_LIBERATION) value += 120
            if (buffChip == CHIP_REMISSION) value += 100

            // Damage return buffs: dynamic threat-aware valuation
            if (buffChip == CHIP_MIRROR) {
                var agility = this._player._agility
                var returnPercent = 5.5 * (1 + agility / 100.0)
                var duration = 3  // 3 turns
                var returnDamage = (expectedDamage * duration) * (returnPercent / 100.0)
                var mirrorValue = returnDamage * 0.8  // Scale down to reasonable scorer range
                if (mirrorValue < 100) mirrorValue = 100  // Minimum value
                value += mirrorValue
                debug("[SCORER-BUFF] MIRROR value: return=" + floor(returnPercent) + "%, threat=" + floor(expectedDamage) + ", value=" + floor(mirrorValue))
            }

            if (buffChip == CHIP_THORN) {
                var agility = this._player._agility
                var returnPercent = 3.5 * (1 + agility / 100.0)
                var duration = 2  // 2 turns
                var returnDamage = (expectedDamage * duration) * (returnPercent / 100.0)
                var thornValue = returnDamage * 0.8  // Scale down to reasonable scorer range
                if (thornValue < 80) thornValue = 80  // Minimum value
                value += thornValue
                debug("[SCORER-BUFF] THORN value: return=" + floor(returnPercent) + "%, threat=" + floor(expectedDamage) + ", value=" + floor(thornValue))
            }

            if (buffChip == CHIP_BRAMBLE) {
                // BRAMBLE: Tactical burst only (1 turn, 25% return, 8 turn cooldown)
                var agility = this._player._agility
                var returnPercent = 25.0 * (1 + agility / 100.0)
                var duration = 1  // 1 turn only
                var returnDamage = expectedDamage * (returnPercent / 100.0)

                // Only valuable in high-threat scenarios
                var brambleValue = 0
                if (expectedDamage > 300) {
                    brambleValue = returnDamage * 1.5  // Higher multiplier for burst value
                    debug("[SCORER-BUFF] BRAMBLE tactical burst: return=" + floor(returnPercent) + "%, threat=" + floor(expectedDamage) + ", value=" + floor(brambleValue))
                } else {
                    brambleValue = 50  // Minimal value if no threat (discourage usage)
                    debug("[SCORER-BUFF] BRAMBLE low threat: discouraged (threat=" + floor(expectedDamage) + ")")
                }

                value += brambleValue
            }
        }

        // Apply kill margin multiplier to ALL buff values
        value *= buffMultiplier

        return value
    }

    evaluateDebuffs(debuffsApplied) {
        var value = 0

        for (var debuffChip in debuffsApplied) {
            
            if (debuffChip == CHIP_VENOM || debuffChip == CHIP_TOXIN) value += 100
            if (debuffChip == CHIP_STALACTITE || debuffChip == CHIP_ICEBERG) value += 120
            if (debuffChip == CHIP_ARMOR || debuffChip == CHIP_SOLIDIFICATION) value += 150

            if (debuffChip == CHIP_SLOW_DOWN || debuffChip == CHIP_BALL_AND_CHAIN) value += 80
        }

        return value
    }

    calculateCritBonus(damageDealt) {
        var agi = this._player._agility

        if (agi > this._player._strength && agi > this._player._magic) {
            var critChance = min(0.5, agi / 2000.0)  
            var critMultiplier = 1.3
            var expectedCritBonus = damageDealt * critChance * (critMultiplier - 1.0)
            return expectedCritBonus * 0.5  
        }

        return 0
    }

    calculateRelativeShieldValue(relativeShieldPercent) {
        var maxHP = this._player._maxHealth
        return (relativeShieldPercent / 100.0) * maxHP
    }
}
