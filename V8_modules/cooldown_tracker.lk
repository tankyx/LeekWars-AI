// ========================================
// Cooldown Tracker Module
// ========================================
// Tracks enemy chip cooldowns (Antidote, Shield, etc.) to optimize strategy
// Usage: If Antidote on cooldown → prioritize Poison scenarios

include('debug_config.lk')

global COOLDOWN_STATE = [:]  // entityId → chip cooldown info
global POISON_PHASE = "BAIT"  // Poison rotation phase: BAIT, DUMP, SUSTAIN
global ANTIDOTE_USED_THIS_FIGHT = false  // Track if enemy has used Antidote
global LAST_POISON_DUMP_TURN = -999  // Track when we last dumped poison
global PREV_ENEMY_POISON = 0  // Track previous turn's actual poison duration remaining for Antidote detection
global BAIT_START_TURN = 1  // Track when BAIT phase started (for timeout → DUMP)

class CooldownTracker {
    _target = null

    // Use LeekScript global constants for chip IDs (avoids ID mismatch with CHIP_DATABASE)
    static CHIP_ANTIDOTE_ID = CHIP_ANTIDOTE
    static CHIP_CURE_ID = CHIP_CURE
    static CHIP_REMISSION_ID = CHIP_REMISSION
    static CHIP_WALL_ID = CHIP_WALL
    static CHIP_FORTRESS_ID = CHIP_FORTRESS
    static CHIP_MIRROR_ID = CHIP_MIRROR
    static CHIP_SHIELD_ID = CHIP_SHIELD

    constructor(target) {
        this._target = target
    }

    // Detect if enemy used a chip by checking effect changes
    detectChipUsage(enemyId, previousEffects, currentEffects) {
        // Compare effect lists to detect new effects
        var newEffects = []

        for (var effect in currentEffects) {
            var effectType = effect['type']
            var isNew = true

            for (var prevEffect in previousEffects) {
                if (prevEffect['type'] == effectType) {
                    isNew = false
                    break
                }
            }

            if (isNew) {
                push(newEffects, effect)
            }
        }

        return newEffects
    }

    // Update cooldown tracking based on turn progression
    updateCooldowns(enemyId) {
        if (!mapContainsKey(COOLDOWN_STATE, enemyId)) {
            COOLDOWN_STATE[enemyId] = [:]
        }

        var entityCooldowns = COOLDOWN_STATE[enemyId]

        // Decrement all active cooldowns
        for (var chipId in mapKeys(entityCooldowns)) {
            var cooldownInfo = entityCooldowns[chipId]
            if (mapContainsKey(cooldownInfo, 'turnsRemaining')) {
                var remaining = cooldownInfo['turnsRemaining']
                if (remaining > 0) {
                    entityCooldowns[chipId]['turnsRemaining'] = remaining - 1
                }
            }
        }
    }

    // Record chip usage (sets cooldown)
    recordChipUse(enemyId, chipId) {
        if (!mapContainsKey(COOLDOWN_STATE, enemyId)) {
            COOLDOWN_STATE[enemyId] = [:]
        }

        var cooldown = this.getChipCooldown(chipId)
        if (cooldown > 0) {
            COOLDOWN_STATE[enemyId][chipId] = [
                'turnsRemaining': cooldown,
                'lastUsedTurn': getTurn()
            ]

            debugInfo("[COOLDOWN] " + getName(enemyId) + " used chip " + chipId + " (cooldown: " + cooldown + " turns)")
        }
    }

    // Get chip cooldown duration (hardcoded for key chips)
    getChipCooldown(chipId) {
        // Antidote/healing chips
        if (chipId == CooldownTracker.CHIP_ANTIDOTE_ID) return 4
        if (chipId == CooldownTracker.CHIP_CURE_ID) return 3
        if (chipId == CooldownTracker.CHIP_REMISSION_ID) return 6

        // Shield chips
        if (chipId == CooldownTracker.CHIP_WALL_ID) return 3
        if (chipId == CooldownTracker.CHIP_FORTRESS_ID) return 4
        if (chipId == CooldownTracker.CHIP_SHIELD_ID) return 4
        if (chipId == CooldownTracker.CHIP_MIRROR_ID) return 4

        // Default: no cooldown tracking
        return 0
    }

    // Check if chip is on cooldown
    isChipOnCooldown(enemyId, chipId) {
        if (!mapContainsKey(COOLDOWN_STATE, enemyId)) return false

        var entityCooldowns = COOLDOWN_STATE[enemyId]
        if (!mapContainsKey(entityCooldowns, chipId)) return false

        var cooldownInfo = entityCooldowns[chipId]
        if (!mapContainsKey(cooldownInfo, 'turnsRemaining')) return false

        return cooldownInfo['turnsRemaining'] > 0
    }

    // Get remaining cooldown turns
    getCooldownRemaining(enemyId, chipId) {
        if (!mapContainsKey(COOLDOWN_STATE, enemyId)) return 0

        var entityCooldowns = COOLDOWN_STATE[enemyId]
        if (!mapContainsKey(entityCooldowns, chipId)) return 0

        var cooldownInfo = entityCooldowns[chipId]
        if (!mapContainsKey(cooldownInfo, 'turnsRemaining')) return 0

        return cooldownInfo['turnsRemaining']
    }

    // Detect poison removal (indicates Antidote use)
    // prevPoison = actual remaining duration stored last turn
    // currPoison = current remaining duration from getEffectRemaining()
    // Natural decay: poison ticks down 1 per turn, so expected = prevPoison - 1
    // Antidote: clears ALL poison stacks instantly (currPoison = 0 when prevPoison > 1)
    detectAntidoteUse(enemyId, prevPoison, currPoison) {
        debugInfo("[ANTIDOTE-CHECK] enemyId=" + enemyId + " prevPoison=" + prevPoison + " currPoison=" + currPoison)

        // Natural decay: prevPoison -> prevPoison-1 is expected (1 turn passes)
        // If prevPoison was 1, it naturally expires to 0 — NOT an Antidote
        if (prevPoison <= 1) {
            debugInfo("[ANTIDOTE-CHECK] Poison naturally expired (prevPoison <= 1)")
            return false
        }

        // If poison was active (duration > 1) but now fully cleared, enemy used Antidote
        if (prevPoison > 1 && currPoison == 0) {
            debugInfo("[COOLDOWN] Detected Antidote use by " + getName(enemyId))
            this.recordChipUse(enemyId, CooldownTracker.CHIP_ANTIDOTE_ID)

            // Update poison phase: BAIT → DUMP
            ANTIDOTE_USED_THIS_FIGHT = true
            POISON_PHASE = "DUMP"
            debugInfo("[POISON-PHASE] Antidote detected! Switching BAIT → DUMP")

            return true
        }

        // Check for early cleanse (duration dropped by more than 1 turn = natural decay)
        if (prevPoison > currPoison + 1) {
            debugInfo("[COOLDOWN] Detected early poison cleanse by " + getName(enemyId))
            this.recordChipUse(enemyId, CooldownTracker.CHIP_ANTIDOTE_ID)
            return true
        }

        debugInfo("[ANTIDOTE-CHECK] No Antidote detected (natural decay or condition not met)")
        return false
    }

    // Check if Antidote is available (not on cooldown)
    isAntidoteAvailable(enemyId) {
        return !this.isChipOnCooldown(enemyId, CooldownTracker.CHIP_ANTIDOTE_ID)
    }

    // Get strategic poison window (turns until Antidote available)
    getPoisonWindow(enemyId) {
        var remaining = this.getCooldownRemaining(enemyId, CooldownTracker.CHIP_ANTIDOTE_ID)
        if (remaining > 0) {
            return remaining  // Turns of guaranteed poison damage
        }
        return 0  // Antidote available now
    }
}

// Global helper functions
function isEnemyAntidoteOnCooldown(enemyId) {
    var tracker = new CooldownTracker(null)
    return !tracker.isAntidoteAvailable(enemyId)
}

function getEnemyPoisonWindow(enemyId) {
    var tracker = new CooldownTracker(null)
    return tracker.getPoisonWindow(enemyId)
}
