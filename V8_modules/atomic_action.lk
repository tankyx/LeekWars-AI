include('world_state.lk')
include('cache_manager.lk')

// Helper function: Check if weapon needs line of sight
function weaponNeedsLoS(weaponObj) {
    var launchType = weaponObj._launchType
    // LINE, DIAGONAL, and STAR require LoS; CIRCLE does not
    return launchType == LAUNCH_TYPE_LINE || launchType == LAUNCH_TYPE_DIAGONAL || launchType == LAUNCH_TYPE_STAR
}

// =============================================================================
// AtomicAction - Primitive action vocabulary for emergent planning
// =============================================================================
//
// Defines the smallest executable units that can be composed into strategies.
// The Beam Search planner recombines these atoms to discover optimal sequences.
//
// Design goals:
// - Low branching factor (~50 actions/state, not 500)
// - Self-validating (knows when it's legal to execute)
// - Composable (chains naturally into multi-step plans)
// - Heuristic-guided (smart pruning, not exhaustive generation)
//
// Atom types:
// - MOVE_TACTICAL: Move to high-value cell (damage/threat-weighted)
// - USE_CHIP: Cast a chip on target
// - USE_WEAPON: Attack with weapon
// - SWAP_WEAPON: Change equipped weapon
// - TELEPORT: Instant repositioning (emergency/OTKO)
//
// =============================================================================

class AtomicAction {
    // Action types
    static MOVE_TACTICAL = 100
    static USE_CHIP = 101
    static USE_WEAPON = 102
    static SWAP_WEAPON = 103
    static TELEPORT = 104

    type = -1
    targetCell = -1         // For movement & teleport
    weaponId = -1           // For weapon actions
    chipId = -1             // For chip actions
    targetEnemyId = -1      // Target enemy (for attacks)

    tpCost = 0              // Cached cost (for fast pruning)
    mpCost = 0

    // Heuristic metadata (for beam search prioritization)
    estimatedDamage = 0
    estimatedHealing = 0
    estimatedShield = 0
    threatReduction = 0     // Moving to safer cell
    synergyBonus = 0        // Combo potential (set by generator)

    constructor(type) {
        this.type = type
    }

    // =========================================================================
    // Factory methods
    // =========================================================================

    static createMove(targetCell, mpCost, threatReduction) {
        var action = new AtomicAction(AtomicAction.MOVE_TACTICAL)
        action.targetCell = targetCell
        action.mpCost = mpCost
        action.threatReduction = threatReduction
        return action
    }

    static createChipUse(chipId, targetEnemyId, tpCost, damage, healing, shield) {
        var action = new AtomicAction(AtomicAction.USE_CHIP)
        action.chipId = chipId
        action.targetEnemyId = targetEnemyId
        action.tpCost = tpCost
        action.estimatedDamage = damage
        action.estimatedHealing = healing
        action.estimatedShield = shield
        return action
    }

    static createWeaponUse(weaponId, targetEnemyId, tpCost, damage) {
        var action = new AtomicAction(AtomicAction.USE_WEAPON)
        action.weaponId = weaponId
        action.targetEnemyId = targetEnemyId
        action.tpCost = tpCost
        action.estimatedDamage = damage
        return action
    }

    static createWeaponSwap(weaponId) {
        var action = new AtomicAction(AtomicAction.SWAP_WEAPON)
        action.weaponId = weaponId
        action.tpCost = 1
        return action
    }

    static createTeleport(targetCell, tpCost, threatReduction) {
        var action = new AtomicAction(AtomicAction.TELEPORT)
        action.targetCell = targetCell
        action.tpCost = tpCost
        action.threatReduction = threatReduction
        return action
    }

    // =========================================================================
    // Validation - Can this action execute from given state?
    // =========================================================================

    isValid(worldState, arsenal, fieldMap) {
        if (this.type == AtomicAction.MOVE_TACTICAL) {
            // Must have MP for path
            if (worldState.mp < this.mpCost) return false

            // Path must exist
            var pathLength = getCachedPathLength(worldState.cell, this.targetCell)
            if (pathLength == null || pathLength > worldState.mp) return false

            return true
        }
        else if (this.type == AtomicAction.USE_CHIP) {
            // Must have TP
            if (worldState.tp < this.tpCost) return false

            // Chip must not be on cooldown
            if (worldState.isChipOnCooldown(this.chipId)) return false

            // Check if this is a self-targeting chip (buffs, healing)
            if (this.isSelfTargetingChip(this.chipId)) {
                // No range/target validation needed for self-buffs
                return true
            }

            // For enemy-targeting chips, validate range and target
            var range = getChipMaxRange(this.chipId)
            var minRange = getChipMinRange(this.chipId)

            var target = this.getTargetEnemy(worldState)
            if (target == null) return false

            var distance = getCellDistance(worldState.cell, target.cellPos)
            if (distance < minRange || distance > range) return false

            return true
        }
        else if (this.type == AtomicAction.USE_WEAPON) {
            // Must have TP
            if (worldState.tp < this.tpCost) return false

            // Weapon must have uses left
            if (!worldState.hasWeaponUsesLeft(this.weaponId)) return false

            // Must be in range
            var weaponObj = arsenal.playerEquippedWeapons[this.weaponId]
            if (weaponObj == null) return false

            var target = this.getTargetEnemy(worldState)
            if (target == null) return false

            var distance = getCellDistance(worldState.cell, target.cellPos)
            if (distance < weaponObj._minRange || distance > weaponObj._maxRange) return false

            // Check line-of-sight for directional weapons
            if (weaponNeedsLoS(weaponObj)) {
                if (!lineOfSight(worldState.cell, target.cellPos, [target.cellPos])) {
                    return false
                }
            }

            return true
        }
        else if (this.type == AtomicAction.SWAP_WEAPON) {
            // Must have TP
            if (worldState.tp < 1) return false

            // Must not already be equipped
            if (worldState.currentWeapon == this.weaponId) return false

            // Must have the weapon
            if (!mapContainsKey(arsenal.playerEquippedWeapons, this.weaponId)) return false

            return true
        }
        else if (this.type == AtomicAction.TELEPORT) {
            // Must have TP
            if (worldState.tp < this.tpCost) return false

            // Distance must be valid (1-12)
            var distance = getCellDistance(worldState.cell, this.targetCell)
            if (distance < 1 || distance > 12) return false

            return true
        }

        return false
    }

    // =========================================================================
    // Helpers
    // =========================================================================

    getTargetEnemy(worldState) {
        for (var enemy in worldState.enemies) {
            if (enemy.id == this.targetEnemyId) {
                return enemy
            }
        }
        return null
    }

    isSelfTargetingChip(chipId) {
        // Buff chips (self-targeting)
        var buffChips = [
            CHIP_STEROID, CHIP_DOPING, CHIP_WARM_UP,
            CHIP_FORTRESS, CHIP_WALL, CHIP_SHIELD, CHIP_HELMET,
            CHIP_PROTEIN, CHIP_LEATHER_BOOTS, CHIP_ADRENALINE
        ]
        // Healing chips (self-targeting)
        var healingChips = [
            CHIP_REGENERATION, CHIP_REMISSION, CHIP_CURE, CHIP_DRIP
        ]
        // Teleportation (self-targeting, but handled separately)
        if (chipId == CHIP_TELEPORTATION) return true

        // Check if chip is in buff or healing lists
        for (var buff in buffChips) {
            if (buff == chipId) return true
        }
        for (var heal in healingChips) {
            if (heal == chipId) return true
        }
        return false
    }

    // =========================================================================
    // Heuristic score (for beam search prioritization)
    // =========================================================================

    getHeuristicValue() {
        // Quick score for early pruning
        return this.estimatedDamage + this.estimatedHealing + this.estimatedShield +
               this.threatReduction + this.synergyBonus
    }

    // =========================================================================
    // Debug
    // =========================================================================

    toString() {
        if (this.type == AtomicAction.MOVE_TACTICAL) {
            return "Move(cell=" + this.targetCell + ", mp=" + this.mpCost + ")"
        } else if (this.type == AtomicAction.USE_CHIP) {
            return "UseChip(chip=" + this.chipId + ", dmg=" + floor(this.estimatedDamage) + ")"
        } else if (this.type == AtomicAction.USE_WEAPON) {
            return "UseWeapon(weapon=" + this.weaponId + ", dmg=" + floor(this.estimatedDamage) + ")"
        } else if (this.type == AtomicAction.SWAP_WEAPON) {
            return "SwapWeapon(" + this.weaponId + ")"
        } else if (this.type == AtomicAction.TELEPORT) {
            return "Teleport(cell=" + this.targetCell + ")"
        }
        return "UnknownAction"
    }
}

// =============================================================================
// AtomicActionGenerator - Generates valid actions from a state
// =============================================================================
//
// Smart generation with branching control:
// - Movement: Top 10 tactical cells only (not all 612 cells)
// - Weapons: Only if in range or can reach range
// - Chips: Only if off cooldown
// - Target ~50 actions per state
//
// =============================================================================

class AtomicActionGenerator {
    _arsenal = null
    _fieldMap = null

    constructor(arsenal, fieldMap) {
        this._arsenal = arsenal
        this._fieldMap = fieldMap
    }

    // =========================================================================
    // Main entry point: Generate all valid actions from a state
    // =========================================================================

    generateActions(worldState) {
        var actions = []

        // 1. Movement actions (top 10 tactical cells)
        var movements = this.generateMovementActions(worldState)
        for (var action in movements) {
            push(actions, action)
        }

        // 2. Attack actions (weapons + damage chips)
        var attacks = this.generateAttackActions(worldState)
        for (var action in attacks) {
            push(actions, action)
        }

        // 3. Buff actions (only if not already buffed)
        var buffs = this.generateBuffActions(worldState)
        for (var action in buffs) {
            push(actions, action)
        }

        // 4. Utility actions (weapon swaps, teleport)
        var utilities = this.generateUtilityActions(worldState)
        for (var action in utilities) {
            push(actions, action)
        }

        return actions
    }

    // =========================================================================
    // Movement: Top 10 cells from tactical map
    // =========================================================================

    generateMovementActions(worldState) {
        var actions = []
        if (worldState.mp < 1) {
            return actions
        }

        // Get top tactical cells (damage-weighted or threat-weighted based on HP)
        var candidates = this._fieldMap.getTopTacticalCells(10, worldState.hp, worldState.maxHP)

        // If no tactical cells, generate simple "move closer" actions
        if (count(candidates) == 0) {
            var reachable = getReachableCells()
            if (count(reachable) > 0) {
                var target = worldState.getPrimaryTarget()
                if (target != null) {
                    // Find reachable cell closest to target
                    var bestCell = -1
                    var bestDist = 999
                    for (var cell in reachable) {
                        var dist = getCellDistance(cell, target.cellPos)
                        if (dist < bestDist) {
                            bestDist = dist
                            bestCell = cell
                        }
                    }
                    if (bestCell != -1) {
                        var pathLength = getCachedPathLength(worldState.cell, bestCell)
                        if (pathLength != null && pathLength > 0 && pathLength <= worldState.mp) {
                            var action = AtomicAction.createMove(bestCell, pathLength, 0)
                            push(actions, action)
                        }
                    }
                }
            }
        } else {
            for (var cellData in candidates) {
                var cell = cellData['cell']
                var threatReduction = cellData['threatReduction']
                var pathLength = getCachedPathLength(worldState.cell, cell)
                if (pathLength != null && pathLength > 0 && pathLength <= worldState.mp) {
                    var action = AtomicAction.createMove(cell, pathLength, threatReduction)
                    push(actions, action)
                }
            }
        }
        return actions
    }

    // =========================================================================
    // Attacks: Weapons + damage chips
    // =========================================================================

    generateAttackActions(worldState) {
        var actions = []
        var target = worldState.getPrimaryTarget()
        if (target == null || !target.isAlive) {
            return actions
        }

        // Weapon attacks (all equipped weapons)
        var weaponKeys = mapKeys(worldState.weaponUses)
        for (var weaponId in weaponKeys) {
            if (worldState.hasWeaponUsesLeft(weaponId)) {
                var weaponObj = this._arsenal.playerEquippedWeapons[weaponId]
                if (weaponObj != null) {
                    var distance = getCellDistance(worldState.cell, target.cellPos)
                    if (distance >= weaponObj._minRange && distance <= weaponObj._maxRange) {
                        var tpCost = weaponObj._cost
                        if (worldState.currentWeapon != weaponId) {
                            tpCost += 1
                        }
                        var damage = this._arsenal.getNetDamageAgainstTarget(
                            worldState.strength, worldState.magic, worldState.wisdom,
                            worldState.science, weaponId, target
                        )
                        var action = AtomicAction.createWeaponUse(weaponId, target.id, tpCost, damage)
                        push(actions, action)
                    }
                }
            }
        }

        // Damage chips (only off cooldown)
        var damageChips = this.getDamageChips()
        for (var chipId in damageChips) {
            if (!worldState.isChipOnCooldown(chipId)) {
                var tpCost = getChipCost(chipId)
                if (worldState.tp >= tpCost) {
                    var damage = this._arsenal.getNetDamageAgainstTarget(
                        worldState.strength, worldState.magic, worldState.wisdom,
                        worldState.science, chipId, target
                    )
                    var action = AtomicAction.createChipUse(chipId, target.id, tpCost, damage, 0, 0)
                    push(actions, action)
                }
            }
        }
        return actions
    }

    // =========================================================================
    // Buffs: Only if not already active
    // =========================================================================

    generateBuffActions(worldState) {
        var actions = []

        // SESSION 3 DEBUG: Always generate at least one buff to test

        // Damage buffs (STEROID, WARM_UP)
        if (!worldState.damageBuffActive) {
            var hasSteroid = mapContainsKey(this._arsenal.playerEquippedChips, CHIP_STEROID)
            if (hasSteroid) {
                var cost1 = getChipCost(CHIP_STEROID)
                if (worldState.tp >= cost1) {
                    push(actions, AtomicAction.createChipUse(CHIP_STEROID, -1, cost1, 0, 0, 0))
                }
            }
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WARM_UP)) {
                var cost2 = getChipCost(CHIP_WARM_UP)
                if (worldState.tp >= cost2) {
                    push(actions, AtomicAction.createChipUse(CHIP_WARM_UP, -1, cost2, 0, 0, 0))
                }
            }
        }

        // Shield buffs (FORTRESS, WALL)
        if (worldState.shieldBuffTurns <= 1) {
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_FORTRESS)) {
                var cost3 = getChipCost(CHIP_FORTRESS)
                if (worldState.tp >= cost3) {
                    var shield = 400 + worldState.wisdom * 4
                    push(actions, AtomicAction.createChipUse(CHIP_FORTRESS, -1, cost3, 0, 0, shield))
                }
            }
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_WALL)) {
                var cost4 = getChipCost(CHIP_WALL)
                if (worldState.tp >= cost4) {
                    var shield2 = 200 + worldState.wisdom * 2
                    push(actions, AtomicAction.createChipUse(CHIP_WALL, -1, cost4, 0, 0, shield2))
                }
            }
        }

        // Healing (REMISSION, REGENERATION)
        if (worldState.hp < worldState.maxHP * 0.7) {
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REMISSION)) {
                var cost5 = getChipCost(CHIP_REMISSION)
                if (worldState.tp >= cost5) {
                    var healing = this._arsenal.getExpectedHeal(CHIP_REMISSION, worldState.wisdom)
                    push(actions, AtomicAction.createChipUse(CHIP_REMISSION, -1, cost5, 0, healing, 0))
                }
            }
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_REGENERATION)) {
                var cost6 = getChipCost(CHIP_REGENERATION)
                if (worldState.tp >= cost6 && !worldState.isChipOnCooldown(CHIP_REGENERATION)) {
                    var healing2 = this._arsenal.getExpectedHeal(CHIP_REGENERATION, worldState.wisdom)
                    push(actions, AtomicAction.createChipUse(CHIP_REGENERATION, -1, cost6, 0, healing2, 0))
                }
            }
        }
        return actions
    }

    // =========================================================================
    // Utility: Weapon swaps, teleport
    // =========================================================================

    generateUtilityActions(worldState) {
        var actions = []

        // Teleport (emergency escape when HP < 30%)
        if (worldState.hp < worldState.maxHP * 0.3) {
            if (mapContainsKey(this._arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
                var cost = getChipCost(CHIP_TELEPORTATION)
                if (worldState.tp >= cost) {
                    var safeCell = this._fieldMap.getSafestCell(worldState.cell)
                    if (safeCell != -1) {
                        var currentThreat = this._fieldMap.getThreatAtCell(worldState.cell)
                        var newThreat = this._fieldMap.getThreatAtCell(safeCell)
                        var threatReduction = currentThreat - newThreat
                        push(actions, AtomicAction.createTeleport(safeCell, cost, threatReduction))
                    }
                }
            }
        }
        return actions
    }

    // =========================================================================
    // Chip catalogs
    // =========================================================================

    getDamageChips() {
        var chips = []
        var damageChipIds = [
            CHIP_ROCKFALL, CHIP_ICEBERG, CHIP_METEORITE, CHIP_STALACTITE,
            CHIP_LIGHTNING, CHIP_SPARK, CHIP_FLAME, CHIP_BALL_AND_CHAIN,
            CHIP_PEBBLE, CHIP_ROCK
        ]
        for (var chipId in damageChipIds) {
            if (mapContainsKey(this._arsenal.playerEquippedChips, chipId)) {
                push(chips, chipId)
            }
        }
        return chips
    }
}
