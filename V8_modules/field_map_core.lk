include('game_entity.lk')

// ====================================================================
// CORE DATA STRUCTURES
// ====================================================================

class Cell {
    _id
    _isObstacle = false
    _entityID = -1
    _weaponDamage = 0
    _chipDamage = 0
    _totalDamage = 0
    _directDamage = 0 // immediate damage portion
    _dotDamage = 0 // cumulative DoT (poison) portion
    _bestType = -1
    _hasLOS = false
    _highestDamageWeapon = -1
    _highestDamageChip = -1
    _weaponsList = [] // all weapons that can fire from this cell
    _chipsList = []   // all chips that can fire from this cell

    constructor(id, isObstacle, entityID, weaponDamage, chipDamage, hasLOS, highestDamageWeapon, highestDamageChip) {
        this._id = id
        this._isObstacle = isObstacle
        this._entityID = entityID
        this._weaponDamage = weaponDamage
        this._chipDamage = chipDamage
        this._hasLOS = hasLOS
        this._highestDamageWeapon = highestDamageWeapon
        this._highestDamageChip = highestDamageChip
        this._totalDamage = weaponDamage + chipDamage
        if (weaponDamage >= chipDamage && weaponDamage > 0) this._bestType = 0
        else if (chipDamage > weaponDamage) this._bestType = 1
    }
}

class Color {
    _r = 0
    _g = 0
    _b = 0

    constructor(r, g, b) {
        this._r = r
        this._g = g
        this._b = b
    }

    getIntColor() {
        return getColor(this._r, this._g, this._b)
    }
}

// ====================================================================
// FIELD MAP - CORE (Entity Management & Basic Queries)
// ====================================================================

class FieldMapCore {
    cells = [:]
    entities = [:]
    wColors = [:]
    cColors = [:]

    private static x_offset = 18
    private static y_offset = 17
    private static base_cell = 308
    private static board_cell_count = 613

    constructor() {
        var playerID = getEntity()

        // Assign colors for weapons
        var k = 1
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            mapPut(this.wColors, wid, new Color((k * 50) % 255, (k * 80) % 255, (k * 110) % 255))
            k++
        }

        // Assign colors for chips
        var kc = 1
        for (var cid in mapKeys(arsenal.playerEquippedChips)) {
            var cObj = arsenal.playerEquippedChips[cid]
            mapPut(this.cColors, cid, new Color((kc * 70) % 255, (kc * 40) % 255, (kc * 95) % 255))
            kc++
        }

        // Initialize all cells and detect entities
        for (var i = 0; i < FieldMapCore.board_cell_count; i++) {
            var isObs = isObstacle(i)
            var entID = -1

            if (isEntity(i)) {
                entID = getEntityOnCell(i)

                // Check entity type (chest, mob, bulb, turret, leek)
                var entityType = getType(entID)

                if (entityType == ENTITY_CHEST) {
                    mapPut(this.entities, entID, new Chest(i))
                    debug("[ENTITY] Chest detected at cell " + i + " (ID: " + entID + ")")
                }
                else if (isAlly(entID)) {
                    if (entID == playerID) {
                        mapPut(this.entities, entID, new Player(i))
                    } else {
                        mapPut(this.entities, entID, new Player(i)) // Ally teammate
                    }
                }
                else {
                    // Check if this is a boss fight entity (Grail or Crystal)
                    var entityName = getName(entID)

                    if (entityName == "graal") {
                        mapPut(this.entities, entID, new Enemy(i))
                        debug("[ENTITY] Graal detected at cell " + i + " (ID: " + entID + ")")
                    }
                    else if (entityName == "red_crystal" || entityName == "green_crystal" || entityName == "blue_crystal" || entityName == "yellow_crystal") {
                        mapPut(this.entities, entID, new Enemy(i))
                        debug("[ENTITY] Crystal '" + entityName + "' detected at cell " + i + " (ID: " + entID + ")")
                    }
                    else {
                        mapPut(this.entities, entID, new Enemy(i))
                    }
                }
            }

            mapPut(this.cells, i, new Cell(i, isObs, entID, 0, 0, false, -1, -1))
        }
    }

    // ====================================================================
    // ENTITY MANAGEMENT
    // ====================================================================

    updateMapEntities() {
        for (var entity in this.entities) {
            if (entity != null) {
                entity.updateEntity()
            }
        }
    }

    getAlliesSubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Player) && key != getEntity()
        })
    }

    getEnemySubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Enemy)
        })
    }

    getChestSubMap() {
        return mapFilter(entities, function(value, key, entities) {
            return (value instanceof Chest)
        })
    }

    // ====================================================================
    // BASIC QUERIES
    // ====================================================================

    getClosestEnemy() {
        var playerPos = player._cellPos
        var closestEnemy = null
        var closestDist = 999

        var enemies = this.getEnemySubMap()
        for (var e in enemies) {
            // Skip dead enemies (Battle Royale fix)
            if (isDead(e._id)) continue

            var dist = getCellDistance(playerPos, e._cellPos)

            if (dist < closestDist) {
                closestDist = dist
                closestEnemy = e
            }
        }
        return closestEnemy
    }

    // Select optimal target based on tactical criteria
    // criteria: optional map {prioritizeLowest: "hp"|"distance", bonusForDebuffed: bool, penalizeBuffed: bool}
    selectOptimalTarget(criteria = null) {
        var enemyMap = this.getEnemySubMap()
        var enemies = mapValues(enemyMap)  // Convert map to array
        if (count(enemies) == 0) return null
        if (count(enemies) == 1) return enemies[0]

        // Default criteria
        var priorityMode = criteria != null && mapContainsKey(criteria, 'prioritizeLowest') ? criteria['prioritizeLowest'] : "hp"
        var penalizeBuffed = criteria != null && mapContainsKey(criteria, 'penalizeBuffed') ? criteria['penalizeBuffed'] : false
        var bonusForDebuffed = criteria != null && mapContainsKey(criteria, 'bonusForDebuffed') ? criteria['bonusForDebuffed'] : false

        var bestTarget = null
        var bestScore = -99999
        var playerPos = player._cellPos

        for (var e in enemies) {
            if (isDead(e._id)) continue

            var score = 0
            var dist = getCellDistance(playerPos, e._cellPos)
            if (dist == null) continue

            // HP priority: favor low HP targets (easier kills)
            var enemyHP = getLife(e._id)
            var enemyMaxHP = getTotalLife(e._id)
            var hpPercent = (enemyHP * 100) / enemyMaxHP

            if (priorityMode == "hp") {
                // Lower HP = higher score (100 - hpPercent)
                score += (100 - hpPercent) * 2  // Weight: 0-200 points
                // Distance penalty (closer = better)
                score -= dist * 5  // -5 per cell distance
            } else {
                // Distance priority
                score -= dist * 10
                // HP bonus (still prefer low HP)
                score += (100 - hpPercent)
            }

            // Bonus for debuffed enemies (POISON, SHACKLE_TP, etc.)
            if (bonusForDebuffed) {
                var effects = getEffects(e._id)
                if (effects != null) {
                    for (var eff in effects) {
                        if (eff[0] == EFFECT_POISON) score += 30  // Poisoned = priority
                        if (eff[0] == EFFECT_SHACKLE_TP) score += 20  // Low TP = vulnerable
                        if (eff[0] == EFFECT_SHACKLE_MP) score += 15  // Low mobility
                    }
                }
            }

            // Penalty for buffed enemies (BUFF_STRENGTH, shields, etc.)
            if (penalizeBuffed) {
                if (e._absShield > 50 || e._relShield > 20) score -= 25  // Heavily shielded
                var effsBuff = getEffects(e._id)
                if (effsBuff != null) {
                    for (var effB in effsBuff) {
                        if (effB[0] == EFFECT_BUFF_STRENGTH) score -= 20  // High damage threat
                        if (effB[0] == EFFECT_DAMAGE_RETURN) score -= 15  // Damage return = risky
                    }
                }
            }

            if (score > bestScore) {
                bestScore = score
                bestTarget = e
            }
        }

        if (bestTarget != null) {
            debug("[TARGET-PRIORITY] Selected enemy " + bestTarget._id + " (score=" + floor(bestScore) + " HP=" + floor((getLife(bestTarget._id) * 100) / getTotalLife(bestTarget._id)) + "%)")
        }

        return bestTarget
    }

    getClosestChest() {
        var playerPos = player._cellPos
        var closestChest = null
        var closestDist = 999

        var chests = this.getChestSubMap()
        for (var c in chests) {
            // Skip dead chests
            if (isDead(c._id)) continue

            var dist = getCellDistance(playerPos, c._cellPos)

            if (dist < closestDist) {
                closestDist = dist
                closestChest = c
            }
        }
        return closestChest
    }

    // ====================================================================
    // UTILITY METHODS
    // ====================================================================

    getCellID(x, y) {
        return FieldMapCore.base_cell + FieldMapCore.x_offset * x + FieldMapCore.y_offset * y
    }

    getPlayerPos() {
        return player._cellPos
    }

    isDamageItem(item) {
        return mapContainsKey(item._effects, EFFECT_DAMAGE) || mapContainsKey(item._effects, EFFECT_POISON)
    }

    // Get all cells affected by AoE around a center cell
    getAoEAffectedCells(centerCell, aoeType) {
        var affected = []

        // AREA_POINT - only the center cell
        if (aoeType == AREA_POINT) {
            push(affected, centerCell)
            return affected
        }

        // Always include center cell
        push(affected, centerCell)

        // AREA_CIRCLE_1, AREA_CIRCLE_2, AREA_CIRCLE_3
        if (aoeType == AREA_CIRCLE_1 || aoeType == AREA_CIRCLE_2 || aoeType == AREA_CIRCLE_3) {
            var radius = (aoeType == AREA_CIRCLE_1) ? 1 : ((aoeType == AREA_CIRCLE_2) ? 2 : 3)
            for (var dx = -radius; dx <= radius; dx++) {
                for (var dy = -radius; dy <= radius; dy++) {
                    var dist = abs(dx) + abs(dy)
                    if (dist > 0 && dist <= radius) {
                        var cellId = centerCell + FieldMapCore.x_offset * dx + FieldMapCore.y_offset * dy
                        if (cellId >= 0 && cellId < FieldMapCore.board_cell_count) {
                            push(affected, cellId)
                        }
                    }
                }
            }
        }
        // AREA_PLUS_1, AREA_PLUS_2, AREA_PLUS_3 (cross pattern)
        else if (aoeType == AREA_PLUS_1 || aoeType == AREA_PLUS_2 || aoeType == AREA_PLUS_3) {
            var radius = (aoeType == AREA_PLUS_1) ? 1 : ((aoeType == AREA_PLUS_2) ? 2 : 3)
            for (var d = 1; d <= radius; d++) {
                var cells = [
                    centerCell + FieldMapCore.x_offset * d,  // right
                    centerCell - FieldMapCore.x_offset * d,  // left
                    centerCell + FieldMapCore.y_offset * d,  // down
                    centerCell - FieldMapCore.y_offset * d   // up
                ]
                for (var c in cells) {
                    if (c >= 0 && c < FieldMapCore.board_cell_count) push(affected, c)
                }
            }
        }
        // AREA_X_1, AREA_X_2, AREA_X_3 (diagonal X pattern)
        else if (aoeType == AREA_X_1 || aoeType == AREA_X_2 || aoeType == AREA_X_3) {
            var radius = (aoeType == AREA_X_1) ? 1 : ((aoeType == AREA_X_2) ? 2 : 3)
            var up_right_offset = FieldMapCore.x_offset - FieldMapCore.y_offset
            var down_right_offset = FieldMapCore.x_offset + FieldMapCore.y_offset
            var down_left_offset = -1 * (FieldMapCore.x_offset - FieldMapCore.y_offset)
            var up_left_offset = -1 * (FieldMapCore.x_offset + FieldMapCore.y_offset)
            for (var d = 1; d <= radius; d++) {
                var cells = [
                    centerCell + up_right_offset * d,
                    centerCell + down_right_offset * d,
                    centerCell + down_left_offset * d,
                    centerCell + up_left_offset * d
                ]
                for (var c in cells) {
                    if (c >= 0 && c < FieldMapCore.board_cell_count) push(affected, c)
                }
            }
        }
        // AREA_SQUARE_1, AREA_SQUARE_2
        else if (aoeType == AREA_SQUARE_1 || aoeType == AREA_SQUARE_2) {
            var radius = (aoeType == AREA_SQUARE_1) ? 1 : 2
            for (var dx = -radius; dx <= radius; dx++) {
                for (var dy = -radius; dy <= radius; dy++) {
                    if (dx == 0 && dy == 0) continue // already added center
                    var cellId = centerCell + FieldMapCore.x_offset * dx + FieldMapCore.y_offset * dy
                    if (cellId >= 0 && cellId < FieldMapCore.board_cell_count) {
                        push(affected, cellId)
                    }
                }
            }
        }
        // AREA_LASER_LINE - handled differently (linear along shot path)
        else if (aoeType == AREA_LASER_LINE) {
            // Laser AoE affects cells along line of fire, not radially
            // Handle during actual shot - treat as single target for damage calc
        }

        return affected
    }
}
