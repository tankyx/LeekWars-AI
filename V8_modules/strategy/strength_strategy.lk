include('action.lk')
include('base_strategy.lk')

class StrengthStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "STR"
    }

    createOTKOScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST-OTKO] Chest detected! Switching OTKO target from enemy to chest (ID: " + chest._id + ")")
            target = chest
        }

        // Check if CHIP_TELEPORTATION is equipped
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            debug("[OTKO] Teleportation not equipped")
            return false
        }

        // Check cooldown (0 = available)
        var cooldown = getCooldown(CHIP_TELEPORTATION, getEntity())
        if (cooldown > 0) {
            debug("[OTKO] Teleportation on cooldown: " + cooldown + " turns")
            return false
        }

        // Check minimum TP budget (9 for teleport + weapon costs)
        var playerTP = player._currTp
        if (playerTP < 15) {  // 9 + minimum 6 TP for one weapon use
            debug("[OTKO] Insufficient TP for teleport OTKO: " + playerTP)
            return false
        }

        // Find optimal teleport cell
        var teleportInfo = fieldMap.findOptimalTeleportCell(target)
        if (teleportInfo == null) {
            debug("[OTKO] No valid teleport cells found")
            return false
        }

        // Only proceed if we have 85%+ kill probability (or if target is chest - always prioritize chests)
        var killProb = teleportInfo['killProbability']
        if (killProb < 0.85 && !(target instanceof Chest)) {
            debug("[OTKO] Kill probability too low: " + round(killProb * 100) + "% (damage: " + teleportInfo['damage'] + " vs HP: " + target._currHealth + ")")

            // Check if CHIP_ADRENALINE can bridge the gap
            if (this.shouldUseAdrenaline(15)) {  // Need at least 15 TP for meaningful OTKO
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
                playerTP -= 1
                playerTP += 5  // Net gain of 4 TP
                player._currTp = playerTP  // Update player TP for recalculation
                debug("[OTKO][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")

                // RECALCULATE with new TP budget
                teleportInfo = fieldMap.findOptimalTeleportCell(target)
                if (teleportInfo == null) {
                    debug("[OTKO][ADRENALINE] Recalculation failed")
                    return false
                }

                var newKillProb = teleportInfo['killProbability']
                if (newKillProb < 0.85) {
                    debug("[OTKO][ADRENALINE] Still insufficient kill probability after Adrenaline: " + round(newKillProb * 100) + "% (damage: " + teleportInfo['damage'] + " vs HP: " + target._currHealth + ")")
                    return false
                }
                debug("[OTKO][ADRENALINE] Recalculated kill probability: " + round(newKillProb * 100) + "% (sufficient for OTKO)")
            } else {
                return false
            }
        }

        var teleCell = teleportInfo['cell']
        debug("[OTKO] Executing teleport OTKO to cell " + teleCell + " projected damage: " + teleportInfo['damage'])

        // Track planned weapon swaps (since we're queuing actions, not executing)
        var plannedWeapon = getWeapon()

        // PRE-OTKO NEUTRINO STACKING: Amplify teleport burst damage with 24% vulnerability
        // Only stack if we have Neutrino equipped, enemy in diagonal range 2-6, and sufficient TP
        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO) && playerTP >= 21) {
            var preTeleportDist = getCellDistance(player._cellPos, target._cellPos)
            var preTeleportAligned = this.isDiagonal(player._cellPos, target._cellPos)

            // Check if we can stack from current position before teleport
            if (preTeleportDist != null && preTeleportDist >= 2 && preTeleportDist <= 6 &&
                preTeleportAligned && lineOfSight(player._cellPos, target._cellPos)) {

                debug("[OTKO][NEUTRINO] Pre-stacking vulnerability before teleport for amplified OTKO")

                // Stack 3x Neutrino for 24% damage amplification (1.24x multiplier)
                // QUEUE these actions instead of executing immediately
                if (plannedWeapon != WEAPON_NEUTRINO) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, WEAPON_NEUTRINO, -1)
                    playerTP -= 1
                    plannedWeapon = WEAPON_NEUTRINO
                }

                for (var nStack = 0; nStack < 3; nStack++) {
                    if (playerTP >= 4) {
                        this.createAttackAction(Action.ACTION_DIRECT, target, WEAPON_NEUTRINO, -1)
                        playerTP -= 4
                    }
                }

                debug("[OTKO][NEUTRINO] Queued 3x Neutrino for 24% vulnerability stacking, TP remaining: " + playerTP + " - now queueing teleport + burst")
            } else {
                debug("[OTKO][NEUTRINO] Cannot pre-stack: dist=" + preTeleportDist + " (need 2-6), diagonal=" + preTeleportAligned + ", TP=" + playerTP)
            }
        }

        // Execute teleportation
        this.createAttackAction(Action.ACTION_TELEPORT, target, -1, CHIP_TELEPORTATION)
        // Override targetCell to teleport destination (not target's position)
        this._actions[count(this._actions) - 1].targetCell = teleCell
        playerTP -= 9

        // Update simulated player position
        var playerPos = teleCell

        // Execute weapon attacks from teleport position
        // Build list of usable weapons sorted by shield-adjusted damage
        var weaponDmgList = []
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            // Check if weapon can hit target from teleport cell
            var distToTarget = getCellDistance(teleCell, target._cellPos)
            if (distToTarget == null) continue
            if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
            if (!lineOfSight(teleCell, target._cellPos)) continue

            var netDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, player._science, wid, target)
            push(weaponDmgList, ['weapon': wObj, 'netDmg': netDmg])
        }

        // Sort by descending net damage (selection sort)
        for (var i = 0; i < count(weaponDmgList); i++) {
            var bestIdx = i
            for (var j = i + 1; j < count(weaponDmgList); j++) {
                if (weaponDmgList[j]['netDmg'] > weaponDmgList[bestIdx]['netDmg']) bestIdx = j
            }
            if (bestIdx != i) {
                var tmp = weaponDmgList[i]
                weaponDmgList[i] = weaponDmgList[bestIdx]
                weaponDmgList[bestIdx] = tmp
            }
        }

        // Execute weapons in order of net damage
        for (var wi = 0; wi < count(weaponDmgList); wi++) {
            var wRec = weaponDmgList[wi]
            var wObj = wRec['weapon']

            // Swap weapon if needed
            if (plannedWeapon != wObj._id) {
                if (playerTP >= 1 + wObj._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                    plannedWeapon = wObj._id
                } else {
                    continue  // Not enough TP to swap and use
                }
            }

            // Use weapon maximum times
            var uses = min(wObj._maxUse, floor(playerTP / wObj._cost))
            while (uses > 0 && playerTP >= wObj._cost) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses -= 1
            }

            if (playerTP <= 0) break
        }

        // Use damage chips with remaining TP
        if (playerTP > 0) {
            var chipDmgList = []
            for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                if (cid == CHIP_TELEPORTATION) continue

                // Filter attack chips
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                // Check range and LOS from teleport cell
                var distChip = getCellDistance(teleCell, target._cellPos)
                if (distChip == null) continue
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(teleCell, target._cellPos)) continue

                var netChipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, player._science, cid, target)
                push(chipDmgList, ['chip': chipObj, 'netDmg': netChipDmg])
            }

            // Sort chips by net damage
            for (var ci = 0; ci < count(chipDmgList); ci++) {
                var bestCIdx = ci
                for (var cj = ci + 1; cj < count(chipDmgList); cj++) {
                    if (chipDmgList[cj]['netDmg'] > chipDmgList[bestCIdx]['netDmg']) bestCIdx = cj
                }
                if (bestCIdx != ci) {
                    var tmpC = chipDmgList[ci]
                    chipDmgList[ci] = chipDmgList[bestCIdx]
                    chipDmgList[bestCIdx] = tmpC
                }
            }

            // Execute chips
            for (var chipIdx = 0; chipIdx < count(chipDmgList); chipIdx++) {
                var cRec = chipDmgList[chipIdx]
                var chipUse = cRec['chip']
                if (playerTP < chipUse._cost) continue
                // Spam chip until max uses OR TP exhausted
                var actualUsesC = 0
                while (actualUsesC < chipUse._maxUse && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    actualUsesC += 1
                }
                if (playerTP <= 0) break
            }
        }

        debug("[OTKO] OTKO scenario complete, remaining TP: " + playerTP)
        return true
    }

    // Check if CHIP_STEROID should be used (strength buff)
    shouldUseSteroid() {
        // CHIP_STEROID: 7 TP cost, need 15 TP minimum (7 + 8 for attacks)
        if (!this.shouldApplyStatBuff(CHIP_STEROID, EFFECT_BUFF_STRENGTH, 15)) return false

        // Validate TP budget (7 TP for STEROID + minimum for attacks)
        if (!this.validateTPBudget(7)) return false

        return true
    }

    // Check if player is in combat range (any enemy within distance 8)
    isInCombatRange() {
        var enemies = fieldMap.getEnemySubMap()
        for (var e in enemies) {
            if (isDead(e._id)) continue
            var dist = getCellDistance(player._cellPos, e._cellPos)
            if (dist != null && dist <= 8) {
                debug("[STR][COMBAT-RANGE] Enemy ID=" + e._id + " at distance " + dist + " (in combat range)")
                return true
            }
        }
        debug("[STR][COMBAT-RANGE] No enemies within distance 8 (not in combat)")
        return false
    }

    // Check if CHIP_ANTIDOTE should be used (poison removal + heal)
    shouldUseAntidote() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_ANTIDOTE)) {
            debug("[STR][ANTIDOTE] Not equipped")
            return false
        }

        var cooldown = getCooldown(CHIP_ANTIDOTE, getEntity())
        if (cooldown > 0) {
            debug("[STR][ANTIDOTE] On cooldown: " + cooldown + " turns")
            return false
        }

        var playerTP = player._currTp
        if (playerTP < 3) {
            debug("[STR][ANTIDOTE] Insufficient TP: " + playerTP + " < 3")
            return false
        }

        // Check if poisoned
        if (!player.hasEffect(EFFECT_POISON)) {
            debug("[STR][ANTIDOTE] Not poisoned")
            return false
        }

        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)
        if (poisonRemaining < 2) {
            debug("[STR][ANTIDOTE] Poison too weak: " + poisonRemaining + " turns remaining")
            return false
        }

        // SMART ANTIDOTE: Calculate if poison is sustainable with available healing
        // Only use antidote if: poison_damage > available_healing OR poison is lethal
        // With liberal REMISSION usage, we can sustain through most poisons

        // Get poison damage per turn
        var poisonDamagePerTurn = player.getEffectValue(EFFECT_POISON)
        if (poisonDamagePerTurn == null) poisonDamagePerTurn = 0

        var totalPoisonDamage = poisonDamagePerTurn * poisonRemaining

        // Calculate available healing resources
        var availableHealing = 0

        // REMISSION: 125 HP average (100-150 range), costs 5 TP (liberal sustain heal)
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REMISSION)) {
            var remissionCD = getCooldown(CHIP_REMISSION, getEntity())
            if (remissionCD == 0 && playerTP >= 10) {  // Need 5 for REMISSION + 5 reserve (liberal threshold)
                availableHealing += 125
            }
        }

        // REGENERATION: 500 HP, costs 8 TP (emergency heal for < 25% HP)
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)) {
            var regenCD = getCooldown(CHIP_REGENERATION, getEntity())
            if (regenCD == 0 && playerTP >= 11) {  // Need 8 for REGEN + 3 reserve
                availableHealing += 500
            }
        }

        // Check if poison is lethal (would kill us before we can heal)
        var currentHP = player._currHealth
        if (totalPoisonDamage >= currentHP) {
            debug("[STR][ANTIDOTE] LETHAL poison: " + totalPoisonDamage + " total dmg (" + poisonDamagePerTurn + "/turn × " + poisonRemaining + " turns) vs " + currentHP + " HP - MUST CLEANSE!")
            return true
        }

        // Check if we can sustain poison with available healing
        if (totalPoisonDamage <= availableHealing) {
            debug("[STR][ANTIDOTE] Poison SUSTAINABLE: " + totalPoisonDamage + " dmg (" + poisonDamagePerTurn + "/turn) vs " + availableHealing + " heal available - saving antidote")
            return false  // Don't waste antidote, we can heal through it
        }

        // Poison damage exceeds healing - use antidote
        debug("[STR][ANTIDOTE] Poison NOT sustainable: " + totalPoisonDamage + " dmg (" + poisonDamagePerTurn + "/turn × " + poisonRemaining + " turns) vs " + availableHealing + " heal - using ANTIDOTE")
        return true
    }

    // Check if CHIP_THERAPY should be used (emergency healing)
    shouldUseTherapy() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_THERAPY)) return false

        var cooldown = getCooldown(CHIP_THERAPY, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 13) return false  // 7 TP for THERAPY + 6 minimum for attacks

        // Use when HP below 40% (emergency healing)
        var hpPercent = (player._currHealth * 100) / player._maxHealth
        if (hpPercent >= 40) return false

        var hpMissing = player._maxHealth - player._currHealth
        if (hpMissing < 50) return false  // Don't waste if only missing small amount of HP

        debug("[STR][THERAPY] HP at " + hpPercent + "% (" + player._currHealth + "/" + player._maxHealth + "), should use THERAPY")
        return true
    }

    // Find best cell to target with CHIP_THERAPY to heal self
    // CHIP_THERAPY: Range 1-5, Area plus 2 (+ pattern with radius 2)
    findTherapyTarget() {
        var playerPos = player._cellPos

        // Get THERAPY chip object for AoE type
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_THERAPY)) return null
        var therapyChip = arsenal.playerEquippedChips[CHIP_THERAPY]

        // Try to target an adjacent cell (range 1) to maximize chance of hitting self in AoE
        var adjacentCells = [
            getCellFromXY(getCellX(playerPos) + 1, getCellY(playerPos)),
            getCellFromXY(getCellX(playerPos) - 1, getCellY(playerPos)),
            getCellFromXY(getCellX(playerPos), getCellY(playerPos) + 1),
            getCellFromXY(getCellX(playerPos), getCellY(playerPos) - 1)
        ]

        for (var targetCell in adjacentCells) {
            if (targetCell == null) continue

            // Check if this cell is valid and in range
            var dist = getCellDistance(playerPos, targetCell)
            if (dist == null || dist < 1 || dist > 5) continue

            // Check if player would be in the AoE (+ pattern radius 2)
            var affectedCells = fieldMap.getAoEAffectedCells(targetCell, therapyChip._aoeType, playerPos)
            var playerInAoE = false
            for (var i = 0; i < count(affectedCells); i++) {
                if (affectedCells[i] == playerPos) {
                    playerInAoE = true
                    break
                }
            }

            if (playerInAoE) {
                debug("[STR][THERAPY] Found valid therapy target cell: " + targetCell)
                return targetCell
            }
        }

        debug("[STR][THERAPY] No valid therapy target cell found")
        return null
    }

    // Check if CHIP_INVERSION should be used (hybrid: heal + damage setup)
    shouldUseInversion(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_INVERSION)) return false

        var cooldown = getCooldown(CHIP_INVERSION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 13) return false  // 4 TP for INVERSION + 9 minimum for one weapon attack

        // Check if enemy in line (horizontal or vertical) within range 1-14
        var playerPos = player._cellPos
        var targetPos = target._cellPos
        var dist = getCellDistance(playerPos, targetPos)
        if (dist == null || dist < 1 || dist > 14) return false

        // Check horizontal or vertical alignment
        var playerX = getCellX(playerPos)
        var playerY = getCellY(playerPos)
        var targetX = getCellX(targetPos)
        var targetY = getCellY(targetPos)

        var isAligned = (playerX == targetX) || (playerY == targetY)
        if (!isAligned) return false

        // Check line of sight
        if (!lineOfSight(playerPos, targetPos)) return false

        debug("[STR][INVERSION] Enemy in line at distance " + dist + ", TP=" + playerTP + " (offensive usage)")
        return true
    }

    // Calculate total TP needed for STEROID + GRAPPLE-HEAVY_SWORD combo
    getComboRequiredTP() {
        var requiredTP = 0

        // STEROID cost (if available)
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
            var cooldown = getCooldown(CHIP_STEROID, getEntity())
            if (cooldown == 0) {
                requiredTP += 7  // STEROID
            }
        }

        // GRAPPLE + HEAVY_SWORD cost
        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD) &&
            mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
            var grappleCooldown = getCooldown(CHIP_GRAPPLE, getEntity())
            if (grappleCooldown == 0) {
                requiredTP += 18  // GRAPPLE (3) + HEAVY_SWORD (15)
            }
        }

        if (requiredTP > 0) {
            debug("[STR][COMBO-TP] Combo requires " + requiredTP + " TP")
        }

        return requiredTP
    }

    // NOTE: FORTRESS and WALL defensive buffs are now applied on Turn 1 in base_strategy.lk
    // when enemy is far (dist > 10). This ensures shields are active during the approach phase.
    // Old shouldUseFortress() and shouldUseWall() methods removed - defensive buffs handled centrally.

    // Check if CHIP_LIBERATION is tactically valuable
    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        // Check range to target
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        // Priority 1: Remove critical player debuffs (shackles reducing our combat effectiveness)
        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        // Priority 2: Remove player poison if significant
        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        // Priority 3: Remove enemy buffs/shields/damage return/resistance
        var enemyShielded = target._relShield > 15 || target._absShield > 30
        var enemyHasDamageReturn = target.hasEffect(EFFECT_DAMAGE_RETURN)
        var enemyHasResistance = target.hasEffect(EFFECT_BUFF_RESISTANCE)

        // Use if we have critical debuffs OR poison with 3+ turns OR enemy heavily buffed
        if (hasDebuff) {
            debug("[LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyHasResistance) {
            debug("[LIBERATION] Should use to strip enemy resistance buff (increases our damage)")
            return true
        }
        if (enemyShielded) {
            debug("[LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }
        if (enemyHasDamageReturn) {
            debug("[LIBERATION] Should use to strip enemy damage return")
            return true
        }

        return false
    }

    // Check if two cells are on same horizontal or vertical line
    isOnSameLine(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        return (x1 == x2 || y1 == y2)  // Horizontal OR vertical
    }

    // Find optimal cell for Neutrino vulnerability stacking (diagonal range 2-6)
    findNeutrinoStackingCell(target) {
        var bestCell = -1
        var bestScore = -1

        var reachableCells = fieldMap.getAccessibleCells(player)
        for (var i = 0; i < count(reachableCells); i++) {
            var cell = reachableCells[i]
            var dist = getCellDistance(cell, target._cellPos)

            // Must be in Neutrino range (2-6 diagonal)
            if (dist == null || dist < 2 || dist > 6) continue

            // Must be on diagonal line
            if (!this.isDiagonal(cell, target._cellPos)) continue

            // Must have line of sight
            if (!lineOfSight(cell, target._cellPos)) continue

            // Score: prefer mid-range (4 sweet spot), closer to current position
            var rangePenalty = abs(dist - 4) * 3  // Penalize distance from range 4
            var distFromCurrent = getCellDistance(player._cellPos, cell)
            if (distFromCurrent == null) continue

            var score = 100 - rangePenalty - distFromCurrent

            if (score > bestScore) {
                bestScore = score
                bestCell = cell
            }
        }

        if (bestCell != -1) {
            debug("[STR][NEUTRINO-POS] Found stacking position: cell " + bestCell + " (score=" + bestScore + ")")
        }

        return bestCell
    }

    // Find optimal cell for GRAPPLE-HEAVY_SWORD combo (range 2-8, same line, LOS)
    findGrappleHeavySwordCell(target) {
        var bestCell = -1
        var bestScore = -1

        var reachableCells = fieldMap.getAccessibleCells(player)
        for (var i = 0; i < count(reachableCells); i++) {
            var cell = reachableCells[i]
            var dist = getCellDistance(cell, target._cellPos)

            // Must be in GRAPPLE range (2-8)
            if (dist == null || dist < 2 || dist > 8) continue

            // Must be on same horizontal/vertical line (GRAPPLE is laser, not diagonal)
            if (!this.isOnSameLine(cell, target._cellPos)) continue

            // Must have line of sight
            if (!lineOfSight(cell, target._cellPos)) continue

            // Score: prefer mid-range (4-6 sweet spot), closer to current position
            var rangePenalty = abs(dist - 5) * 5  // Penalize distance from range 5
            var distFromCurrent = getCellDistance(player._cellPos, cell)
            if (distFromCurrent == null) continue

            var score = 100 - rangePenalty - distFromCurrent

            if (score > bestScore) {
                bestScore = score
                bestCell = cell
            }
        }

        if (bestCell != -1) {
            debug("[STR][GRAPPLE-HS] Found combo position: cell " + bestCell + " (score=" + bestScore + ")")
        }

        return bestCell
    }

    // Check if GRAPPLE-HEAVY_SWORD combo should be used
    shouldUseGrappleHeavySword(target) {
        // Check if HEAVY_SWORD equipped
        if (!mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD)) {
            debug("[STR][GRAPPLE-HS] HEAVY_SWORD not equipped")
            return false
        }

        var playerTP = player._currTp
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null) return false

        // Case 1: Enemy already adjacent (range 1) - just use HEAVY_SWORD
        if (dist == 1) {
            // Need 15 TP for HEAVY_SWORD, plus 1 TP for weapon swap if needed
            var requiredTP = 15
            if (getWeapon() != WEAPON_HEAVY_SWORD) {
                requiredTP = 16  // Need 1 TP for weapon swap
            }

            if (playerTP < requiredTP) {
                debug("[STR][GRAPPLE-HS] Enemy adjacent but insufficient TP: " + playerTP + " < " + requiredTP)
                return false
            }
            debug("[STR][GRAPPLE-HS] Enemy adjacent, will use HEAVY_SWORD directly")
            return true
        }

        // Case 2: Enemy in GRAPPLE range (2-8) - use combo
        if (dist >= 2 && dist <= 8) {
            if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
                debug("[STR][GRAPPLE-HS] GRAPPLE not equipped, can't pull enemy")
                return false
            }

            var cooldown = getCooldown(CHIP_GRAPPLE, getEntity())
            if (cooldown > 0) {
                debug("[STR][GRAPPLE-HS] GRAPPLE on cooldown: " + cooldown + " turns")
                return false
            }

            // Combo costs: GRAPPLE (3) + weapon swap (1 if needed) + HEAVY_SWORD (15) = 18-19 TP
            var comboTPCost = 18  // Assume weapon already equipped
            if (getWeapon() != WEAPON_HEAVY_SWORD) {
                comboTPCost = 19  // Need 1 TP for weapon swap
            }

            if (playerTP < comboTPCost) {
                debug("[STR][GRAPPLE-HS] Insufficient TP for combo: " + playerTP + " < " + comboTPCost)
                return false
            }

            // Check horizontal/vertical alignment (GRAPPLE is laser, not diagonal)
            var aligned = this.isOnSameLine(player._cellPos, target._cellPos)
            if (!aligned) {
                debug("[STR][GRAPPLE-HS] Not on same line (diagonal), can't use GRAPPLE")
                return false
            }

            if (!lineOfSight(player._cellPos, target._cellPos)) {
                debug("[STR][GRAPPLE-HS] No line of sight to enemy")
                return false
            }

            // WEEK 2: Validate path is clear (no obstacles between player and target)
            var pathToTarget = getPath(player._cellPos, target._cellPos)
            if (pathToTarget == null || count(pathToTarget) == 0) {
                debug("[STR][GRAPPLE-HS] No valid path to target (obstacles blocking)")
                return false
            }

            // Calculate where enemy will land after GRAPPLE (cell adjacent to player)
            var playerX = getCellX(player._cellPos)
            var playerY = getCellY(player._cellPos)
            var enemyX = getCellX(target._cellPos)
            var enemyY = getCellY(target._cellPos)

            var pullDestX = playerX
            var pullDestY = playerY

            if (playerY == enemyY) {
                // Horizontal alignment
                pullDestX = (enemyX > playerX) ? playerX + 1 : playerX - 1
            } else {
                // Vertical alignment
                pullDestY = (enemyY > playerY) ? playerY + 1 : playerY - 1
            }

            var pullDestCell = getCellFromXY(pullDestX, pullDestY)
            if (pullDestCell == null || isObstacle(pullDestCell)) {
                debug("[STR][GRAPPLE-HS] Pull destination blocked (cell " + pullDestCell + ")")
                return false
            }

            // Check if destination is occupied by another entity
            if (isEntity(pullDestCell) && getEntityOnCell(pullDestCell) != target._id) {
                debug("[STR][GRAPPLE-HS] Pull destination occupied by another entity")
                return false
            }

            debug("[STR][GRAPPLE-HS] Combo ready: aligned, range " + dist + ", TP=" + playerTP + ", path clear")
            return true
        }

        // Enemy out of range
        debug("[STR][GRAPPLE-HS] Enemy out of range: " + dist)
        return false
    }

    // Execute GRAPPLE-HEAVY_SWORD combo immediately (not queued to avoid validation issues)
    executeGrappleHeavySwordCombo(target) {
        var dist = getCellDistance(player._cellPos, target._cellPos)

        // Case 1: Enemy already adjacent - skip GRAPPLE, use HEAVY_SWORD only
        if (dist == 1) {
            debug("[STR][GRAPPLE-HS] Enemy already adjacent, using HEAVY_SWORD only")

            // Only swap weapon if not already equipped
            if (getWeapon() != WEAPON_HEAVY_SWORD) {
                setWeapon(WEAPON_HEAVY_SWORD)
                player._currTp -= 1
                debug("[STR][GRAPPLE-HS] Swapped to HEAVY_SWORD (1 TP)")
            }

            useWeaponOnCell(target._cellPos)
            player._currTp -= 15
            debug("[STR][GRAPPLE-HS] HEAVY_SWORD executed (60 vulnerability), TP remaining: " + player._currTp)
            return true
        }

        // Case 2: Enemy at range 2-8, use full GRAPPLE combo
        // Calculate target cell for GRAPPLE: adjacent to player on same axis toward enemy
        var playerX = getCellX(player._cellPos)
        var playerY = getCellY(player._cellPos)
        var enemyX = getCellX(target._cellPos)
        var enemyY = getCellY(target._cellPos)

        var grappleCell = -1

        if (playerY == enemyY) {
            // Horizontal alignment - enemy on same row
            if (enemyX < playerX) {
                // Enemy is to the left - target 1 cell LEFT of player (toward enemy)
                grappleCell = getCellFromXY(playerX - 1, playerY)
            } else {
                // Enemy is to the right - target 1 cell RIGHT of player (toward enemy)
                grappleCell = getCellFromXY(playerX + 1, playerY)
            }
        } else if (playerX == enemyX) {
            // Vertical alignment - enemy on same column
            if (enemyY < playerY) {
                // Enemy is above - target 1 cell ABOVE player (toward enemy)
                grappleCell = getCellFromXY(playerX, playerY - 1)
            } else {
                // Enemy is below - target 1 cell BELOW player (toward enemy)
                grappleCell = getCellFromXY(playerX, playerY + 1)
            }
        }

        if (grappleCell == -1 || grappleCell == null) {
            // Fallback: try player cell if adjacent cell invalid
            debug("[STR][GRAPPLE-HS] ERROR: Could not calculate adjacent cell on axis")
            grappleCell = player._cellPos
        }

        var alignment = (playerY == enemyY) ? "horizontal" : "vertical"
        debug("[STR][GRAPPLE-HS] Player at (" + playerX + "," + playerY + ") Enemy at (" + enemyX + "," + enemyY + ") Alignment: " + alignment)
        debug("[STR][GRAPPLE-HS] Executing GRAPPLE to pull enemy from range " + dist + " toward cell " + grappleCell)

        // Execute GRAPPLE immediately
        useChipOnCell(CHIP_GRAPPLE, grappleCell)
        player._currTp -= 3

        // Update enemy position after GRAPPLE
        target.updateEntity()

        // Execute HEAVY_SWORD immediately (enemy should now be adjacent)
        // Only swap weapon if not already equipped (saves 1 TP)
        if (getWeapon() != WEAPON_HEAVY_SWORD) {
            setWeapon(WEAPON_HEAVY_SWORD)
            player._currTp -= 1
            debug("[STR][GRAPPLE-HS] Swapped to HEAVY_SWORD (1 TP)")
        }

        useWeaponOnCell(target._cellPos)
        player._currTp -= 15

        debug("[STR][GRAPPLE-HS] Combo executed: GRAPPLE → HEAVY_SWORD (60 vulnerability), TP remaining: " + player._currTp)
        return true
    }

    // Check if NEUTRINO vulnerability stacking should be used (core DPS amplifier)
    shouldStackNeutrino(target) {
        // Check if Neutrino is equipped
        if (!mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return false
        }

        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null) return false

        // Range validation: 2-6 diagonal
        if (dist < 2 || dist > 6) {
            debug("[STR][NEUTRINO] Out of range: " + dist + " (need 2-6)")
            return false
        }

        if (!this.isDiagonal(player._cellPos, target._cellPos)) {
            debug("[STR][NEUTRINO] Not on diagonal")
            return false
        }

        if (!lineOfSight(player._cellPos, target._cellPos)) {
            debug("[STR][NEUTRINO] No line of sight")
            return false
        }

        // TP budget: 12 TP minimum (3x Neutrino @ 4 TP + enough for 1 weapon use)
        if (player._currTp < 12) {
            debug("[STR][NEUTRINO] Insufficient TP: " + player._currTp + " < 12")
            return false
        }

        // Check current vulnerability stacks (based on relShield value)
        var currentStacks = arsenal.getVulnerabilityStacks(target)

        // Check vulnerability duration (fixed getEffectRemaining now uses correct index [3])
        var vulnRemaining = target.getEffectRemaining(EFFECT_VULNERABILITY)

        // Don't stack if already at 3 stacks with good duration (2+ turns remaining)
        if (currentStacks >= 3 && vulnRemaining >= 2) {
            debug("[STR][NEUTRINO] Already at max stacks (3), remaining: " + vulnRemaining + " turns, relShield: " + target._relShield)
            return false
        }

        // Refresh if vulnerability is about to expire (at 2+ stacks, 1 turn remaining)
        if (currentStacks >= 2 && vulnRemaining <= 1 && vulnRemaining > 0) {
            debug("[STR][NEUTRINO] Refreshing expiring vulnerability (stacks=" + currentStacks + ", remaining=" + vulnRemaining + ", relShield: " + target._relShield + ")")
            return true
        }

        // Don't stack if enemy HP too low (OTKO range handles this separately)
        if (target._currHealth < 500) {
            debug("[STR][NEUTRINO] Enemy HP too low for stacking: " + target._currHealth)
            return false
        }

        // Calculate value proposition using Arsenal helper
        var avgWeaponDamage = 180  // Base estimate for STR build
        if (player.hasEffect(EFFECT_BUFF_STRENGTH)) {
            avgWeaponDamage = 240  // Higher with STEROID active (+160 STR)
        }

        // Estimate future attacks: remaining TP this turn + next 2 turns
        var futureAttacks = floor((player._currTp - 12) / 8) + 4  // Conservative estimate

        var benefit = arsenal.calculateNeutrinoAmplification(3, futureAttacks, avgWeaponDamage)

        debug("[STR][NEUTRINO] Amplification analysis: " + floor(benefit['netBenefit']) + " total value (" + floor(benefit['amplification']) + " amp + " + floor(benefit['directDamage']) + " direct)")
        debug("[STR][NEUTRINO] Multiplier: " + benefit['multiplier'] + "x, Future attacks: " + futureAttacks + ", Avg dmg: " + avgWeaponDamage)

        // Stack if net benefit > threshold
        // Lower threshold if we have lots of TP to spare (aggressive stacking)
        var threshold = 150
        if (player._currTp >= 20) threshold = 100  // More aggressive with spare TP

        if (benefit['netBenefit'] >= threshold) {
            debug("[STR][NEUTRINO] Value check PASSED: " + floor(benefit['netBenefit']) + " >= " + threshold)
            return true
        } else {
            debug("[STR][NEUTRINO] Value check FAILED: " + floor(benefit['netBenefit']) + " < " + threshold)
            return false
        }
    }

    // Execute Neutrino vulnerability stacking sequence (immediate execution, not queued)
    executeNeutrinoStacking(target) {
        debug("[STR][NEUTRINO] Executing vulnerability stacking sequence")

        // Swap to Neutrino if needed (1 TP cost)
        if (getWeapon() != WEAPON_NEUTRINO) {
            setWeapon(WEAPON_NEUTRINO)
            player._currTp -= 1
            debug("[STR][NEUTRINO] Swapped to Neutrino (1 TP)")
        }

        // Stack 3 times for maximum vulnerability (24% = 1.24x damage multiplier)
        var stacksApplied = 0
        for (var i = 0; i < 3; i++) {
            if (player._currTp >= 4) {
                useWeaponOnCell(target._cellPos)
                player._currTp -= 4
                stacksApplied += 1
            }
        }

        // Update target entity to refresh vulnerability status
        target.updateEntity()

        var totalVuln = stacksApplied * 8
        var currentRelShield = target._relShield
        debug("[STR][NEUTRINO] Applied " + stacksApplied + " stacks (" + totalVuln + "% vulnerability)")
        debug("[STR][NEUTRINO] Target relative shield now: " + currentRelShield + "%, TP remaining: " + player._currTp)

        return stacksApplied >= 2  // Success if we got at least 2 stacks (16% vulnerability)
    }

    // Override offensive scenario for Strength builds: always prioritize weapons (highest weapon damage cell)
    // Only after exhausting primary + secondary weapons do we spend leftover TP on damage chips (sorted by per-use damage desc).
    createOffensiveScenario(target, targetHitCell) {
        // Track whether GRAPPLE-HEAVY_SWORD combo was executed
        var comboExecuted = false

        // PRIORITY 0: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            // Rebuild hit map for chest position
            fieldMap.buildHitMap(chest._cellPos)
            targetHitCell = fieldMap.getBestWeaponOrChipCell()
        }

        // PRIORITY 1: OPPORTUNISTIC OTKO (check every turn based on current enemy HP)
        // This runs on EVERY turn - as enemy HP drops from attrition, OTKO becomes viable
        var canTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                         getCooldown(CHIP_TELEPORTATION, getEntity()) == 0 &&
                         player._currTp >= 15  // Minimum for teleport + attacks

        if (canTeleport) {
            // Calculate damage projection from teleport position
            var teleportInfo = fieldMap.findOptimalTeleportCell(target)
            if (teleportInfo != null) {
                var teleCell = teleportInfo['cell']
                var killProb = teleportInfo['killProbability']
                var projectedDamage = teleportInfo['damage']
                var enemyHP = target._currHealth

                debug("[STR][OTKO-ATTRITION] Enemy HP: " + enemyHP + ", Projected damage: " + floor(projectedDamage) + ", Kill prob: " + round(killProb * 100) + "%")

                // ATTRITION-BASED OTKO: Trigger when enemy HP drops to killable range (85%+ confidence)
                if (killProb >= 0.85) {
                    debug("[STR][OTKO-ATTRITION] OTKO NOW VIABLE! Enemy weakened to " + enemyHP + " HP, executing kill shot!")
                    var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
                    if (otkoExecuted) {
                        debug("[STR] OTKO scenario executed successfully (attrition-based)")
                        return  // OTKO actions planned, skip normal offensive logic
                    }
                    debug("[STR] OTKO execution failed, falling back to normal offensive scenario")
                }
                // Only show detailed message when enemy is getting close to killable range
                else if (enemyHP < 1500) {
                    debug("[STR][OTKO-ATTRITION] Enemy at " + enemyHP + " HP, need " + round((killProb * 100)) + "% → 85% kill prob (continue attrition)")
                }
            }
        }

        // PRIORITY 1.5: Reapply STEROID when it wears off (maintain +160 STR throughout fight)
        // Changed: No distance check - reapply immediately when buff expires
        if (!player.hasEffect(EFFECT_BUFF_STRENGTH)) {
            // Only apply STEROID if we didn't just execute OTKO (save TP for kill)
            var shouldApplySteroid = true

            // Check if OTKO was viable - if so, skip STEROID (TP was used for OTKO)
            if (canTeleport) {
                var teleportInfo = fieldMap.findOptimalTeleportCell(target)
                if (teleportInfo != null && teleportInfo['killProbability'] >= 0.85) {
                    shouldApplySteroid = false  // OTKO executed, no need for STEROID
                    debug("[STR][BUFF-REAPPLY] Skipping STEROID - OTKO executed (TP used for kill)")
                }
            }

            if (shouldApplySteroid) {
                var minTPForBurst = 20  // 7 (STEROID) + 13 (meaningful attacks) - prioritize attacks over early reapply
                var playerTP = player._currTp

                debug("[STR][BUFF-REAPPLY] STEROID expired, checking TP for reapplication (TP=" + playerTP + ", threshold=" + minTPForBurst + ")")

                // Use ADRENALINE if short 1-4 TP to reach burst threshold
                if (playerTP < minTPForBurst && playerTP >= 16) {
                    if (this.shouldUseAdrenaline(minTPForBurst)) {
                        debug("[STR][BUFF-REAPPLY] Using ADRENALINE to bridge TP gap (have " + playerTP + ", need " + minTPForBurst + ")")
                        useChip(CHIP_ADRENALINE, player._id)
                        player._currTp = player._currTp - 1 + 5  // Net +4 TP
                        playerTP = player._currTp
                        debug("[STR][BUFF-REAPPLY] After ADRENALINE: TP=" + playerTP)
                    }
                }

                // Apply STEROID for +160 STR burst damage (only if TP >= 20 for meaningful post-buff attacks)
                if (playerTP >= minTPForBurst && this.isChipAvailable(CHIP_STEROID, 7)) {
                    debug("[STR][BUFF-REAPPLY] Reapplying STEROID (TP=" + playerTP + ")")
                    useChip(CHIP_STEROID, player._id)
                    player._currTp -= 7
                    debug("[STR][BUFF-REAPPLY] STEROID active! +160 STR for 3 turns, TP remaining: " + player._currTp)

                    // RE-CHECK OTKO: Now that STEROID is active, check if OTKO became possible
                    if (canTeleport && player._currTp >= 15) {
                        var teleportInfoBuffed = fieldMap.findOptimalTeleportCell(target)
                        if (teleportInfoBuffed != null) {
                            var killProbBuffed = teleportInfoBuffed['killProbability']
                            var dmgBuffed = teleportInfoBuffed['damage']

                            debug("[STR][OTKO-RECHECK] With STEROID: damage=" + floor(dmgBuffed) + " vs HP=" + target._currHealth + ", kill prob=" + round(killProbBuffed * 100) + "%")

                            if (killProbBuffed >= 0.85) {
                                debug("[STR][OTKO-RECHECK] STEROID enabled OTKO! Executing...")
                                var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
                                if (otkoExecuted) {
                                    debug("[STR] OTKO with STEROID executed successfully")
                                    return  // OTKO actions planned, skip normal offensive
                                }
                            }
                        }
                    }
                } else if (playerTP < minTPForBurst) {
                    debug("[STR][BUFF-REAPPLY] Skipping STEROID - prioritizing attacks (TP=" + playerTP + ", threshold=" + minTPForBurst + ")")
                }
            }
        }

        // Calculate HP percentage once for all health-based decisions
        var hpPercent = (player._currHealth * 100) / player._maxHealth

        // PRIORITY 2: Defensive sustain - REMISSION for emergencies, shields for continuous protection
        // Philosophy: Maintain continuous shield coverage, use REMISSION only when HP significantly low
        // REMISSION: Emergency heal (100-150 HP), 5 TP (30-50% HP range - true emergency, not every turn)
        // Shields: Alternate FORTRESS (6 TP, 3 turns) and WALL (3 TP, 2 turns) for continuous coverage

        // CONTINUOUS SHIELD MAINTENANCE (every turn, regardless of HP)
        var hasShield = player.hasEffect(EFFECT_RELATIVE_SHIELD)
        var shieldRemaining = hasShield ? player.getEffectRemaining(EFFECT_RELATIVE_SHIELD) : 0

        // Apply new shield when current shield expires or missing (maintain continuous coverage)
        if (!hasShield || shieldRemaining <= 1) {
            // Prefer FORTRESS (stronger, 3 turns, 6 TP) if available
            if (this.isChipAvailable(CHIP_FORTRESS, 9) && player._currTp >= 9) {  // 6 for FORTRESS + 3 reserve
                debug("[STR][SHIELD] Applying FORTRESS (7-8% reduction, 3 turns, TP=" + player._currTp + ")")
                useChip(CHIP_FORTRESS, player._id)
                player._currTp -= 6
            }
            // Fallback to WALL (cheaper, 2 turns, 3 TP) if FORTRESS unavailable
            else if (this.isChipAvailable(CHIP_WALL, 6) && player._currTp >= 6) {  // 3 for WALL + 3 reserve
                debug("[STR][SHIELD] Applying WALL (4-5% reduction, 2 turns, TP=" + player._currTp + ")")
                useChip(CHIP_WALL, player._id)
                player._currTp -= 3
            }
        } else {
            debug("[STR][SHIELD] Shield active with " + shieldRemaining + " turns remaining")
        }

        // REMISSION HEALING (only when HP in emergency range 30-50%)
        var inSustainRange = hpPercent >= 30 && hpPercent <= 50
        var hasSustainTP = player._currTp >= 10  // Minimum TP to afford sustain + attacks

        if (inSustainRange && hasSustainTP) {
            debug("[STR][SUSTAIN] HP at " + round(hpPercent) + "%, applying REMISSION healing (TP=" + player._currTp + ")")

            // Apply REMISSION for sustained healing (~120 HP, 5 TP)
            if (this.isChipAvailable(CHIP_REMISSION, 5)) {
                debug("[STR][SUSTAIN] Using REMISSION (TP=" + player._currTp + ")")
                useChip(CHIP_REMISSION, player._id)
                player._currTp -= 5
            }
        }

        // PRIORITY 2.5: NEUTRINO VULNERABILITY STACKING (CORE DPS MULTIPLIER)
        // This is the foundation of our damage output - all weapons benefit from 24% vulnerability
        // Stack before GRAPPLE-HEAVY_SWORD to amplify combo damage
        var neutrinoExecuted = false

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            var neutrinoDist = getCellDistance(player._cellPos, target._cellPos)
            var neutrinoAligned = this.isDiagonal(player._cellPos, target._cellPos)

            // Case 1: Already in Neutrino range (diagonal 2-6) - stack immediately
            if (neutrinoDist != null && neutrinoDist >= 2 && neutrinoDist <= 6 &&
                neutrinoAligned && lineOfSight(player._cellPos, target._cellPos)) {

                if (this.shouldStackNeutrino(target)) {
                    debug("[STR][NEUTRINO] In range, executing stacking from current position")
                    if (this.executeNeutrinoStacking(target)) {
                        neutrinoExecuted = true
                        debug("[STR][NEUTRINO] Stacking complete, continuing with amplified weapons")
                    }
                }
            }
            // Case 2: Not in range - move to Neutrino position if high value
            // More aggressive repositioning: MP >= 2, TP >= 12 (lowered from 3/15)
            else if (player._currMp >= 2 && player._currTp >= 12) {
                var neutrinoCell = this.findNeutrinoStackingCell(target)
                if (neutrinoCell != -1) {
                    var pathToNeutrinoCell = getPath(player._cellPos, neutrinoCell)
                    if (pathToNeutrinoCell != null && count(pathToNeutrinoCell) <= player._currMp) {
                        debug("[STR][NEUTRINO] Moving to stacking position (cell " + neutrinoCell + ", " + count(pathToNeutrinoCell) + " MP)")
                        var moveResult = moveTowardCell(neutrinoCell)
                        player._currMp -= count(pathToNeutrinoCell)
                        player._cellPos = getCell()

                        // Stack after repositioning
                        if (this.shouldStackNeutrino(target)) {
                            if (this.executeNeutrinoStacking(target)) {
                                neutrinoExecuted = true
                                debug("[STR][NEUTRINO] Repositioned and stacked vulnerability")
                            }
                        }
                    }
                } else {
                    debug("[STR][NEUTRINO] Not in range (dist=" + neutrinoDist + " diagonal=" + neutrinoAligned + "), no good repositioning cell found")
                }
            } else {
                debug("[STR][NEUTRINO] Not in range (dist=" + neutrinoDist + " diagonal=" + neutrinoAligned + "), insufficient resources to reposition")
            }
        }

        // PRIORITY 3: GRAPPLE-HEAVY_SWORD combo check (after OTKO, before defensive chips consume TP)
        // Position for combo if needed, then execute
        var comboAttempted = false  // Track if combo was attempted (prevents INVERSION waste)

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD) &&
            mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE) &&
            getCooldown(CHIP_GRAPPLE, getEntity()) == 0 &&
            player._currTp >= 18) {

            // Check if already in combo position (dist 1-8, aligned on same line)
            var currentDist = getCellDistance(player._cellPos, target._cellPos)
            var currentlyAligned = this.isOnSameLine(player._cellPos, target._cellPos)

            // Only execute combo if already in valid position (no repositioning - combo uses immediate execution)
            if (currentDist != null && currentDist >= 1 && currentDist <= 8 && currentlyAligned) {
                debug("[STR][GRAPPLE-HS] In combo position (dist=" + currentDist + " aligned=true), will execute combo")
                comboAttempted = true  // Set flag: combo will be attempted
            } else {
                debug("[STR][GRAPPLE-HS] Not in combo position (dist=" + currentDist + " aligned=" + currentlyAligned + "), skipping combo")
            }

            // Execute combo immediately (not queued to avoid validation issues with position changes)
            if (this.shouldUseGrappleHeavySword(target)) {
                if (this.executeGrappleHeavySwordCombo(target)) {
                    debug("[STR] GRAPPLE-HEAVY_SWORD combo executed successfully")
                    comboExecuted = true  // FLAG: Skip weapon cell recalculation

                    // Update target position after GRAPPLE pull
                    target.updateEntity()

                    // Continue with remaining TP for weapon spam
                } else {
                    debug("[STR] GRAPPLE-HEAVY_SWORD combo execution failed")
                }
            }
        }

        // PRIORITY 3: CHIP_ANTIDOTE - Remove poison (ongoing damage removal > one-time heal)
        if (this.shouldUseAntidote()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ANTIDOTE)
            // Target self
            this._actions[count(this._actions) - 1].targetCell = player._cellPos
            player._currTp -= 3
            debug("[STR] Applied CHIP_ANTIDOTE (remove poison + 25-35 HP heal)")
        }

        // PRIORITY 4: CHIP_THERAPY - Emergency healing (only if HP critically low < 25%)
        // Note: hpPercent already calculated above for sustain combo
        if (hpPercent < 25 && this.shouldUseTherapy()) {
            var therapyTarget = this.findTherapyTarget()
            if (therapyTarget != null) {
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_THERAPY)
                // Update action with correct target cell
                this._actions[count(this._actions) - 1].targetCell = therapyTarget
                player._currTp -= 7
                debug("[STR] Applied CHIP_THERAPY (75-80 HP heal)")
            }
        }

        // PRIORITY 5: CHIP_INVERSION - Offensive hybrid (heal + 20% vulnerability, ONLY if can attack after)
        // Skip if combo attempted (MP already committed to positioning, swap would strand us)
        if (!comboAttempted && this.shouldUseInversion(target)) {
            // Save positions before swap
            var playerOldPos = player._cellPos
            var targetOldPos = target._cellPos

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_INVERSION)
            // Target cell is enemy position (will swap)
            this._actions[count(this._actions) - 1].targetCell = target._cellPos
            player._currTp -= 4

            // Update virtual positions after INVERSION (positions will swap)
            player._cellPos = targetOldPos  // Player moves to enemy's position
            target._cellPos = playerOldPos  // Enemy moves to player's position

            debug("[STR] Applied CHIP_INVERSION (50 HP heal + 20% vulnerability on enemy)")
            debug("[STR][INVERSION] Position swap: player " + playerOldPos + " → " + player._cellPos + ", enemy " + targetOldPos + " → " + target._cellPos)
        }

        // NOTE: FORTRESS and WALL defensive buffs removed from here (now applied on Turn 1 when enemy far)

        // PRIORITY 6: Check for tactical CHIP_LIBERATION usage BEFORE combat
        if (this.shouldUseLiberation(target)) {
            // Use on enemy to remove their buffs, or on self to remove debuffs
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[STR] Using Liberation on self to remove debuffs")
            } else {
                debug("[STR] Using Liberation on enemy to remove buffs/shields")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            // Update action with correct target cell
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            player._currTp -= 5
        }

        // OTKO check already done at beginning of function (PRIORITY 2)
        // If we reach here, OTKO was not viable - proceed with normal offensive

        // If GRAPPLE-HEAVY_SWORD combo executed, skip weapon cell recalculation
        // Enemy is now adjacent with vulnerability applied - stay in position
        if (comboExecuted) {
            debug("[STR] Combo executed, using remaining TP from current position")

            // Use remaining TP for any attacks from current position
            var playerTP = player._currTp
            var playerMP = player._currMp

            // Try to use remaining LIGHTNINGER charges if in range
            if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_ENHANCED_LIGHTNINGER)) {
                var lightninger = arsenal.playerEquippedWeapons[WEAPON_ENHANCED_LIGHTNINGER]
                var dist = getCellDistance(player._cellPos, target._cellPos)

                // LIGHTNINGER range: 6-10 (enemy is adjacent after combo, likely out of range)
                if (dist != null && dist >= 6 && dist <= 10 && playerTP >= 9) {
                    debug("[STR][COMBO] Enemy at range " + dist + ", can use LIGHTNINGER")

                    // Set weapon if needed
                    if (getWeapon() != WEAPON_ENHANCED_LIGHTNINGER) {
                        this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, WEAPON_ENHANCED_LIGHTNINGER, -1)
                        playerTP -= 1
                    }

                    // Spam LIGHTNINGER with remaining TP
                    var uses = min(lightninger._maxUse, floor(playerTP / 9))
                    while (uses > 0 && playerTP >= 9) {
                        this.createAttackAction(Action.ACTION_DIRECT, target, WEAPON_ENHANCED_LIGHTNINGER, -1)
                        playerTP -= 9
                        uses -= 1
                    }

                    player._currTp = playerTP
                } else {
                    debug("[STR][COMBO] Enemy at range " + dist + ", out of LIGHTNINGER range (6-10)")
                }
            }

            // Add hide-and-seek repositioning with remaining MP
            var hnsCell = fieldMap.findHideAndSeekCell("defensive", target)
            if (hnsCell != -1 && hnsCell != null) {
                var hideCellId = hnsCell['cell']
                debug("[STR][COMBO] Moving to hide-and-seek cell: " + hideCellId + " (danger=" + hnsCell['danger'] + ")")
                this.createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
            }

            debug("[STR] Combo offensive complete. Remaining TP: " + player._currTp + ", MP: " + player._currMp)
            return  // Skip normal weapon cell calculation
        }

        // Re-compute best pure weapon cell ignoring chip-only high damage cells.
        var bestWeaponCell = -1
        var bestWeaponDamage = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in fieldMap.damageMap) {
            if (c._highestDamageWeapon == -1) continue
            var dist = getCachedPathLength(playerPos, c._id)
            if (dist == null) continue
            // Prefer higher weaponDamage, tie-break shorter distance
            if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                bestWeaponDamage = c._weaponDamage
                bestWeaponCell = c
                bestDist = dist
            }
        }
        // Fallback to incoming targetHitCell if no weapon cell found (should be rare)
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) bestWeaponCell = targetHitCell
        if (bestWeaponCell == -1) {
            debug("[STR] No weapon cell found; falling back to base logic")
            return super.createOffensiveScenario(target, targetHitCell)
        }

        // Execute shared weapon-focused combat logic (no chip exclusions for strength)
        var playerMP = player._currMp
        var playerTP = player._currTp
        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [], "STR", false)

        debug("[STR] Offensive scenario complete. Remaining TP: " + result['playerTP'] + ", MP: " + result['playerMP'])
    }

}
