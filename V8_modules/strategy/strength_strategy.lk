include('action.lk')
include('base_strategy.lk')

class StrengthStrategy extends Strategy {
    constructor() {
        super()
    }

    createOTKOScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST-OTKO] Chest detected! Switching OTKO target from enemy to chest (ID: " + chest._id + ")")
            target = chest
        }

        // Check if CHIP_TELEPORTATION is equipped
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            debug("[OTKO] Teleportation not equipped")
            return false
        }

        // Check cooldown (0 = available)
        var cooldown = getCooldown(CHIP_TELEPORTATION, getEntity())
        if (cooldown > 0) {
            debug("[OTKO] Teleportation on cooldown: " + cooldown + " turns")
            return false
        }

        // Check minimum TP budget (9 for teleport + weapon costs)
        var playerTP = player._currTp
        if (playerTP < 15) {  // 9 + minimum 6 TP for one weapon use
            debug("[OTKO] Insufficient TP for teleport OTKO: " + playerTP)
            return false
        }

        // Find optimal teleport cell
        var teleportInfo = fieldMap.findOptimalTeleportCell(target)
        if (teleportInfo == null) {
            debug("[OTKO] No valid teleport cells found")
            return false
        }

        // Only proceed if we can guarantee the kill (or if target is chest - always prioritize chests)
        if (!teleportInfo['canKill'] && !(target instanceof Chest)) {
            debug("[OTKO] Projected damage insufficient for kill: " + teleportInfo['damage'] + " vs " + target._currHealth + " HP")

            // Check if CHIP_ADRENALINE can bridge the gap
            if (this.shouldUseAdrenaline(15)) {  // Need at least 15 TP for meaningful OTKO
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
                playerTP -= 1
                playerTP += 5  // Net gain of 4 TP
                debug("[OTKO][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")
                // Re-check if we can now kill
                if (teleportInfo['damage'] < target._currHealth) {
                    return false
                }
            } else {
                return false
            }
        }

        var teleCell = teleportInfo['cell']
        debug("[OTKO] Executing teleport OTKO to cell " + teleCell + " projected damage: " + teleportInfo['damage'])

        // Execute teleportation
        this.createAttackAction(Action.ACTION_DIRECT, target, -1, CHIP_TELEPORTATION)
        playerTP -= 9

        // Update simulated player position
        var playerPos = teleCell

        // Execute weapon attacks from teleport position
        // Build list of usable weapons sorted by shield-adjusted damage
        var weaponDmgList = []
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            // Check if weapon can hit target from teleport cell
            var distToTarget = getCellDistance(teleCell, target._cellPos)
            if (distToTarget == null) continue
            if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
            if (!lineOfSight(teleCell, target._cellPos)) continue

            var netDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)
            push(weaponDmgList, ['weapon': wObj, 'netDmg': netDmg])
        }

        // Sort by descending net damage (selection sort)
        for (var i = 0; i < count(weaponDmgList); i++) {
            var bestIdx = i
            for (var j = i + 1; j < count(weaponDmgList); j++) {
                if (weaponDmgList[j]['netDmg'] > weaponDmgList[bestIdx]['netDmg']) bestIdx = j
            }
            if (bestIdx != i) {
                var tmp = weaponDmgList[i]
                weaponDmgList[i] = weaponDmgList[bestIdx]
                weaponDmgList[bestIdx] = tmp
            }
        }

        // Execute weapons in order of net damage
        for (var wi = 0; wi < count(weaponDmgList); wi++) {
            var wRec = weaponDmgList[wi]
            var wObj = wRec['weapon']

            // Swap weapon if needed
            if (getWeapon() != wObj._id) {
                if (playerTP >= 1 + wObj._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                } else {
                    continue  // Not enough TP to swap and use
                }
            }

            // Use weapon maximum times
            var uses = min(wObj._maxUse, floor(playerTP / wObj._cost))
            while (uses > 0 && playerTP >= wObj._cost) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses -= 1
            }

            if (playerTP <= 0) break
        }

        // Use damage chips with remaining TP
        if (playerTP > 0) {
            var chipDmgList = []
            for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                if (cid == CHIP_TELEPORTATION) continue

                // Filter attack chips
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                // Check range and LOS from teleport cell
                var distChip = getCellDistance(teleCell, target._cellPos)
                if (distChip == null) continue
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(teleCell, target._cellPos)) continue

                var netChipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                push(chipDmgList, ['chip': chipObj, 'netDmg': netChipDmg])
            }

            // Sort chips by net damage
            for (var ci = 0; ci < count(chipDmgList); ci++) {
                var bestCIdx = ci
                for (var cj = ci + 1; cj < count(chipDmgList); cj++) {
                    if (chipDmgList[cj]['netDmg'] > chipDmgList[bestCIdx]['netDmg']) bestCIdx = cj
                }
                if (bestCIdx != ci) {
                    var tmpC = chipDmgList[ci]
                    chipDmgList[ci] = chipDmgList[bestCIdx]
                    chipDmgList[bestCIdx] = tmpC
                }
            }

            // Execute chips
            for (var chipIdx = 0; chipIdx < count(chipDmgList); chipIdx++) {
                var cRec = chipDmgList[chipIdx]
                var chipUse = cRec['chip']
                if (playerTP < chipUse._cost) continue
                // Spam chip until max uses OR TP exhausted
                var actualUsesC = 0
                while (actualUsesC < chipUse._maxUse && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    actualUsesC += 1
                }
                if (playerTP <= 0) break
            }
        }

        debug("[OTKO] OTKO scenario complete, remaining TP: " + playerTP)
        return true
    }

    // Check if CHIP_STEROID should be used (strength buff)
    shouldUseSteroid() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) return false

        var cooldown = getCooldown(CHIP_STEROID, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        // Need 7 TP for buff + at least 8 TP for meaningful attacks (15 TP minimum)
        if (playerTP < 15) return false

        // Check if we already have strength buff active
        var hasStrBuff = player.hasEffect(EFFECT_BUFF_STRENGTH)
        if (hasStrBuff) {
            var buffRemaining = player.getEffectRemaining(EFFECT_BUFF_STRENGTH)
            if (buffRemaining > 1) {
                debug("[STEROID] Strength buff active with " + buffRemaining + " turns remaining")
                return false
            }
            debug("[STEROID] Strength buff expiring in " + buffRemaining + " turn(s) - reapplying")
            return true
        }

        debug("[STEROID] No strength buff active - applying")
        return true
    }

    // Check if CHIP_ADRENALINE should be used tactically
    shouldUseAdrenaline(requiredTP) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_ADRENALINE)) return false

        var cooldown = getCooldown(CHIP_ADRENALINE, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        // Only use if we're short of required TP by 1-4 points (Adrenaline gives +4 net TP)
        var shortage = requiredTP - playerTP
        if (shortage >= 1 && shortage <= 4) {
            debug("[ADRENALINE] Short " + shortage + " TP (have " + playerTP + " need " + requiredTP + ") - using Adrenaline")
            return true
        }

        return false
    }

    // Check if CHIP_LEATHER_BOOTS should be used for positioning
    shouldUseLeatherBoots(targetCell) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS)) return false

        var cooldown = getCooldown(CHIP_LEATHER_BOOTS, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        // Need 3 TP for boots + at least 7 TP for attacks (10 TP minimum)
        if (playerTP < 10) return false

        // Check if we already have MP buff active
        var hasMPBuff = player.hasEffect(EFFECT_BUFF_MP)
        if (hasMPBuff) {
            debug("[LEATHER_BOOTS] MP buff already active")
            return false
        }

        // Only use if target cell is unreachable but within MP+2 range
        var pathLen = getPathLength(player._cellPos, targetCell)
        if (pathLen == null) return false

        var playerMP = player._currMp
        if (pathLen > playerMP && pathLen <= playerMP + 2) {
            debug("[LEATHER_BOOTS] Target cell unreachable (need " + pathLen + " MP, have " + playerMP + ") - using boots")
            return true
        }

        return false
    }

    // Check if CHIP_LIBERATION is tactically valuable
    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        // Check range to target
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        // Priority 1: Remove critical player debuffs (shackles reducing our combat effectiveness)
        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        // Priority 2: Remove player poison if significant
        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        // Priority 3: Remove enemy buffs/shields
        var enemyShielded = target._relShield > 15 || target._absShield > 30

        // Use if we have critical debuffs OR poison with 3+ turns OR enemy heavily shielded
        if (hasDebuff) {
            debug("[LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyShielded) {
            debug("[LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }

        return false
    }

    // Override offensive scenario for Strength builds: always prioritize weapons (highest weapon damage cell)
    // Only after exhausting primary + secondary weapons do we spend leftover TP on damage chips (sorted by per-use damage desc).
    createOffensiveScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            // Rebuild hit map for chest position
            targetHitCell = fieldMap.buildHitMap(chest._cellPos)
        }

        // PRIORITY 2: Apply CHIP_STEROID before combat if needed
        if (this.shouldUseSteroid()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_STEROID)
            player._currTp -= 7
            debug("[STR] Applied CHIP_STEROID (+150-170 Strength for 3 turns)")
        }

        // PRIORITY 3: Check for CHIP_LEATHER_BOOTS if target cell unreachable
        if (targetHitCell != -1 && targetHitCell != null && this.shouldUseLeatherBoots(targetHitCell._id)) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_LEATHER_BOOTS)
            player._currTp -= 3
            player._currMp += 2  // Immediate MP boost
            debug("[STR] Applied CHIP_LEATHER_BOOTS (+2 MP for 2 turns)")
        }

        // PRIORITY 4: Check for tactical CHIP_LIBERATION usage BEFORE combat
        if (this.shouldUseLiberation(target)) {
            // Use on enemy to remove their buffs, or on self to remove debuffs
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[STR] Using Liberation on self to remove debuffs")
            } else {
                debug("[STR] Using Liberation on enemy to remove buffs/shields")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            // Update action with correct target cell
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            player._currTp -= 5
        }

        // Check for OTKO opportunity first (low HP enemies)
        var hpThreshold = min(target._maxHealth * 0.35, 500)  // 35% HP or 500 HP, whichever is lower
        if (target._currHealth <= hpThreshold) {
            debug("[STR] Enemy HP below OTKO threshold: " + target._currHealth + " <= " + hpThreshold)
            var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
            if (otkoExecuted) {
                debug("[STR] OTKO scenario executed successfully")
                return  // OTKO actions planned, skip normal offensive logic
            }
            debug("[STR] OTKO not viable, falling back to normal offensive scenario")
        }

        // Re-compute best pure weapon cell ignoring chip-only high damage cells.
        var bestWeaponCell = -1
        var bestWeaponDamage = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in fieldMap.damageMap) {
            if (c._highestDamageWeapon == -1) continue
            var dist = getPathLength(playerPos, c._id)
            if (dist == null) continue
            // Prefer higher weaponDamage, tie-break shorter distance
            if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                bestWeaponDamage = c._weaponDamage
                bestWeaponCell = c
                bestDist = dist
            }
        }
        // Fallback to incoming targetHitCell if no weapon cell found (should be rare)
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) bestWeaponCell = targetHitCell
        if (bestWeaponCell == -1) {
            debug("[STR] No weapon cell found; falling back to base logic")
            return super.createOffensiveScenario(target, targetHitCell)
        }

        // Execute shared weapon-focused combat logic (no chip exclusions for strength)
        var playerMP = player._currMp
        var playerTP = player._currTp
        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [], "STR")

        debug("[STR] Offensive scenario complete. Remaining TP: " + result['playerTP'] + ", MP: " + result['playerMP'])
    }

}
