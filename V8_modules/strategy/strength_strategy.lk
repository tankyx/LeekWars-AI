include('action.lk')
include('base_strategy.lk')

class StrengthStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "STR"
    }

    createOTKOScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST-OTKO] Chest detected! Switching OTKO target from enemy to chest (ID: " + chest._id + ")")
            target = chest
        }

        // Check if CHIP_TELEPORTATION is equipped
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            debug("[OTKO] Teleportation not equipped")
            return false
        }

        // Check cooldown (0 = available)
        var cooldown = getCooldown(CHIP_TELEPORTATION, getEntity())
        if (cooldown > 0) {
            debug("[OTKO] Teleportation on cooldown: " + cooldown + " turns")
            return false
        }

        // Check minimum TP budget (9 for teleport + weapon costs)
        var playerTP = player._currTp
        if (playerTP < 15) {  // 9 + minimum 6 TP for one weapon use
            debug("[OTKO] Insufficient TP for teleport OTKO: " + playerTP)
            return false
        }

        // Find optimal teleport cell
        var teleportInfo = fieldMap.findOptimalTeleportCell(target)
        if (teleportInfo == null) {
            debug("[OTKO] No valid teleport cells found")
            return false
        }

        // Only proceed if we can guarantee the kill (or if target is chest - always prioritize chests)
        if (!teleportInfo['canKill'] && !(target instanceof Chest)) {
            debug("[OTKO] Projected damage insufficient for kill: " + teleportInfo['damage'] + " vs " + target._currHealth + " HP")

            // Check if CHIP_ADRENALINE can bridge the gap
            if (this.shouldUseAdrenaline(15)) {  // Need at least 15 TP for meaningful OTKO
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
                playerTP -= 1
                playerTP += 5  // Net gain of 4 TP
                debug("[OTKO][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")
                // Re-check if we can now kill
                if (teleportInfo['damage'] < target._currHealth) {
                    return false
                }
            } else {
                return false
            }
        }

        var teleCell = teleportInfo['cell']
        debug("[OTKO] Executing teleport OTKO to cell " + teleCell + " projected damage: " + teleportInfo['damage'])

        // Execute teleportation
        this.createAttackAction(Action.ACTION_TELEPORT, target, -1, CHIP_TELEPORTATION)
        // Override targetCell to teleport destination (not target's position)
        this._actions[count(this._actions) - 1].targetCell = teleCell
        playerTP -= 9

        // Update simulated player position
        var playerPos = teleCell

        // Execute weapon attacks from teleport position
        // Build list of usable weapons sorted by shield-adjusted damage
        var weaponDmgList = []
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            // Check if weapon can hit target from teleport cell
            var distToTarget = getCellDistance(teleCell, target._cellPos)
            if (distToTarget == null) continue
            if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
            if (!lineOfSight(teleCell, target._cellPos)) continue

            var netDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)
            push(weaponDmgList, ['weapon': wObj, 'netDmg': netDmg])
        }

        // Sort by descending net damage (selection sort)
        for (var i = 0; i < count(weaponDmgList); i++) {
            var bestIdx = i
            for (var j = i + 1; j < count(weaponDmgList); j++) {
                if (weaponDmgList[j]['netDmg'] > weaponDmgList[bestIdx]['netDmg']) bestIdx = j
            }
            if (bestIdx != i) {
                var tmp = weaponDmgList[i]
                weaponDmgList[i] = weaponDmgList[bestIdx]
                weaponDmgList[bestIdx] = tmp
            }
        }

        // Execute weapons in order of net damage
        for (var wi = 0; wi < count(weaponDmgList); wi++) {
            var wRec = weaponDmgList[wi]
            var wObj = wRec['weapon']

            // Swap weapon if needed
            if (getWeapon() != wObj._id) {
                if (playerTP >= 1 + wObj._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                } else {
                    continue  // Not enough TP to swap and use
                }
            }

            // Use weapon maximum times
            var uses = min(wObj._maxUse, floor(playerTP / wObj._cost))
            while (uses > 0 && playerTP >= wObj._cost) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses -= 1
            }

            if (playerTP <= 0) break
        }

        // Use damage chips with remaining TP
        if (playerTP > 0) {
            var chipDmgList = []
            for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                if (cid == CHIP_TELEPORTATION) continue

                // Filter attack chips
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                // Check range and LOS from teleport cell
                var distChip = getCellDistance(teleCell, target._cellPos)
                if (distChip == null) continue
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(teleCell, target._cellPos)) continue

                var netChipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                push(chipDmgList, ['chip': chipObj, 'netDmg': netChipDmg])
            }

            // Sort chips by net damage
            for (var ci = 0; ci < count(chipDmgList); ci++) {
                var bestCIdx = ci
                for (var cj = ci + 1; cj < count(chipDmgList); cj++) {
                    if (chipDmgList[cj]['netDmg'] > chipDmgList[bestCIdx]['netDmg']) bestCIdx = cj
                }
                if (bestCIdx != ci) {
                    var tmpC = chipDmgList[ci]
                    chipDmgList[ci] = chipDmgList[bestCIdx]
                    chipDmgList[bestCIdx] = tmpC
                }
            }

            // Execute chips
            for (var chipIdx = 0; chipIdx < count(chipDmgList); chipIdx++) {
                var cRec = chipDmgList[chipIdx]
                var chipUse = cRec['chip']
                if (playerTP < chipUse._cost) continue
                // Spam chip until max uses OR TP exhausted
                var actualUsesC = 0
                while (actualUsesC < chipUse._maxUse && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    actualUsesC += 1
                }
                if (playerTP <= 0) break
            }
        }

        debug("[OTKO] OTKO scenario complete, remaining TP: " + playerTP)
        return true
    }

    // Check if CHIP_STEROID should be used (strength buff)
    shouldUseSteroid() {
        // CHIP_STEROID: 7 TP cost, need 15 TP minimum (7 + 8 for attacks)
        if (!this.shouldApplyStatBuff(CHIP_STEROID, EFFECT_BUFF_STRENGTH, 15)) return false

        // Validate TP budget (7 TP for STEROID + minimum for attacks)
        if (!this.validateTPBudget(7)) return false

        return true
    }

    // Check if player is in combat range (any enemy within distance 8)
    isInCombatRange() {
        var enemies = fieldMap.getEnemySubMap()
        for (var e in enemies) {
            if (isDead(e._id)) continue
            var dist = getCellDistance(player._cellPos, e._cellPos)
            if (dist != null && dist <= 8) {
                debug("[STR][COMBAT-RANGE] Enemy ID=" + e._id + " at distance " + dist + " (in combat range)")
                return true
            }
        }
        debug("[STR][COMBAT-RANGE] No enemies within distance 8 (not in combat)")
        return false
    }

    // Check if CHIP_ANTIDOTE should be used (poison removal + heal)
    shouldUseAntidote() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_ANTIDOTE)) return false

        var cooldown = getCooldown(CHIP_ANTIDOTE, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 9) return false  // 3 TP for ANTIDOTE + 6 minimum for attacks

        // Check if poisoned
        if (!player.hasEffect(EFFECT_POISON)) return false

        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)
        if (poisonRemaining < 2) return false  // Not worth it for 1 turn of poison

        debug("[STR][ANTIDOTE] Poisoned with " + poisonRemaining + " turns remaining, should use ANTIDOTE")
        return true
    }

    // Check if CHIP_THERAPY should be used (emergency healing)
    shouldUseTherapy() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_THERAPY)) return false

        var cooldown = getCooldown(CHIP_THERAPY, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 13) return false  // 7 TP for THERAPY + 6 minimum for attacks

        // Use when HP below 40% (emergency healing)
        var hpPercent = (player._currHealth * 100) / player._maxHealth
        if (hpPercent >= 40) return false

        var hpMissing = player._maxHealth - player._currHealth
        if (hpMissing < 50) return false  // Don't waste if only missing small amount of HP

        debug("[STR][THERAPY] HP at " + hpPercent + "% (" + player._currHealth + "/" + player._maxHealth + "), should use THERAPY")
        return true
    }

    // Find best cell to target with CHIP_THERAPY to heal self
    // CHIP_THERAPY: Range 1-5, Area plus 2 (+ pattern with radius 2)
    findTherapyTarget() {
        var playerPos = player._cellPos

        // Try to target an adjacent cell (range 1) to maximize chance of hitting self in AoE
        var adjacentCells = [
            getCellFromXY(getCellX(playerPos) + 1, getCellY(playerPos)),
            getCellFromXY(getCellX(playerPos) - 1, getCellY(playerPos)),
            getCellFromXY(getCellX(playerPos), getCellY(playerPos) + 1),
            getCellFromXY(getCellX(playerPos), getCellY(playerPos) - 1)
        ]

        for (var targetCell in adjacentCells) {
            if (targetCell == null) continue

            // Check if this cell is valid and in range
            var dist = getCellDistance(playerPos, targetCell)
            if (dist == null || dist < 1 || dist > 5) continue

            // Check if player would be in the AoE (+ pattern radius 2)
            var affectedCells = getAoEAffectedCells(CHIP_THERAPY, targetCell)
            var playerInAoE = false
            for (var i = 0; i < count(affectedCells); i++) {
                if (affectedCells[i] == playerPos) {
                    playerInAoE = true
                    break
                }
            }

            if (playerInAoE) {
                debug("[STR][THERAPY] Found valid therapy target cell: " + targetCell)
                return targetCell
            }
        }

        debug("[STR][THERAPY] No valid therapy target cell found")
        return null
    }

    // Check if CHIP_INVERSION should be used (hybrid: heal + damage setup)
    shouldUseInversion(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_INVERSION)) return false

        var cooldown = getCooldown(CHIP_INVERSION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 10) return false  // 4 TP for INVERSION + 6 minimum for attacks

        // Use when HP below 60% (medium-low health)
        var hpPercent = (player._currHealth * 100) / player._maxHealth
        if (hpPercent >= 60) return false

        // Check if enemy in line (horizontal or vertical) within range 1-14
        var playerPos = player._cellPos
        var targetPos = target._cellPos
        var dist = getCellDistance(playerPos, targetPos)
        if (dist == null || dist < 1 || dist > 14) return false

        // Check horizontal or vertical alignment
        var playerX = getCellX(playerPos)
        var playerY = getCellY(playerPos)
        var targetX = getCellX(targetPos)
        var targetY = getCellY(targetPos)

        var isAligned = (playerX == targetX) || (playerY == targetY)
        if (!isAligned) return false

        // Check line of sight
        if (!lineOfSight(playerPos, targetPos)) return false

        debug("[STR][INVERSION] HP at " + hpPercent + "%, enemy in line at distance " + dist + ", should use INVERSION")
        return true
    }

    // Check if CHIP_FORTRESS should be used (defensive buff)
    shouldUseFortress() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_FORTRESS)) return false

        var cooldown = getCooldown(CHIP_FORTRESS, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 12) return false  // 6 TP for FORTRESS + 6 minimum for attacks

        // Don't use if poisoned (shields don't reduce poison damage)
        if (player.hasEffect(EFFECT_POISON)) {
            debug("[STR][FORTRESS] Skipping FORTRESS - player is poisoned (shields don't help)")
            return false
        }

        // Check if effect already active
        if (player.hasEffect(EFFECT_RELATIVE_SHIELD)) {
            var remaining = player.getEffectRemaining(EFFECT_RELATIVE_SHIELD)
            if (remaining > 1) return false  // Already have defensive buff active
        }

        // Use when in combat range (enemy within distance 8)
        if (!this.isInCombatRange()) {
            debug("[STR][FORTRESS] Not in combat range, skipping FORTRESS")
            return false
        }

        debug("[STR][FORTRESS] In combat range, should use FORTRESS")
        return true
    }

    // Check if CHIP_WALL should be used (weaker defensive buff)
    shouldUseWall() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_WALL)) return false

        var cooldown = getCooldown(CHIP_WALL, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 9) return false  // 3 TP for WALL + 6 minimum for attacks

        // Don't use if poisoned (shields don't reduce poison damage)
        if (player.hasEffect(EFFECT_POISON)) {
            debug("[STR][WALL] Skipping WALL - player is poisoned (shields don't help)")
            return false
        }

        // Check if effect already active
        if (player.hasEffect(EFFECT_RELATIVE_SHIELD)) {
            var remaining = player.getEffectRemaining(EFFECT_RELATIVE_SHIELD)
            if (remaining > 1) return false  // Already have defensive buff active
        }

        // Use when in combat range (enemy within distance 8)
        if (!this.isInCombatRange()) {
            debug("[STR][WALL] Not in combat range, skipping WALL")
            return false
        }

        debug("[STR][WALL] In combat range, should use WALL")
        return true
    }

    // Check if CHIP_LIBERATION is tactically valuable
    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        // Check range to target
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        // Priority 1: Remove critical player debuffs (shackles reducing our combat effectiveness)
        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        // Priority 2: Remove player poison if significant
        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        // Priority 3: Remove enemy buffs/shields/damage return
        var enemyShielded = target._relShield > 15 || target._absShield > 30
        var enemyHasDamageReturn = target.hasEffect(EFFECT_DAMAGE_RETURN)

        // Use if we have critical debuffs OR poison with 3+ turns OR enemy heavily buffed
        if (hasDebuff) {
            debug("[LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyShielded) {
            debug("[LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }
        if (enemyHasDamageReturn) {
            debug("[LIBERATION] Should use to strip enemy damage return")
            return true
        }

        return false
    }

    // Override offensive scenario for Strength builds: always prioritize weapons (highest weapon damage cell)
    // Only after exhausting primary + secondary weapons do we spend leftover TP on damage chips (sorted by per-use damage desc).
    createOffensiveScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            // Rebuild hit map for chest position
            targetHitCell = fieldMap.buildHitMap(chest._cellPos)
        }

        // PRIORITY 2: CHIP_THERAPY - Emergency healing (HP < 40%)
        if (this.shouldUseTherapy()) {
            var therapyTarget = this.findTherapyTarget()
            if (therapyTarget != null) {
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_THERAPY)
                // Update action with correct target cell
                this._actions[count(this._actions) - 1].targetCell = therapyTarget
                player._currTp -= 7
                debug("[STR] Applied CHIP_THERAPY (75-80 HP heal)")
            }
        }

        // PRIORITY 3: CHIP_ANTIDOTE - Remove poison (clears poison + 25-35 HP heal)
        if (this.shouldUseAntidote()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ANTIDOTE)
            // Target self
            this._actions[count(this._actions) - 1].targetCell = player._cellPos
            player._currTp -= 3
            debug("[STR] Applied CHIP_ANTIDOTE (remove poison + 25-35 HP heal)")
        }

        // PRIORITY 4: CHIP_INVERSION - Hybrid heal + damage setup (HP < 60%)
        if (this.shouldUseInversion(target)) {
            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_INVERSION)
            // Target cell is enemy position (will swap)
            this._actions[count(this._actions) - 1].targetCell = target._cellPos
            player._currTp -= 4
            debug("[STR] Applied CHIP_INVERSION (50 HP heal + 20% vulnerability on enemy)")
        }

        // PRIORITY 5: CHIP_FORTRESS - Defensive buff (HP < 50%, no poison)
        if (this.shouldUseFortress()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_FORTRESS)
            // Target self
            this._actions[count(this._actions) - 1].targetCell = player._cellPos
            player._currTp -= 6
            debug("[STR] Applied CHIP_FORTRESS (7-8% damage reduction for 3 turns)")
        }

        // PRIORITY 6: CHIP_WALL - Weaker defensive buff (HP < 60%, no poison, fallback)
        if (this.shouldUseWall()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_WALL)
            // Target self
            this._actions[count(this._actions) - 1].targetCell = player._cellPos
            player._currTp -= 3
            debug("[STR] Applied CHIP_WALL (4-5% damage reduction for 2 turns)")
        }

        // PRIORITY 7: Apply CHIP_STEROID before combat if needed
        if (this.shouldUseSteroid()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_STEROID)
            player._currTp -= 7
            debug("[STR] Applied CHIP_STEROID (+150-170 Strength for 3 turns)")
        }

        // PRIORITY 8: Check for CHIP_LEATHER_BOOTS if target cell unreachable
        if (targetHitCell != -1 && targetHitCell != null && this.shouldUseLeatherBoots(targetHitCell._id)) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_LEATHER_BOOTS)
            player._currTp -= 3
            player._currMp += 2  // Immediate MP boost
            debug("[STR] Applied CHIP_LEATHER_BOOTS (+2 MP for 2 turns)")
        }

        // PRIORITY 9: Check for tactical CHIP_LIBERATION usage BEFORE combat
        if (this.shouldUseLiberation(target)) {
            // Use on enemy to remove their buffs, or on self to remove debuffs
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[STR] Using Liberation on self to remove debuffs")
            } else {
                debug("[STR] Using Liberation on enemy to remove buffs/shields")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            // Update action with correct target cell
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            player._currTp -= 5
        }

        // Check for OTKO opportunity first (low HP enemies)
        var hpThreshold = min(target._maxHealth * 0.35, 500)  // 35% HP or 500 HP, whichever is lower
        if (target._currHealth <= hpThreshold) {
            debug("[STR] Enemy HP below OTKO threshold: " + target._currHealth + " <= " + hpThreshold)
            var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
            if (otkoExecuted) {
                debug("[STR] OTKO scenario executed successfully")
                return  // OTKO actions planned, skip normal offensive logic
            }
            debug("[STR] OTKO not viable, falling back to normal offensive scenario")
        }

        // Re-compute best pure weapon cell ignoring chip-only high damage cells.
        var bestWeaponCell = -1
        var bestWeaponDamage = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in fieldMap.damageMap) {
            if (c._highestDamageWeapon == -1) continue
            var dist = getPathLength(playerPos, c._id)
            if (dist == null) continue
            // Prefer higher weaponDamage, tie-break shorter distance
            if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                bestWeaponDamage = c._weaponDamage
                bestWeaponCell = c
                bestDist = dist
            }
        }
        // Fallback to incoming targetHitCell if no weapon cell found (should be rare)
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) bestWeaponCell = targetHitCell
        if (bestWeaponCell == -1) {
            debug("[STR] No weapon cell found; falling back to base logic")
            return super.createOffensiveScenario(target, targetHitCell)
        }

        // Execute shared weapon-focused combat logic (no chip exclusions for strength)
        var playerMP = player._currMp
        var playerTP = player._currTp
        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [], "STR")

        debug("[STR] Offensive scenario complete. Remaining TP: " + result['playerTP'] + ", MP: " + result['playerMP'])
    }

}
