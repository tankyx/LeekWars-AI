include('action.lk')
include('base_strategy.lk')

class StrengthStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "STR"
    }

    createOTKOScenario(target, targetHitCell) {
        debug("[OTKO-V2] Starting OTKO scenario creation (teleport optimization enabled)")

        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST-OTKO] Chest detected! Switching OTKO target from enemy to chest (ID: " + chest._id + ")")
            target = chest
        }

        var playerTP = player._currTp
        var playerPos = player._cellPos

        var burstFromCurrent = this.calculateBurstDamage(target, playerPos, playerTP)
        var killProbCurrent = burstFromCurrent / target._currHealth
        debug("[OTKO-V2] Current position (cell=" + playerPos + "): damage=" + floor(burstFromCurrent) + " kill prob=" + round(killProbCurrent * 100) + "%")

        var shouldTeleport = false
        var teleportInfo = null
        var teleCell = playerPos

        var hasTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)
        var teleportReady = hasTeleport && getCooldown(CHIP_TELEPORTATION, player._id) == 0
        var enoughTPForTeleport = playerTP >= 24

        debug("[OTKO-V2] Teleport check: equipped=" + hasTeleport + " ready=" + teleportReady + " TP=" + playerTP + " (need 24)")

        if (hasTeleport && teleportReady && enoughTPForTeleport) {
            debug("[OTKO-V2] Evaluating teleport option...")
            teleportInfo = fieldMap.findOptimalTeleportCell(target)
            if (teleportInfo != null) {
                var teleportDamage = teleportInfo['damage']
                var killProbTeleport = teleportInfo['killProbability']

                var damageImprovement = teleportDamage / burstFromCurrent
                debug("[OTKO-V2] Teleport option (cell=" + teleportInfo['cell'] + "): damage=" + floor(teleportDamage) + " kill prob=" + round(killProbTeleport * 100) + "% (improvement: " + round(damageImprovement * 100) + "%)")

                if (killProbCurrent >= 0.85) {
                    debug("[OTKO-V2] Current position viable (>85%), checking if teleport offers 20%+ boost...")
                    if (damageImprovement > 1.2) {
                        debug("[OTKO-V2] DECISION: Teleporting for 20%+ damage boost")
                        shouldTeleport = true
                        teleCell = teleportInfo['cell']
                    } else {
                        debug("[OTKO-V2] DECISION: Stay at current position (improvement only " + round((damageImprovement - 1) * 100) + "%)")
                        shouldTeleport = false
                    }
                } else if (killProbTeleport >= 0.85) {
                    debug("[OTKO-V2] DECISION: Teleporting to reach 85% kill threshold (current only " + round(killProbCurrent * 100) + "%)")
                    shouldTeleport = true
                    teleCell = teleportInfo['cell']
                } else {
                    debug("[OTKO-V2] DECISION: Neither option reaches threshold (current=" + round(killProbCurrent * 100) + "% teleport=" + round(killProbTeleport * 100) + "%)")
                }
            } else {
                debug("[OTKO-V2] No valid teleport cells found")
            }
        } else {
            debug("[OTKO-V2] Teleport not available, using current position")
        }

        if (!shouldTeleport && killProbCurrent < 0.85) {
            debug("[OTKO] Cannot achieve 85% kill probability (current=" + round(killProbCurrent * 100) + "%, no viable teleport)")
            return false
        }

        var killProb = shouldTeleport ? teleportInfo['killProbability'] : killProbCurrent

        if (killProb < 0.85 && !(target instanceof Chest)) {
            var effectiveDamage = shouldTeleport ? teleportInfo['damage'] : burstFromCurrent
            debug("[OTKO] Kill probability too low: " + round(killProb * 100) + "% (damage: " + floor(effectiveDamage) + " vs HP: " + target._currHealth + ")")

            if (this.shouldUseAdrenaline(15)) {  
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
                playerTP -= 1
                playerTP += 5  
                player._currTp = playerTP  
                debug("[OTKO][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")

                teleportInfo = fieldMap.findOptimalTeleportCell(target)
                if (teleportInfo == null) {
                    debug("[OTKO][ADRENALINE] Recalculation failed")
                    return false
                }

                var newKillProb = teleportInfo['killProbability']
                if (newKillProb < 0.85) {
                    debug("[OTKO][ADRENALINE] Still insufficient kill probability after Adrenaline: " + round(newKillProb * 100) + "% (damage: " + teleportInfo['damage'] + " vs HP: " + target._currHealth + ")")
                    return false
                }
                debug("[OTKO][ADRENALINE] Recalculated kill probability: " + round(newKillProb * 100) + "% (sufficient for OTKO)")
            } else {
                return false
            }
        }

        if (shouldTeleport) {
            debug("[OTKO] Executing teleport OTKO to cell " + teleCell + " projected damage: " + teleportInfo['damage'])
        } else {
            debug("[OTKO] Executing OTKO from current position (cell=" + teleCell + ") projected damage: " + floor(burstFromCurrent))
        }

        var plannedWeapon = getWeapon()

        if (shouldTeleport && mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO) && playerTP >= 21) {
            var preTeleportDist = getCellDistance(player._cellPos, target._cellPos)
            var preTeleportAligned = this.isDiagonal(player._cellPos, target._cellPos)

            if (preTeleportDist != null && preTeleportDist >= 2 && preTeleportDist <= 6 &&
                preTeleportAligned && lineOfSight(player._cellPos, target._cellPos)) {

                debug("[OTKO][NEUTRINO] Pre-stacking vulnerability before teleport for amplified OTKO")

                if (plannedWeapon != WEAPON_NEUTRINO) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, WEAPON_NEUTRINO, -1)
                    playerTP -= 1
                    plannedWeapon = WEAPON_NEUTRINO
                }

                for (var nStack = 0; nStack < 3; nStack++) {
                    if (playerTP >= 4) {
                        this.createAttackAction(Action.ACTION_DIRECT, target, WEAPON_NEUTRINO, -1)
                        playerTP -= 4
                    }
                }

                debug("[OTKO][NEUTRINO] Queued 3x Neutrino for 24% vulnerability stacking, TP remaining: " + playerTP + " - now queueing teleport + burst")
            } else {
                debug("[OTKO][NEUTRINO] Cannot pre-stack: dist=" + preTeleportDist + " (need 2-6), diagonal=" + preTeleportAligned + ", TP=" + playerTP)
            }
        }

        if (shouldTeleport) {
            this.createAttackAction(Action.ACTION_TELEPORT, target, -1, CHIP_TELEPORTATION)
            this._actions[count(this._actions) - 1].targetCell = teleCell
            playerTP -= 9
        }

        playerPos = teleCell

        var weaponDmgList = []
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            var distToTarget = getCellDistance(teleCell, target._cellPos)
            if (distToTarget == null) continue
            if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
            if (!lineOfSight(teleCell, target._cellPos)) continue

            var netDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, player._science, wid, target)
            push(weaponDmgList, ['weapon': wObj, 'netDmg': netDmg])
        }

        for (var i = 0; i < count(weaponDmgList); i++) {
            var bestIdx = i
            for (var j = i + 1; j < count(weaponDmgList); j++) {
                if (weaponDmgList[j]['netDmg'] > weaponDmgList[bestIdx]['netDmg']) bestIdx = j
            }
            if (bestIdx != i) {
                var tmp = weaponDmgList[i]
                weaponDmgList[i] = weaponDmgList[bestIdx]
                weaponDmgList[bestIdx] = tmp
            }
        }

        for (var wi = 0; wi < count(weaponDmgList); wi++) {
            var wRec = weaponDmgList[wi]
            var wObj = wRec['weapon']

            if (plannedWeapon != wObj._id) {
                if (playerTP >= 1 + wObj._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                    plannedWeapon = wObj._id
                } else {
                    continue  
                }
            }

            var uses = min(wObj._maxUse, floor(playerTP / wObj._cost))
            while (uses > 0 && playerTP >= wObj._cost) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses -= 1
            }

            if (playerTP <= 0) break
        }

        if (playerTP > 0) {
            var chipDmgList = []
            for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                if (cid == CHIP_TELEPORTATION) continue

                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                var distChip = getCellDistance(teleCell, target._cellPos)
                if (distChip == null) continue
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(teleCell, target._cellPos)) continue

                var netChipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, player._science, cid, target)
                push(chipDmgList, ['chip': chipObj, 'netDmg': netChipDmg])
            }

            for (var ci = 0; ci < count(chipDmgList); ci++) {
                var bestCIdx = ci
                for (var cj = ci + 1; cj < count(chipDmgList); cj++) {
                    if (chipDmgList[cj]['netDmg'] > chipDmgList[bestCIdx]['netDmg']) bestCIdx = cj
                }
                if (bestCIdx != ci) {
                    var tmpC = chipDmgList[ci]
                    chipDmgList[ci] = chipDmgList[bestCIdx]
                    chipDmgList[bestCIdx] = tmpC
                }
            }

            for (var chipIdx = 0; chipIdx < count(chipDmgList); chipIdx++) {
                var cRec = chipDmgList[chipIdx]
                var chipUse = cRec['chip']
                if (playerTP < chipUse._cost) continue
                
                var actualUsesC = 0
                while (actualUsesC < chipUse._maxUse && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    actualUsesC += 1
                }
                if (playerTP <= 0) break
            }
        }

        debug("[OTKO] OTKO scenario complete, remaining TP: " + playerTP)
        return true
    }

    shouldUseSteroid() {
        
        if (!this.shouldApplyStatBuff(CHIP_STEROID, EFFECT_BUFF_STRENGTH, 15)) return false

        if (!this.validateTPBudget(7)) return false

        return true
    }

    isInCombatRange() {
        var enemies = fieldMap.getEnemySubMap()
        for (var e in enemies) {
            if (isDead(e._id)) continue
            var dist = getCellDistance(player._cellPos, e._cellPos)
            if (dist != null && dist <= 8) {
                debug("[STR][COMBAT-RANGE] Enemy ID=" + e._id + " at distance " + dist + " (in combat range)")
                return true
            }
        }
        debug("[STR][COMBAT-RANGE] No enemies within distance 8 (not in combat)")
        return false
    }

    shouldUseAntidote() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_ANTIDOTE)) {
            debug("[STR][ANTIDOTE] Not equipped")
            return false
        }

        var cooldown = getCooldown(CHIP_ANTIDOTE, getEntity())
        if (cooldown > 0) {
            debug("[STR][ANTIDOTE] On cooldown: " + cooldown + " turns")
            return false
        }

        var playerTP = player._currTp
        if (playerTP < 3) {
            debug("[STR][ANTIDOTE] Insufficient TP: " + playerTP + " < 3")
            return false
        }

        if (!player.hasEffect(EFFECT_POISON)) {
            debug("[STR][ANTIDOTE] Not poisoned")
            return false
        }

        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)
        if (poisonRemaining < 2) {
            debug("[STR][ANTIDOTE] Poison too weak: " + poisonRemaining + " turns remaining")
            return false
        }

        var poisonDamagePerTurn = player.getEffectValue(EFFECT_POISON)
        if (poisonDamagePerTurn == null) poisonDamagePerTurn = 0

        var totalPoisonDamage = poisonDamagePerTurn * poisonRemaining

        var availableHealing = 0

        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REMISSION)) {
            var remissionCD = getCooldown(CHIP_REMISSION, getEntity())
            if (remissionCD == 0 && playerTP >= 10) {  
                availableHealing += 125
            }
        }

        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)) {
            var regenCD = getCooldown(CHIP_REGENERATION, getEntity())
            if (regenCD == 0 && playerTP >= 11) {  
                availableHealing += 500
            }
        }

        var currentHP = player._currHealth
        if (totalPoisonDamage >= currentHP) {
            debug("[STR][ANTIDOTE] LETHAL poison: " + totalPoisonDamage + " total dmg (" + poisonDamagePerTurn + "/turn × " + poisonRemaining + " turns) vs " + currentHP + " HP - MUST CLEANSE!")
            return true
        }

        if (totalPoisonDamage <= availableHealing) {
            debug("[STR][ANTIDOTE] Poison SUSTAINABLE: " + totalPoisonDamage + " dmg (" + poisonDamagePerTurn + "/turn) vs " + availableHealing + " heal available - saving antidote")
            return false  
        }

        debug("[STR][ANTIDOTE] Poison NOT sustainable: " + totalPoisonDamage + " dmg (" + poisonDamagePerTurn + "/turn × " + poisonRemaining + " turns) vs " + availableHealing + " heal - using ANTIDOTE")
        return true
    }

    shouldUseTherapy() {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_THERAPY)) return false

        var cooldown = getCooldown(CHIP_THERAPY, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 13) return false  

        var hpPercent = (player._currHealth * 100) / player._maxHealth
        if (hpPercent >= 40) return false

        var hpMissing = player._maxHealth - player._currHealth
        if (hpMissing < 50) return false  

        debug("[STR][THERAPY] HP at " + hpPercent + "% (" + player._currHealth + "/" + player._maxHealth + "), should use THERAPY")
        return true
    }

    findTherapyTarget() {
        var playerPos = player._cellPos

        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_THERAPY)) return null
        var therapyChip = arsenal.playerEquippedChips[CHIP_THERAPY]

        var adjacentCells = [
            getCellFromXY(getCellX(playerPos) + 1, getCellY(playerPos)),
            getCellFromXY(getCellX(playerPos) - 1, getCellY(playerPos)),
            getCellFromXY(getCellX(playerPos), getCellY(playerPos) + 1),
            getCellFromXY(getCellX(playerPos), getCellY(playerPos) - 1)
        ]

        for (var targetCell in adjacentCells) {
            if (targetCell == null) continue

            var dist = getCellDistance(playerPos, targetCell)
            if (dist == null || dist < 1 || dist > 5) continue

            var affectedCells = fieldMap.getAoEAffectedCells(targetCell, therapyChip._aoeType, playerPos)
            var playerInAoE = false
            for (var i = 0; i < count(affectedCells); i++) {
                if (affectedCells[i] == playerPos) {
                    playerInAoE = true
                    break
                }
            }

            if (playerInAoE) {
                debug("[STR][THERAPY] Found valid therapy target cell: " + targetCell)
                return targetCell
            }
        }

        debug("[STR][THERAPY] No valid therapy target cell found")
        return null
    }

    shouldUseInversion(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_INVERSION)) return false

        var cooldown = getCooldown(CHIP_INVERSION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 13) return false  

        var playerPos = player._cellPos
        var targetPos = target._cellPos
        var dist = getCellDistance(playerPos, targetPos)
        if (dist == null || dist < 1 || dist > 14) return false

        var playerX = getCellX(playerPos)
        var playerY = getCellY(playerPos)
        var targetX = getCellX(targetPos)
        var targetY = getCellY(targetPos)

        var isAligned = (playerX == targetX) || (playerY == targetY)
        if (!isAligned) return false

        if (!lineOfSight(playerPos, targetPos)) return false

        debug("[STR][INVERSION] Enemy in line at distance " + dist + ", TP=" + playerTP + " (offensive usage)")
        return true
    }

    getComboRequiredTP() {
        var requiredTP = 0

        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
            var cooldown = getCooldown(CHIP_STEROID, getEntity())
            if (cooldown == 0) {
                requiredTP += 7  
            }
        }

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD) &&
            mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
            var grappleCooldown = getCooldown(CHIP_GRAPPLE, getEntity())
            if (grappleCooldown == 0) {
                requiredTP += 18  
            }
        }

        if (requiredTP > 0) {
            debug("[STR][COMBO-TP] Combo requires " + requiredTP + " TP")
        }

        return requiredTP
    }

    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        var enemyShielded = target._relShield > 15 || target._absShield > 30
        var enemyHasDamageReturn = target.hasEffect(EFFECT_DAMAGE_RETURN)
        var enemyHasResistance = target.hasEffect(EFFECT_BUFF_RESISTANCE)

        if (hasDebuff) {
            debug("[LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyHasResistance) {
            debug("[LIBERATION] Should use to strip enemy resistance buff (increases our damage)")
            return true
        }
        if (enemyShielded) {
            debug("[LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }
        if (enemyHasDamageReturn) {
            debug("[LIBERATION] Should use to strip enemy damage return")
            return true
        }

        return false
    }

    isOnSameLine(cell1, cell2) {
        var x1 = getCellX(cell1)
        var y1 = getCellY(cell1)
        var x2 = getCellX(cell2)
        var y2 = getCellY(cell2)
        return (x1 == x2 || y1 == y2)  
    }

    findNeutrinoStackingCell(target) {
        var bestCell = -1
        var bestScore = -1

        var reachableCells = fieldMap.getAccessibleCells(player)
        for (var i = 0; i < count(reachableCells); i++) {
            var cell = reachableCells[i]
            var dist = getCellDistance(cell, target._cellPos)

            if (dist == null || dist < 2 || dist > 6) continue

            if (!this.isDiagonal(cell, target._cellPos)) continue

            if (!lineOfSight(cell, target._cellPos)) continue

            var rangePenalty = abs(dist - 4) * 3  
            var distFromCurrent = getCellDistance(player._cellPos, cell)
            if (distFromCurrent == null) continue

            var score = 100 - rangePenalty - distFromCurrent

            if (score > bestScore) {
                bestScore = score
                bestCell = cell
            }
        }

        if (bestCell != -1) {
            debug("[STR][NEUTRINO-POS] Found stacking position: cell " + bestCell + " (score=" + bestScore + ")")
        }

        return bestCell
    }

    findGrappleHeavySwordCell(target) {
        var bestCell = -1
        var bestScore = -1

        var reachableCells = fieldMap.getAccessibleCells(player)
        for (var i = 0; i < count(reachableCells); i++) {
            var cell = reachableCells[i]
            var dist = getCellDistance(cell, target._cellPos)

            if (dist == null || dist < 2 || dist > 8) continue

            if (!this.isOnSameLine(cell, target._cellPos)) continue

            if (!lineOfSight(cell, target._cellPos)) continue

            var rangePenalty = abs(dist - 5) * 5  
            var distFromCurrent = getCellDistance(player._cellPos, cell)
            if (distFromCurrent == null) continue

            var score = 100 - rangePenalty - distFromCurrent

            if (score > bestScore) {
                bestScore = score
                bestCell = cell
            }
        }

        if (bestCell != -1) {
            debug("[STR][GRAPPLE-HS] Found combo position: cell " + bestCell + " (score=" + bestScore + ")")
        }

        return bestCell
    }

    shouldUseGrappleHeavySword(target) {
        
        if (!mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD)) {
            debug("[STR][GRAPPLE-HS] HEAVY_SWORD not equipped")
            return false
        }

        var playerTP = player._currTp
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null) return false

        if (dist == 1) {
            
            var requiredTP = 15
            if (getWeapon() != WEAPON_HEAVY_SWORD) {
                requiredTP = 16  
            }

            if (playerTP < requiredTP) {
                debug("[STR][GRAPPLE-HS] Enemy adjacent but insufficient TP: " + playerTP + " < " + requiredTP)
                return false
            }
            debug("[STR][GRAPPLE-HS] Enemy adjacent, will use HEAVY_SWORD directly")
            return true
        }

        if (dist >= 2 && dist <= 8) {
            if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE)) {
                debug("[STR][GRAPPLE-HS] GRAPPLE not equipped, can't pull enemy")
                return false
            }

            var cooldown = getCooldown(CHIP_GRAPPLE, getEntity())
            if (cooldown > 0) {
                debug("[STR][GRAPPLE-HS] GRAPPLE on cooldown: " + cooldown + " turns")
                return false
            }

            var comboTPCost = 18  
            if (getWeapon() != WEAPON_HEAVY_SWORD) {
                comboTPCost = 19  
            }

            if (playerTP < comboTPCost) {
                debug("[STR][GRAPPLE-HS] Insufficient TP for combo: " + playerTP + " < " + comboTPCost)
                return false
            }

            var aligned = this.isOnSameLine(player._cellPos, target._cellPos)
            if (!aligned) {
                debug("[STR][GRAPPLE-HS] Not on same line (diagonal), can't use GRAPPLE")
                return false
            }

            if (!lineOfSight(player._cellPos, target._cellPos)) {
                debug("[STR][GRAPPLE-HS] No line of sight to enemy")
                return false
            }

            var pathToTarget = getPath(player._cellPos, target._cellPos)
            if (pathToTarget == null || count(pathToTarget) == 0) {
                debug("[STR][GRAPPLE-HS] No valid path to target (obstacles blocking)")
                return false
            }

            var playerX = getCellX(player._cellPos)
            var playerY = getCellY(player._cellPos)
            var enemyX = getCellX(target._cellPos)
            var enemyY = getCellY(target._cellPos)

            var pullDestX = playerX
            var pullDestY = playerY

            if (playerY == enemyY) {
                
                pullDestX = (enemyX > playerX) ? playerX + 1 : playerX - 1
            } else {
                
                pullDestY = (enemyY > playerY) ? playerY + 1 : playerY - 1
            }

            var pullDestCell = getCellFromXY(pullDestX, pullDestY)
            if (pullDestCell == null || isObstacle(pullDestCell)) {
                debug("[STR][GRAPPLE-HS] Pull destination blocked (cell " + pullDestCell + ")")
                return false
            }

            if (isEntity(pullDestCell) && getEntityOnCell(pullDestCell) != target._id) {
                debug("[STR][GRAPPLE-HS] Pull destination occupied by another entity")
                return false
            }

            debug("[STR][GRAPPLE-HS] Combo ready: aligned, range " + dist + ", TP=" + playerTP + ", path clear")
            return true
        }

        debug("[STR][GRAPPLE-HS] Enemy out of range: " + dist)
        return false
    }

    executeGrappleHeavySwordCombo(target) {
        var dist = getCellDistance(player._cellPos, target._cellPos)

        if (dist == 1) {
            debug("[STR][GRAPPLE-HS] Enemy already adjacent, using HEAVY_SWORD only")

            if (getWeapon() != WEAPON_HEAVY_SWORD) {
                setWeapon(WEAPON_HEAVY_SWORD)
                player._currTp -= 1
                debug("[STR][GRAPPLE-HS] Swapped to HEAVY_SWORD (1 TP)")
            }

            useWeaponOnCell(target._cellPos)
            player._currTp -= 15
            debug("[STR][GRAPPLE-HS] HEAVY_SWORD executed (60 vulnerability), TP remaining: " + player._currTp)
            return true
        }

        var playerX = getCellX(player._cellPos)
        var playerY = getCellY(player._cellPos)
        var enemyX = getCellX(target._cellPos)
        var enemyY = getCellY(target._cellPos)

        var grappleCell = -1

        if (playerY == enemyY) {
            
            if (enemyX < playerX) {
                
                grappleCell = getCellFromXY(playerX - 1, playerY)
            } else {
                
                grappleCell = getCellFromXY(playerX + 1, playerY)
            }
        } else if (playerX == enemyX) {
            
            if (enemyY < playerY) {
                
                grappleCell = getCellFromXY(playerX, playerY - 1)
            } else {
                
                grappleCell = getCellFromXY(playerX, playerY + 1)
            }
        }

        if (grappleCell == -1 || grappleCell == null) {
            
            debug("[STR][GRAPPLE-HS] ERROR: Could not calculate adjacent cell on axis")
            grappleCell = player._cellPos
        }

        var alignment = (playerY == enemyY) ? "horizontal" : "vertical"
        debug("[STR][GRAPPLE-HS] Player at (" + playerX + "," + playerY + ") Enemy at (" + enemyX + "," + enemyY + ") Alignment: " + alignment)
        debug("[STR][GRAPPLE-HS] Executing GRAPPLE to pull enemy from range " + dist + " toward cell " + grappleCell)

        useChipOnCell(CHIP_GRAPPLE, grappleCell)
        player._currTp -= 3

        target.updateEntity()

        if (getWeapon() != WEAPON_HEAVY_SWORD) {
            setWeapon(WEAPON_HEAVY_SWORD)
            player._currTp -= 1
            debug("[STR][GRAPPLE-HS] Swapped to HEAVY_SWORD (1 TP)")
        }

        useWeaponOnCell(target._cellPos)
        player._currTp -= 15

        debug("[STR][GRAPPLE-HS] Combo executed: GRAPPLE → HEAVY_SWORD (60 vulnerability), TP remaining: " + player._currTp)
        return true
    }

    shouldStackNeutrino(target) {
        
        if (!mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            return false
        }

        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null) return false

        if (dist < 2 || dist > 6) {
            debug("[STR][NEUTRINO] Out of range: " + dist + " (need 2-6)")
            return false
        }

        if (!this.isDiagonal(player._cellPos, target._cellPos)) {
            debug("[STR][NEUTRINO] Not on diagonal")
            return false
        }

        if (!lineOfSight(player._cellPos, target._cellPos)) {
            debug("[STR][NEUTRINO] No line of sight")
            return false
        }

        if (player._currTp < 12) {
            debug("[STR][NEUTRINO] Insufficient TP: " + player._currTp + " < 12")
            return false
        }

        var currentStacks = arsenal.getVulnerabilityStacks(target)

        var vulnRemaining = target.getEffectRemaining(EFFECT_VULNERABILITY)

        if (currentStacks >= 3 && vulnRemaining >= 2) {
            debug("[STR][NEUTRINO] Already at max stacks (3), remaining: " + vulnRemaining + " turns, relShield: " + target._relShield)
            return false
        }

        if (currentStacks >= 2 && vulnRemaining <= 1 && vulnRemaining > 0) {
            debug("[STR][NEUTRINO] Refreshing expiring vulnerability (stacks=" + currentStacks + ", remaining=" + vulnRemaining + ", relShield: " + target._relShield + ")")
            return true
        }

        if (target._currHealth < 500) {
            debug("[STR][NEUTRINO] Enemy HP too low for stacking: " + target._currHealth)
            return false
        }

        var avgWeaponDamage = 180  
        if (player.hasEffect(EFFECT_BUFF_STRENGTH)) {
            avgWeaponDamage = 240  
        }

        var futureAttacks = floor((player._currTp - 12) / 8) + 4  

        var benefit = arsenal.calculateNeutrinoAmplification(3, futureAttacks, avgWeaponDamage)

        debug("[STR][NEUTRINO] Amplification analysis: " + floor(benefit['netBenefit']) + " total value (" + floor(benefit['amplification']) + " amp + " + floor(benefit['directDamage']) + " direct)")
        debug("[STR][NEUTRINO] Multiplier: " + benefit['multiplier'] + "x, Future attacks: " + futureAttacks + ", Avg dmg: " + avgWeaponDamage)

        var threshold = 150
        if (player._currTp >= 20) threshold = 100  

        if (benefit['netBenefit'] >= threshold) {
            debug("[STR][NEUTRINO] Value check PASSED: " + floor(benefit['netBenefit']) + " >= " + threshold)
            return true
        } else {
            debug("[STR][NEUTRINO] Value check FAILED: " + floor(benefit['netBenefit']) + " < " + threshold)
            return false
        }
    }

    executeNeutrinoStacking(target) {
        debug("[STR][NEUTRINO] Executing vulnerability stacking sequence")

        if (getWeapon() != WEAPON_NEUTRINO) {
            setWeapon(WEAPON_NEUTRINO)
            player._currTp -= 1
            debug("[STR][NEUTRINO] Swapped to Neutrino (1 TP)")
        }

        var stacksApplied = 0
        for (var i = 0; i < 3; i++) {
            if (player._currTp >= 4) {
                useWeaponOnCell(target._cellPos)
                player._currTp -= 4
                stacksApplied += 1
            }
        }

        target.updateEntity()

        var totalVuln = stacksApplied * 8
        var currentRelShield = target._relShield
        debug("[STR][NEUTRINO] Applied " + stacksApplied + " stacks (" + totalVuln + "% vulnerability)")
        debug("[STR][NEUTRINO] Target relative shield now: " + currentRelShield + "%, TP remaining: " + player._currTp)

        return stacksApplied >= 2  
    }

    createOffensiveScenario(target, targetHitCell) {
        
        var comboExecuted = false

        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            
            fieldMap.buildHitMap(chest._cellPos)
            targetHitCell = fieldMap.getBestWeaponOrChipCell()
        }

        var canTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                         getCooldown(CHIP_TELEPORTATION, getEntity()) == 0 &&
                         player._currTp >= 15  

        if (canTeleport) {
            
            var teleportInfo = fieldMap.findOptimalTeleportCell(target)
            if (teleportInfo != null) {
                var teleCell = teleportInfo['cell']
                var killProb = teleportInfo['killProbability']
                var projectedDamage = teleportInfo['damage']
                var enemyHP = target._currHealth

                debug("[STR][OTKO-ATTRITION] Enemy HP: " + enemyHP + ", Projected damage: " + floor(projectedDamage) + ", Kill prob: " + round(killProb * 100) + "%")

                if (killProb >= 0.85) {
                    debug("[STR][OTKO-ATTRITION] OTKO NOW VIABLE! Enemy weakened to " + enemyHP + " HP, executing kill shot!")
                    var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
                    if (otkoExecuted) {
                        debug("[STR] OTKO scenario executed successfully (attrition-based)")
                        return  
                    }
                    debug("[STR] OTKO execution failed, falling back to normal offensive scenario")
                }
                
                else if (enemyHP < 1500) {
                    debug("[STR][OTKO-ATTRITION] Enemy at " + enemyHP + " HP, need " + round((killProb * 100)) + "% → 85% kill prob (continue attrition)")
                }
            }
        }

        if (!player.hasEffect(EFFECT_BUFF_STRENGTH)) {
            
            var shouldApplySteroid = true

            if (canTeleport) {
                var teleportInfo = fieldMap.findOptimalTeleportCell(target)
                if (teleportInfo != null && teleportInfo['killProbability'] >= 0.85) {
                    shouldApplySteroid = false  
                    debug("[STR][BUFF-REAPPLY] Skipping STEROID - OTKO executed (TP used for kill)")
                }
            }

            if (shouldApplySteroid) {
                var minTPForBurst = 20  
                var playerTP = player._currTp

                debug("[STR][BUFF-REAPPLY] STEROID expired, checking TP for reapplication (TP=" + playerTP + ", threshold=" + minTPForBurst + ")")

                if (playerTP < minTPForBurst && playerTP >= 16) {
                    if (this.shouldUseAdrenaline(minTPForBurst)) {
                        debug("[STR][BUFF-REAPPLY] Using ADRENALINE to bridge TP gap (have " + playerTP + ", need " + minTPForBurst + ")")
                        useChip(CHIP_ADRENALINE, player._id)
                        player._currTp = player._currTp - 1 + 5  
                        playerTP = player._currTp
                        debug("[STR][BUFF-REAPPLY] After ADRENALINE: TP=" + playerTP)
                    }
                }

                if (playerTP >= minTPForBurst && this.isChipAvailable(CHIP_STEROID, 7)) {
                    debug("[STR][BUFF-REAPPLY] Reapplying STEROID (TP=" + playerTP + ")")
                    useChip(CHIP_STEROID, player._id)
                    player._currTp -= 7
                    debug("[STR][BUFF-REAPPLY] STEROID active! +160 STR for 3 turns, TP remaining: " + player._currTp)

                    if (canTeleport && player._currTp >= 15) {
                        var teleportInfoBuffed = fieldMap.findOptimalTeleportCell(target)
                        if (teleportInfoBuffed != null) {
                            var killProbBuffed = teleportInfoBuffed['killProbability']
                            var dmgBuffed = teleportInfoBuffed['damage']

                            debug("[STR][OTKO-RECHECK] With STEROID: damage=" + floor(dmgBuffed) + " vs HP=" + target._currHealth + ", kill prob=" + round(killProbBuffed * 100) + "%")

                            if (killProbBuffed >= 0.85) {
                                debug("[STR][OTKO-RECHECK] STEROID enabled OTKO! Executing...")
                                var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
                                if (otkoExecuted) {
                                    debug("[STR] OTKO with STEROID executed successfully")
                                    return  
                                }
                            }
                        }
                    }
                } else if (playerTP < minTPForBurst) {
                    debug("[STR][BUFF-REAPPLY] Skipping STEROID - prioritizing attacks (TP=" + playerTP + ", threshold=" + minTPForBurst + ")")
                }
            }
        }

        var hpPercent = (player._currHealth * 100) / player._maxHealth

        var hasShield = player.hasEffect(EFFECT_RELATIVE_SHIELD)
        var shieldRemaining = hasShield ? player.getEffectRemaining(EFFECT_RELATIVE_SHIELD) : 0

        if (!hasShield || shieldRemaining <= 1) {
            
            if (this.isChipAvailable(CHIP_FORTRESS, 9) && player._currTp >= 9) {  
                debug("[STR][SHIELD] Applying FORTRESS (7-8% reduction, 3 turns, TP=" + player._currTp + ")")
                useChip(CHIP_FORTRESS, player._id)
                player._currTp -= 6
            }
            
            else if (this.isChipAvailable(CHIP_WALL, 6) && player._currTp >= 6) {  
                debug("[STR][SHIELD] Applying WALL (4-5% reduction, 2 turns, TP=" + player._currTp + ")")
                useChip(CHIP_WALL, player._id)
                player._currTp -= 3
            }
        } else {
            debug("[STR][SHIELD] Shield active with " + shieldRemaining + " turns remaining")
        }

        var inSustainRange = hpPercent >= 30 && hpPercent <= 50
        var hasSustainTP = player._currTp >= 10  

        if (inSustainRange && hasSustainTP) {
            debug("[STR][SUSTAIN] HP at " + round(hpPercent) + "%, applying REMISSION healing (TP=" + player._currTp + ")")

            if (this.isChipAvailable(CHIP_REMISSION, 5)) {
                debug("[STR][SUSTAIN] Using REMISSION (TP=" + player._currTp + ")")
                useChip(CHIP_REMISSION, player._id)
                player._currTp -= 5
            }
        }

        var neutrinoExecuted = false

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            var neutrinoDist = getCellDistance(player._cellPos, target._cellPos)
            var neutrinoAligned = this.isDiagonal(player._cellPos, target._cellPos)

            if (neutrinoDist != null && neutrinoDist >= 2 && neutrinoDist <= 6 &&
                neutrinoAligned && lineOfSight(player._cellPos, target._cellPos)) {

                if (this.shouldStackNeutrino(target)) {
                    debug("[STR][NEUTRINO] In range, executing stacking from current position")
                    if (this.executeNeutrinoStacking(target)) {
                        neutrinoExecuted = true
                        debug("[STR][NEUTRINO] Stacking complete, continuing with amplified weapons")
                    }
                }
            }
            
            else if (player._currMp >= 2 && player._currTp >= 12) {
                var neutrinoCell = this.findNeutrinoStackingCell(target)
                if (neutrinoCell != -1) {
                    var pathToNeutrinoCell = getPath(player._cellPos, neutrinoCell)
                    if (pathToNeutrinoCell != null && count(pathToNeutrinoCell) <= player._currMp) {
                        debug("[STR][NEUTRINO] Moving to stacking position (cell " + neutrinoCell + ", " + count(pathToNeutrinoCell) + " MP)")
                        var moveResult = moveTowardCell(neutrinoCell)
                        player._currMp -= count(pathToNeutrinoCell)
                        player._cellPos = getCell()

                        if (this.shouldStackNeutrino(target)) {
                            if (this.executeNeutrinoStacking(target)) {
                                neutrinoExecuted = true
                                debug("[STR][NEUTRINO] Repositioned and stacked vulnerability")
                            }
                        }
                    }
                } else {
                    debug("[STR][NEUTRINO] Not in range (dist=" + neutrinoDist + " diagonal=" + neutrinoAligned + "), no good repositioning cell found")
                }
            } else {
                debug("[STR][NEUTRINO] Not in range (dist=" + neutrinoDist + " diagonal=" + neutrinoAligned + "), insufficient resources to reposition")
            }
        }

        var comboAttempted = false  

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_HEAVY_SWORD) &&
            mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE) &&
            getCooldown(CHIP_GRAPPLE, getEntity()) == 0 &&
            player._currTp >= 18) {

            var currentDist = getCellDistance(player._cellPos, target._cellPos)
            var currentlyAligned = this.isOnSameLine(player._cellPos, target._cellPos)

            if (currentDist != null && currentDist >= 1 && currentDist <= 8 && currentlyAligned) {
                debug("[STR][GRAPPLE-HS] In combo position (dist=" + currentDist + " aligned=true), will execute combo")
                comboAttempted = true  
            } else {
                debug("[STR][GRAPPLE-HS] Not in combo position (dist=" + currentDist + " aligned=" + currentlyAligned + "), skipping combo")
            }

            if (this.shouldUseGrappleHeavySword(target)) {
                if (this.executeGrappleHeavySwordCombo(target)) {
                    debug("[STR] GRAPPLE-HEAVY_SWORD combo executed successfully")
                    comboExecuted = true  

                    target.updateEntity()

                } else {
                    debug("[STR] GRAPPLE-HEAVY_SWORD combo execution failed")
                }
            }
        }

        if (this.shouldUseAntidote()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ANTIDOTE)
            
            this._actions[count(this._actions) - 1].targetCell = player._cellPos
            player._currTp -= 3
            debug("[STR] Applied CHIP_ANTIDOTE (remove poison + 25-35 HP heal)")
        }

        if (hpPercent < 25 && this.shouldUseTherapy()) {
            var therapyTarget = this.findTherapyTarget()
            if (therapyTarget != null) {
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_THERAPY)
                
                this._actions[count(this._actions) - 1].targetCell = therapyTarget
                player._currTp -= 7
                debug("[STR] Applied CHIP_THERAPY (75-80 HP heal)")
            }
        }

        if (!comboAttempted && this.shouldUseInversion(target)) {
            
            var playerOldPos = player._cellPos
            var targetOldPos = target._cellPos

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_INVERSION)
            
            this._actions[count(this._actions) - 1].targetCell = target._cellPos
            player._currTp -= 4

            player._cellPos = targetOldPos  
            target._cellPos = playerOldPos  

            debug("[STR] Applied CHIP_INVERSION (50 HP heal + 20% vulnerability on enemy)")
            debug("[STR][INVERSION] Position swap: player " + playerOldPos + " → " + player._cellPos + ", enemy " + targetOldPos + " → " + target._cellPos)
        }

        if (this.shouldUseLiberation(target)) {
            
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[STR] Using Liberation on self to remove debuffs")
            } else {
                debug("[STR] Using Liberation on enemy to remove buffs/shields")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            player._currTp -= 5
        }

        if (comboExecuted) {
            debug("[STR] Combo executed, using remaining TP from current position")

            var playerTP = player._currTp
            var playerMP = player._currMp

            if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_ENHANCED_LIGHTNINGER)) {
                var lightninger = arsenal.playerEquippedWeapons[WEAPON_ENHANCED_LIGHTNINGER]
                var dist = getCellDistance(player._cellPos, target._cellPos)

                if (dist != null && dist >= 6 && dist <= 10 && playerTP >= 9) {
                    debug("[STR][COMBO] Enemy at range " + dist + ", can use LIGHTNINGER")

                    if (getWeapon() != WEAPON_ENHANCED_LIGHTNINGER) {
                        this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, WEAPON_ENHANCED_LIGHTNINGER, -1)
                        playerTP -= 1
                    }

                    var uses = min(lightninger._maxUse, floor(playerTP / 9))
                    while (uses > 0 && playerTP >= 9) {
                        this.createAttackAction(Action.ACTION_DIRECT, target, WEAPON_ENHANCED_LIGHTNINGER, -1)
                        playerTP -= 9
                        uses -= 1
                    }

                    player._currTp = playerTP
                } else {
                    debug("[STR][COMBO] Enemy at range " + dist + ", out of LIGHTNINGER range (6-10)")
                }
            }

            var hnsCell = fieldMap.findHideAndSeekCell("defensive", target)
            if (hnsCell != -1 && hnsCell != null) {
                var hideCellId = hnsCell['cell']
                debug("[STR][COMBO] Moving to hide-and-seek cell: " + hideCellId + " (danger=" + hnsCell['danger'] + ")")
                this.createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
            }

            debug("[STR] Combo offensive complete. Remaining TP: " + player._currTp + ", MP: " + player._currMp)
            return  
        }

        var bestWeaponCell = -1
        var bestWeaponDamage = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in fieldMap.damageMap) {
            if (c._highestDamageWeapon == -1) continue
            var dist = getCachedPathLength(playerPos, c._id)
            if (dist == null) continue
            
            if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                bestWeaponDamage = c._weaponDamage
                bestWeaponCell = c
                bestDist = dist
            }
        }
        
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) bestWeaponCell = targetHitCell
        if (bestWeaponCell == -1) {
            debug("[STR] No weapon cell found; falling back to base logic")
            return super.createOffensiveScenario(target, targetHitCell)
        }

        var playerMP = player._currMp
        var playerTP = player._currTp
        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [], "STR", false)

        debug("[STR] Offensive scenario complete. Remaining TP: " + result['playerTP'] + ", MP: " + result['playerMP'])
    }

}
