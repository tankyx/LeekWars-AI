include('action.lk')
include('base_strategy.lk')

class StrengthStrategy extends Strategy {
    constructor() {
        super()
    }

    createOTKOScenario(target, targetHitCell) {
        // Check if CHIP_TELEPORTATION is equipped
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            debug("[OTKO] Teleportation not equipped")
            return false
        }

        // Check cooldown (0 = available)
        var cooldown = getCooldown(CHIP_TELEPORTATION, getEntity())
        if (cooldown > 0) {
            debug("[OTKO] Teleportation on cooldown: " + cooldown + " turns")
            return false
        }

        // Check minimum TP budget (9 for teleport + weapon costs)
        var playerTP = player._currTp
        if (playerTP < 15) {  // 9 + minimum 6 TP for one weapon use
            debug("[OTKO] Insufficient TP for teleport OTKO: " + playerTP)
            return false
        }

        // Find optimal teleport cell
        var teleportInfo = fieldMap.findOptimalTeleportCell(target)
        if (teleportInfo == null) {
            debug("[OTKO] No valid teleport cells found")
            return false
        }

        // Only proceed if we can guarantee the kill
        if (!teleportInfo['canKill']) {
            debug("[OTKO] Projected damage insufficient for kill: " + teleportInfo['damage'] + " vs " + target._currHealth + " HP")
            return false
        }

        var teleCell = teleportInfo['cell']
        debug("[OTKO] Executing teleport OTKO to cell " + teleCell + " projected damage: " + teleportInfo['damage'])

        // Execute teleportation
        this.createAttackAction(Action.ACTION_DIRECT, target, -1, CHIP_TELEPORTATION)
        useChip(CHIP_TELEPORTATION, teleCell)
        playerTP -= 9

        // Update simulated player position
        var playerPos = teleCell

        // Execute weapon attacks from teleport position
        // Build list of usable weapons sorted by shield-adjusted damage
        var weaponDmgList = []
        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            // Check if weapon can hit target from teleport cell
            var distToTarget = getCellDistance(teleCell, target._cellPos)
            if (distToTarget == null) continue
            if (distToTarget < wObj._minRange || distToTarget > wObj._maxRange) continue
            if (!lineOfSight(teleCell, target._cellPos)) continue

            var netDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, wid, target)
            push(weaponDmgList, ['weapon': wObj, 'netDmg': netDmg])
        }

        // Sort by descending net damage (selection sort)
        for (var i = 0; i < count(weaponDmgList); i++) {
            var bestIdx = i
            for (var j = i + 1; j < count(weaponDmgList); j++) {
                if (weaponDmgList[j]['netDmg'] > weaponDmgList[bestIdx]['netDmg']) bestIdx = j
            }
            if (bestIdx != i) {
                var tmp = weaponDmgList[i]
                weaponDmgList[i] = weaponDmgList[bestIdx]
                weaponDmgList[bestIdx] = tmp
            }
        }

        // Execute weapons in order of net damage
        for (var wi = 0; wi < count(weaponDmgList); wi++) {
            var wRec = weaponDmgList[wi]
            var wObj = wRec['weapon']

            // Swap weapon if needed
            if (getWeapon() != wObj._id) {
                if (playerTP >= 1 + wObj._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                } else {
                    continue  // Not enough TP to swap and use
                }
            }

            // Use weapon maximum times
            var uses = min(wObj._maxUse, floor(playerTP / wObj._cost))
            while (uses > 0 && playerTP >= wObj._cost) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses -= 1
            }

            if (playerTP <= 0) break
        }

        // Use damage chips with remaining TP
        if (playerTP > 0) {
            var chipDmgList = []
            for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                if (cid == CHIP_TELEPORTATION) continue

                // Filter attack chips
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                // Check range and LOS from teleport cell
                var distChip = getCellDistance(teleCell, target._cellPos)
                if (distChip == null) continue
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(teleCell, target._cellPos)) continue

                var netChipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, cid, target)
                push(chipDmgList, ['chip': chipObj, 'netDmg': netChipDmg])
            }

            // Sort chips by net damage
            for (var ci = 0; ci < count(chipDmgList); ci++) {
                var bestCIdx = ci
                for (var cj = ci + 1; cj < count(chipDmgList); cj++) {
                    if (chipDmgList[cj]['netDmg'] > chipDmgList[bestCIdx]['netDmg']) bestCIdx = cj
                }
                if (bestCIdx != ci) {
                    var tmpC = chipDmgList[ci]
                    chipDmgList[ci] = chipDmgList[bestCIdx]
                    chipDmgList[bestCIdx] = tmpC
                }
            }

            // Execute chips
            for (var chipIdx = 0; chipIdx < count(chipDmgList); chipIdx++) {
                var cRec = chipDmgList[chipIdx]
                var chipUse = cRec['chip']
                if (playerTP < chipUse._cost) continue
                var usesC = min(chipUse._maxUse, floor(playerTP / chipUse._cost))
                while (usesC > 0 && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    usesC -= 1
                }
                if (playerTP <= 0) break
            }
        }

        debug("[OTKO] OTKO scenario complete, remaining TP: " + playerTP)
        return true
    }

    // Override offensive scenario for Strength builds: always prioritize weapons (highest weapon damage cell)
    // Only after exhausting primary + secondary weapons do we spend leftover TP on damage chips (sorted by per-use damage desc).
    createOffensiveScenario(target, targetHitCell) {
        // Check for OTKO opportunity first (low HP enemies)
        var hpThreshold = min(target._maxHealth * 0.35, 500)  // 35% HP or 500 HP, whichever is lower
        if (target._currHealth <= hpThreshold) {
            debug("[STR] Enemy HP below OTKO threshold: " + target._currHealth + " <= " + hpThreshold)
            var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
            if (otkoExecuted) {
                debug("[STR] OTKO scenario executed successfully")
                return  // OTKO actions planned, skip normal offensive logic
            }
            debug("[STR] OTKO not viable, falling back to normal offensive scenario")
        }

        // Re-compute best pure weapon cell ignoring chip-only high damage cells.
        var bestWeaponCell = -1
        var bestWeaponDamage = -1
        var bestDist = 99999
        var playerPos = player._cellPos
        for (var c in fieldMap.damageMap) {
            if (c._highestDamageWeapon == -1) continue
            var dist = getPathLength(playerPos, c._id)
            if (dist == null) continue
            // Prefer higher weaponDamage, tie-break shorter distance
            if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                bestWeaponDamage = c._weaponDamage
                bestWeaponCell = c
                bestDist = dist
            }
        }
        // Fallback to incoming targetHitCell if no weapon cell found (should be rare)
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) bestWeaponCell = targetHitCell
        if (bestWeaponCell == -1) {
            debug("[STR] No weapon cell found; falling back to base logic")
            return super.createOffensiveScenario(target, targetHitCell)
        }

        // Optional: consider approach hide cell if it allows attack with same weaponDamage and is closer.
        var hnsApproach = fieldMap.findApproachHideAndSeekCell(target)
        if (hnsApproach != null && hnsApproach['canAttack'] && mapContainsKey(fieldMap.damageMap, hnsApproach['cell'])) {
            var hCellObj = fieldMap.damageMap[hnsApproach['cell']]
            if (hCellObj._highestDamageWeapon != -1) {
                var distOrig = getPathLength(playerPos, bestWeaponCell._id)
                var distH = getPathLength(playerPos, hCellObj._id)
                if (distH != null && distOrig != null && hCellObj._weaponDamage >= bestWeaponCell._weaponDamage && distH < distOrig) {
                    debug("[STR][HNS-APPROACH] Switching weapon cell to safer/closer cell " + hCellObj._id)
                    bestWeaponCell = hCellObj
                }
            }
        }

        var pathLen = getPathLength(playerPos, bestWeaponCell._id)
        var playerMP = player._currMp
        var playerTP = player._currTp

        if (pathLen == null) pathLen = 99999
        if (pathLen > playerMP) {
            // Move as close as possible (reuse generic approach movement)
            this.createMovementAction(Action.MOVEMENT_APPROACH, bestWeaponCell._id, target)
            debug("[STR] Approaching weapon cell (unreachable this turn) cell=" + bestWeaponCell._id)
            // No attacks (can't reach) stop here.
            return
        }

        if (pathLen > 0) {
            this.createMovementAction(Action.MOVEMENT_OFFENSIVE, bestWeaponCell._id, target)
            playerMP -= pathLen
            playerPos = bestWeaponCell._id
        } else {
            debug("[STR] Already on best weapon cell " + bestWeaponCell._id)
        }

        // Primary weapon usage
        var primaryWeapon = bestWeaponCell._highestDamageWeapon
        if (primaryWeapon != -1 && primaryWeapon != null) {
            if (getWeapon() != primaryWeapon._id) {
                if (playerTP >= 1 + primaryWeapon._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, primaryWeapon._id, -1)
                    playerTP -= 1
                } else {
                    debug("[STR] Not enough TP to swap and use primary weapon " + getWeaponName(primaryWeapon._id))
                }
            }
            var uses = primaryWeapon._maxUse
            while (playerTP >= primaryWeapon._cost && uses > 0) {
                this.createAttackAction(Action.ACTION_DIRECT, target, primaryWeapon._id, -1)
                playerTP -= primaryWeapon._cost
                uses -= 1
            }
        }

        // Secondary weapons (similar to base but after primary only)
        var primaryWid = (primaryWeapon != -1 && primaryWeapon != null) ? primaryWeapon._id : -1
        var weaponIds = mapKeys(arsenal.playerEquippedWeapons)
        for (var wi = 0; wi < count(weaponIds); wi++) {
            var wid = weaponIds[wi]
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue
            if (wObj._id == primaryWid) continue
            if (playerTP < wObj._cost + 1) continue // need swap + one use
            // Check if we already are on a valid cell for this weapon; if not and have MP remaining we can attempt moving (but we already moved). Skip extra movement for simplicity.
            // Just fire if current cell allows; else attempt to find closest cell within remaining MP.
            var curCellObj = null
            if (mapContainsKey(fieldMap.damageMap, playerPos)) curCellObj = fieldMap.damageMap[playerPos]
            var canFireHere = false
            if (curCellObj != null) {
                for (var wL = 0; wL < count(curCellObj._weaponsList); wL++) { if (curCellObj._weaponsList[wL]._id == wObj._id) { canFireHere = true; break } }
            }
            if (!canFireHere) continue
            this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
            playerTP -= 1
            var uses2 = wObj._maxUse
            while (playerTP >= wObj._cost && uses2 > 0) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses2 -= 1
            }
        }

        // Finally: spend leftover TP on damage/poison chips sorted by per-use total damage (descending)
        if (playerTP > 0) {
            var dmgChips = []
            var chipIds = mapKeys(arsenal.playerEquippedChips)
            for (var ci = 0; ci < count(chipIds); ci++) {
                var cid = chipIds[ci]
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                // Filter attack chips (damage or poison effects)
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue
                // Range & LOS from bestWeaponCell (current position)
                var distChip = getCellDistance(bestWeaponCell._id, target._cellPos)
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(bestWeaponCell._id, target._cellPos)) continue
                var bd = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, chipObj._id)
                push(dmgChips, ['chip': chipObj, 'per': bd['total']])
            }
            // Selection sort descending by per-use total
            for (var i = 0; i < count(dmgChips); i++) {
                var bestIdx = i
                for (var j = i + 1; j < count(dmgChips); j++) { if (dmgChips[j]['per'] > dmgChips[bestIdx]['per']) bestIdx = j }
                if (bestIdx != i) { var tmp = dmgChips[i]; dmgChips[i] = dmgChips[bestIdx]; dmgChips[bestIdx] = tmp }
            }
            for (var dc = 0; dc < count(dmgChips); dc++) {
                var rec = dmgChips[dc]
                var chipUse = rec['chip']
                if (playerTP < chipUse._cost) continue
                var usesC = min(chipUse._maxUse, floor(playerTP / chipUse._cost))
                while (usesC > 0 && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    usesC -= 1
                }
                if (playerTP <= 0) break
            }
        }

        // Post-offensive HNS relocation (reuse base logic portion)
        if (playerMP > 0) {
            var hnsInfo = fieldMap.findHideAndSeekCell()
            if (hnsInfo != null) {
                var hideCellId = hnsInfo['cell']
                if (hideCellId != bestWeaponCell._id) {
                    var legLen = getPathLength(bestWeaponCell._id, hideCellId)
                    if (legLen != null && legLen <= playerMP) {
                        debug("[STR][HNS] Adding hide move to cell " + hideCellId + " danger=" + hnsInfo['danger'])
                        this.createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
                        playerMP -= legLen
                    }
                }
            }
        }
    }

}
