include('action.lk')
include('base_strategy.lk')

// Boss Fight Strategy for Roi Fenouil
// Handles two-phase boss fight: puzzle phase (crystal alignment) + combat phase
// Team composition: 3 puzzle solvers + 1 combat specialist
class BossFightStrategy extends Strategy {
    getStrategyName() {
        return "BOSS"
    }

    // Team coordination (static - shared across all leeks in fight)
    static _roleAssignments = [:]  // Map: entityId → role string
    static _solverCount = 0        // Number of solvers assigned
    static _crystalAssignments = [:] // Map: crystalColor → solverId

    constructor() {
        super()
    }

    // Disable damage map building in boss fights (performance + irrelevant for puzzle solving)
    shouldBuildDamageMap() {
        return false
    }

    // ============================================================
    // ENTITY DETECTION SYSTEM
    // ============================================================

    // Detect if this is a boss fight (Grail present)
    static detectBossFight() {
        var entityIds = mapKeys(fieldMap.entities)
        for (var e in entityIds) {
            if (getName(e) == 'graal') {
                return true
            }
        }
        return false
    }

    // Find Grail entity
    findGrailEntity() {
        var entityIds = mapKeys(fieldMap.entities)
        for (var e in entityIds) {
            if (getName(e) == 'graal') {
                return e
            }
        }
        return null
    }

    // Find all crystal entities
    findCrystalEntities() {
        var crystals = []
        var entityIds = mapKeys(fieldMap.entities)

        for (var e in entityIds) {
            var name = getName(e)

            if (name == 'red_crystal') {
                push(crystals, {
                    id: e,
                    color: 'red',
                    position: getCell(e)
                })
            } else if (name == 'blue_crystal') {
                push(crystals, {
                    id: e,
                    color: 'blue',
                    position: getCell(e)
                })
            } else if (name == 'yellow_crystal') {
                push(crystals, {
                    id: e,
                    color: 'yellow',
                    position: getCell(e)
                })
            } else if (name == 'green_crystal') {
                push(crystals, {
                    id: e,
                    color: 'green',
                    position: getCell(e)
                })
            }
        }

        return crystals
    }

    // ============================================================
    // ALIGNMENT VALIDATION
    // ============================================================

    // Check if a crystal is correctly aligned to project its ray onto the Grail
    // Red: North ray → crystal must be SOUTH of grail (below, same X)
    // Blue: West ray → crystal must be EAST of grail (right, same Y)
    // Yellow: East ray → crystal must be WEST of grail (left, same Y)
    // Green: South ray → crystal must be NORTH of grail (above, same X)
    checkCrystalAlignment(crystalColor, crystalPos, grailPos) {
        var grailX = getCellX(grailPos)
        var grailY = getCellY(grailPos)
        var crystalX = getCellX(crystalPos)
        var crystalY = getCellY(crystalPos)

        if (crystalColor == 'red') {
            // Red: North ray → must be SOUTH of grail
            return crystalX == grailX && crystalY < grailY
        } else if (crystalColor == 'blue') {
            // Blue: West ray → must be EAST of grail
            return crystalY == grailY && crystalX > grailX
        } else if (crystalColor == 'yellow') {
            // Yellow: East ray → must be WEST of grail
            return crystalY == grailY && crystalX < grailX
        } else if (crystalColor == 'green') {
            // Green: South ray → must be NORTH of grail
            return crystalX == grailX && crystalY > grailY
        }

        return false
    }

    // Check if all crystals are aligned (puzzle complete)
    areAllCrystalsAligned() {
        var grail = this.findGrailEntity()
        if (grail == null) {
            return true  // Grail destroyed, puzzle complete
        }

        var grailPos = getCell(grail)
        var crystals = this.findCrystalEntities()

        for (var crystal in crystals) {
            if (!this.checkCrystalAlignment(crystal.color, crystal.position, grailPos)) {
                return false  // At least one crystal misaligned
            }
        }

        return true  // All 4 crystals aligned
    }

    // ============================================================
    // TARGET POSITION CALCULATOR
    // ============================================================

    // Calculate target position for crystal alignment
    calculateCrystalTargetPosition(crystalColor, grailPos) {
        var grailX = getCellX(grailPos)
        var grailY = getCellY(grailPos)

        var targetX = grailX
        var targetY = grailY

        // Try distance 3 first, then 2, then 1 as fallback
        var distances = [3, 2, 1]

        for (var dist in distances) {
            if (crystalColor == 'red') {
                // Red: Below grail (same X, Y - N)
                targetX = grailX
                targetY = grailY - dist
            } else if (crystalColor == 'blue') {
                // Blue: Right of grail (X + N, same Y)
                targetX = grailX + dist
                targetY = grailY
            } else if (crystalColor == 'yellow') {
                // Yellow: Left of grail (X - N, same Y)
                targetX = grailX - dist
                targetY = grailY
            } else if (crystalColor == 'green') {
                // Green: Above grail (same X, Y + N)
                targetX = grailX
                targetY = grailY + dist
            }

            var targetCell = getCellFromXY(targetX, targetY)

            // Validate cell exists and is walkable
            if (targetCell != null && (isEmptyCell(targetCell) || !isObstacle(targetCell))) {
                return targetCell
            }
        }

        // Fallback: return grail position (should never happen)
        return grailPos
    }

    // Visualize crystal movement path by marking cells with crystal color
    visualizeCrystalPath(crystalColor, crystalPos, targetPos) {
        // LeekScript mark color constants: RED=0, BLUE=1, GREEN=2, YELLOW=3
        var markColor = 0  // Default red
        if (crystalColor == 'red') markColor = 0
        else if (crystalColor == 'blue') markColor = 1
        else if (crystalColor == 'green') markColor = 2
        else if (crystalColor == 'yellow') markColor = 3

        // Get path from crystal to target
        var path = getPath(crystalPos, targetPos)

        if (path == null || count(path) == 0) {
            debug("[VIZ] No path from " + crystalPos + " to " + targetPos)
            return
        }

        // Mark all cells along the path with crystal color
        for (var i = 0; i < count(path); i++) {
            mark(path[i], markColor)
        }

        debug("[VIZ] Marked " + count(path) + " cells " + crystalColor + " (crystal→target path)")
    }

    // ============================================================
    // TEAM COORDINATION
    // ============================================================

    // Assign team role (3 solvers + 1 combat specialist)
    assignTeamRole() {
        var myId = getEntity()

        // Check if I already have an assigned role
        if (BossFightStrategy._roleAssignments[myId] != null) {
            return BossFightStrategy._roleAssignments[myId]
        }

        // Get my stats and equipment
        var hasGrapple = mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE)
        var hasBoxingGlove = mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)
        var mySTR = getStrength()
        var myWIS = getWisdom()
        var myAGI = getAgility()

        // Check if I'm a combat build (STR or WIS dominant)
        var isCombatBuild = (mySTR > myAGI && mySTR > myWIS) ||
                            (myWIS > myAGI && myWIS > mySTR)

        // Assign combat specialist (1 max)
        if (isCombatBuild && BossFightStrategy._solverCount >= 3) {
            BossFightStrategy._roleAssignments[myId] = "COMBAT_SPECIALIST"
            debug("Assigned as COMBAT_SPECIALIST (staying back for Phase 2)")
            return "COMBAT_SPECIALIST"
        }

        // Assign puzzle solver (3 max, requires both chips)
        if (hasGrapple && hasBoxingGlove && BossFightStrategy._solverCount < 3) {
            BossFightStrategy._solverCount++
            BossFightStrategy._roleAssignments[myId] = "PUZZLE_SOLVER"
            debug("Assigned as PUZZLE_SOLVER #" + BossFightStrategy._solverCount)
            return "PUZZLE_SOLVER"
        }

        // Fallback: become solver if slots available
        if (BossFightStrategy._solverCount < 3) {
            BossFightStrategy._solverCount++
            BossFightStrategy._roleAssignments[myId] = "PUZZLE_SOLVER"
            debug("Assigned as PUZZLE_SOLVER (fallback, missing chips)")
            return "PUZZLE_SOLVER"
        }

        // Last resort: combat specialist
        BossFightStrategy._roleAssignments[myId] = "COMBAT_SPECIALIST"
        debug("Assigned as COMBAT_SPECIALIST (fallback)")
        return "COMBAT_SPECIALIST"
    }

    // Assign crystal tasks using relative turn order among allies
    assignCrystalTasks() {
        var myId = getEntity()
        var grail = this.findGrailEntity()

        if (grail == null) {
            return null  // No grail, puzzle complete
        }

        var grailPos = getCell(grail)
        var crystals = this.findCrystalEntities()

        // Get all ally entities and sort by turn order
        var allAllies = getAllies()
        var alliesWithOrder = []

        for (var ally in allAllies) {
            var turnOrder = getEntityTurnOrder(ally)
            push(alliesWithOrder, ['id': ally, 'order': turnOrder])
        }

        // Sort allies by turn order (bubble sort since no built-in sort)
        for (var i = 0; i < count(alliesWithOrder); i++) {
            for (var j = i + 1; j < count(alliesWithOrder); j++) {
                if (alliesWithOrder[j]['order'] < alliesWithOrder[i]['order']) {
                    var temp = alliesWithOrder[i]
                    alliesWithOrder[i] = alliesWithOrder[j]
                    alliesWithOrder[j] = temp
                }
            }
        }

        // Find my position in sorted list (0-based index)
        var myPosition = -1
        for (var i = 0; i < count(alliesWithOrder); i++) {
            if (alliesWithOrder[i]['id'] == myId) {
                myPosition = i
                break
            }
        }

        if (myPosition == -1) {
            debug("ERROR: Could not find my position in ally list")
            return null
        }

        // Assign crystal based on position: 0→red, 1→blue, 2→yellow, 3→green
        // Wrap around for 5+ allies
        var colorsByPosition = ['red', 'blue', 'yellow', 'green']
        var colorIndex = myPosition % 4
        var assignedColor = colorsByPosition[colorIndex]

        debug("Ally position " + myPosition + " (of " + count(alliesWithOrder) + ") → " + assignedColor + " crystal")

        // Check if this crystal still needs alignment
        for (var crystal in crystals) {
            if (crystal.color == assignedColor) {
                // Check if already aligned
                if (this.checkCrystalAlignment(crystal.color, crystal.position, grailPos)) {
                    debug(assignedColor + " crystal already aligned, nothing to do")
                    return null
                }

                debug("Assigned " + assignedColor + " crystal")
                return assignedColor
            }
        }

        debug("ERROR: Crystal " + assignedColor + " not found")
        return null
    }

    // ============================================================
    // POSITIONING HELPERS
    // ============================================================

    // Calculate which direction to push crystal (returns direction vector)
    calculatePushDirection(crystalPos, targetPos) {
        var crystalX = getCellX(crystalPos)
        var crystalY = getCellY(crystalPos)
        var targetX = getCellX(targetPos)
        var targetY = getCellY(targetPos)

        // Calculate normalized direction (-1, 0, or 1 for each axis)
        var dirX = 0
        var dirY = 0

        if (targetX > crystalX) dirX = 1
        else if (targetX < crystalX) dirX = -1

        if (targetY > crystalY) dirY = 1
        else if (targetY < crystalY) dirY = -1

        return ['dirX': dirX, 'dirY': dirY]
    }

    // Find best cell to push crystal toward target
    // Returns cell on opposite side of crystal from target
    findPushPosition(crystalPos, targetPos) {
        var dir = this.calculatePushDirection(crystalPos, targetPos)
        var crystalX = getCellX(crystalPos)
        var crystalY = getCellY(crystalPos)

        // Try cells on opposite side of crystal from target
        // If target is NORTH (dirY=1), we want to be SOUTH (dirY=-1)
        var pushFromX = crystalX - dir['dirX']
        var pushFromY = crystalY - dir['dirY']

        // Generate candidate cells (direct opposite + diagonals)
        var candidates = []

        // Direct opposite (best)
        var directCell = getCellFromXY(pushFromX, pushFromY)
        if (directCell != null) push(candidates, directCell)

        // Diagonal alternatives if direct is blocked
        if (dir['dirX'] != 0 && dir['dirY'] != 0) {
            // Moving diagonally, try horizontal or vertical alternatives
            var hCell = getCellFromXY(pushFromX, crystalY)
            var vCell = getCellFromXY(crystalX, pushFromY)
            if (hCell != null) push(candidates, hCell)
            if (vCell != null) push(candidates, vCell)
        }

        // Check candidates for empty cells
        for (var cell in candidates) {
            if (isEmptyCell(cell)) {
                return cell
            }
        }

        return null
    }

    // Find optimal position to use GRAPPLE/BOXING_GLOVE on crystal
    // targetCell is where we want the crystal to end up
    // Find safest cell (maximum distance from all entities)
    findSafestCell(myPos, entityIds) {
        var accessibleCells = fieldMap.getAccessibleCells(player)
        var bestCell = null
        var bestScore = -999

        for (var cell in accessibleCells) {
            var minDist = 999

            // Find minimum distance to any entity
            for (var e in entityIds) {
                var entityCell = getCell(e)
                if (entityCell != null) {
                    var dist = getCellDistance(cell, entityCell)
                    if (dist < minDist) {
                        minDist = dist
                    }
                }
            }

            // Higher score = farther from all entities
            if (minDist > bestScore) {
                bestScore = minDist
                bestCell = cell
            }
        }

        return bestCell
    }

    // Get all empty cells on crystal's horizontal or vertical axis
    getCellsOnAxis(crystalPos, axisType) {
        var cells = []
        var crystalX = getCellX(crystalPos)
        var crystalY = getCellY(crystalPos)

        if (axisType == "VERTICAL") {
            // All cells with same X coordinate (vertical line)
            for (var y = -17; y <= 17; y++) {
                var cell = getCellFromXY(crystalX, y)
                if (cell != null && cell != crystalPos && isEmptyCell(cell)) {
                    push(cells, cell)
                }
            }
        } else {
            // All cells with same Y coordinate (horizontal line)
            for (var x = -17; x <= 17; x++) {
                var cell = getCellFromXY(x, crystalY)
                if (cell != null && cell != crystalPos && isEmptyCell(cell)) {
                    push(cells, cell)
                }
            }
        }

        return cells
    }

    // Find reachable cell on axis within chip range
    findReachableCellOnAxis(crystalPos, axisType, minRange, maxRange) {
        var axisCells = this.getCellsOnAxis(crystalPos, axisType)
        var accessible = fieldMap.getAccessibleCells(player)
        var myPos = getCell()

        var bestCell = null
        var bestDist = 999

        for (var cell in axisCells) {
            // Check if reachable
            var isReachable = false
            for (var acc in accessible) {
                if (acc == cell) {
                    isReachable = true
                    break
                }
            }

            if (!isReachable) continue

            // Check if in chip range from crystal
            var distToCrystal = getCellDistance(cell, crystalPos)
            if (distToCrystal < minRange || distToCrystal > maxRange) continue

            // Find closest to player
            var distToPlayer = getCellDistance(myPos, cell)
            if (distToPlayer < bestDist) {
                bestDist = distToPlayer
                bestCell = cell
            }
        }

        return bestCell
    }

    // Move toward axis line (reduce X or Y distance, not point distance)
    moveTowardAxis(crystalPos, axisType) {
        var accessible = fieldMap.getAccessibleCells(player)
        var myPos = getCell()

        if (axisType == "VERTICAL") {
            // Need to reach X = crystalX
            var targetX = getCellX(crystalPos)
            var currentX = getCellX(myPos)

            var bestCell = null
            var bestXDist = abs(currentX - targetX)

            for (var cell in accessible) {
                var cellX = getCellX(cell)
                var xDist = abs(cellX - targetX)

                // Closer to target X coordinate?
                if (xDist < bestXDist) {
                    bestXDist = xDist
                    bestCell = cell
                }
            }

            if (bestCell != null) {
                debug("Moving toward vertical axis X=" + targetX + " (current X=" + currentX + ")")
                this.createMovementAction(Action.MOVEMENT_APPROACH, bestCell, null)
                return true
            }
        } else {
            // Need to reach Y = crystalY
            var targetY = getCellY(crystalPos)
            var currentY = getCellY(myPos)

            var bestCell = null
            var bestYDist = abs(currentY - targetY)

            for (var cell in accessible) {
                var cellY = getCellY(cell)
                var yDist = abs(cellY - targetY)

                // Closer to target Y coordinate?
                if (yDist < bestYDist) {
                    bestYDist = yDist
                    bestCell = cell
                }
            }

            if (bestCell != null) {
                debug("Moving toward horizontal axis Y=" + targetY + " (current Y=" + currentY + ")")
                this.createMovementAction(Action.MOVEMENT_APPROACH, bestCell, null)
                return true
            }
        }

        debug("No accessible cells to move toward axis")
        return false
    }

    // Determine which axis alignment is needed (vertical or horizontal)
    determineAxisType(crystalColor, grailPos) {
        // Red: South of grail (vertical, below)
        // Green: North of grail (vertical, above)
        // Blue: East of grail (horizontal, right)
        // Yellow: West of grail (horizontal, left)

        if (crystalColor == "red" || crystalColor == "green") {
            return "VERTICAL"
        } else {
            return "HORIZONTAL"
        }
    }

    // Check if INVERSION would be beneficial
    shouldUseInversion(playerPos, crystalPos, targetPos) {
        var playerToTarget = getCellDistance(playerPos, targetPos)
        var crystalToTarget = getCellDistance(crystalPos, targetPos)

        // Player must be significantly closer to target (at least 3 cells)
        // This makes the swap worthwhile
        return playerToTarget < crystalToTarget - 2
    }

    // ============================================================
    // SCENARIO IMPLEMENTATIONS
    // ============================================================

    // Puzzle solver scenario (move crystals to alignment)
    createPuzzleSolvingScenario(target) {
        // Use game's actual turn number for INVERSION availability
        var gameTurn = getTurn()
        debug("=== PUZZLE SOLVER TURN " + gameTurn + " ===")
        debug("INVERSION available: " + (gameTurn % 2 == 0))

        // DEBUG: Show equipped chips and current resources
        var hasGrapple = mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE)
        var hasBoxing = mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)
        var hasInversion = mapContainsKey(arsenal.playerEquippedChips, CHIP_INVERSION)
        var hasTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)
        debug("[CHIPS] GRAPPLE=" + hasGrapple + " BOXING=" + hasBoxing + " INVERSION=" + hasInversion + " TELEPORT=" + hasTeleport)
        debug("[RESOURCES] TP=" + getTP() + " MP=" + getMP())

        var grail = this.findGrailEntity()

        if (grail == null) {
            debug("Grail destroyed, puzzle complete!")
            return
        }

        var grailPos = getCell(grail)
        var grailX = getCellX(grailPos)
        var grailY = getCellY(grailPos)

        // Show grail and all crystal positions (once per puzzle start)
        var crystals = this.findCrystalEntities()
        debug("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        debug("GRAIL: cell=" + grailPos + " (" + grailX + "," + grailY + ")")
        debug("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

        for (var c in crystals) {
            var targetCell = this.calculateCrystalTargetPosition(c.color, grailPos)
            var dist = getCellDistance(c.position, targetCell)
            var aligned = this.checkCrystalAlignment(c.color, c.position, grailPos)
            var status = aligned ? "✅ ALIGNED" : ("❌ " + dist + " cells away")

            debug(c.color + " crystal: current=" + c.position + " → target=" + targetCell + " " + status)
        }
        debug("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

        // Check alignment status
        if (this.areAllCrystalsAligned()) {
            debug("All crystals aligned! Waiting for Grail self-destruct...")
            // Move to safe position
            var safeCell = fieldMap.findHideAndSeekCell("defensive", null)
            if (safeCell != null && safeCell != -1) {
                this.createMovementAction(Action.MOVEMENT_HNS, safeCell, target)
            }
            return
        }

        // Get my assigned crystal
        var myColor = this.assignCrystalTasks()

        if (myColor == null) {
            debug("No crystal available to work on")
            // All crystals claimed by other solvers, stay back
            return
        }

        // Find my crystal entity
        var myCrystal = null
        for (var c in crystals) {
            if (c.color == myColor) {
                myCrystal = c
                break
            }
        }

        if (myCrystal == null) {
            debug("ERROR: Assigned crystal not found")
            return
        }

        debug("Working on " + myColor + " crystal: current=" + myCrystal.position + ", target=" + this.calculateCrystalTargetPosition(myCrystal.color, grailPos))

        // Check if already aligned
        if (this.checkCrystalAlignment(myCrystal.color, myCrystal.position, grailPos)) {
            debug(myColor + " crystal already aligned!")
            // Release assignment, allow reclaiming
            BossFightStrategy._crystalAssignments[myColor] = null
            return
        }

        // Calculate target position
        var targetCell = this.calculateCrystalTargetPosition(myCrystal.color, grailPos)

        // Visualize THIS crystal's path (each leek marks their own crystal)
        this.visualizeCrystalPath(myCrystal.color, myCrystal.position, targetCell)

        // CHIP-BASED CRYSTAL MOVEMENT STRATEGY
        // Use GRAPPLE (pull) and BOXING_GLOVE (push) with correct cell targeting
        var playerPos = getCell()
        var crystalPos = myCrystal.position
        var distToCrystal = getCellDistance(playerPos, crystalPos)
        var crystalToTarget = getCellDistance(crystalPos, targetCell)
        var axisType = this.determineAxisType(myCrystal.color, grailPos)

        debug("Player at " + playerPos + ", crystal at " + crystalPos + ", target at " + targetCell)
        debug("Distance to crystal: " + distToCrystal + ", crystal to target: " + crystalToTarget + " cells")
        debug("Axis type: " + axisType)

        // Check if we're on the same axis (horizontal or vertical) as crystal
        var playerX = getCellX(playerPos)
        var playerY = getCellY(playerPos)
        var crystalX = getCellX(crystalPos)
        var crystalY = getCellY(crystalPos)
        var onAxis = (playerX == crystalX) || (playerY == crystalY)

        debug("On axis with crystal: " + onAxis + " (playerX=" + playerX + " crystalX=" + crystalX + " playerY=" + playerY + " crystalY=" + crystalY + ")")

        // STRATEGY: If on axis and in range (1-8), use GRAPPLE or BOXING_GLOVE
        // Both chips aim at TARGET CELL (where we want crystal to end up)
        if (onAxis && distToCrystal >= 1 && distToCrystal <= 8) {
            // Determine if we should PULL (GRAPPLE) or PUSH (BOXING_GLOVE)
            // GRAPPLE works when we're PAST the target (farther from target than crystal)
            // BOXING_GLOVE works when we're closer to crystal (before or same side)
            var playerToTarget = getCellDistance(playerPos, targetCell)
            var shouldPull = playerToTarget > crystalToTarget  // We're farther from target than crystal

            debug("On axis and in range! shouldPull=" + shouldPull + " (playerToTarget=" + playerToTarget + " crystalToTarget=" + crystalToTarget + ")")

            if (shouldPull && hasGrapple) {
                // GRAPPLE: Pull crystal adjacent to player on the line toward target
                // We want to pull crystal closer to its target position
                // Calculate direction from crystal TO target
                var targetX = getCellX(targetCell)
                var targetY = getCellY(targetCell)
                var dx = targetX - crystalX
                var dy = targetY - crystalY
                if (dx != 0) dx = dx / abs(dx)
                if (dy != 0) dy = dy / abs(dy)

                // Target cell: 1 step from crystal toward target
                var grappleTargetX = crystalX + dx * 1
                var grappleTargetY = crystalY + dy * 1
                var grappleCell = getCellFromXY(grappleTargetX, grappleTargetY)

                // Validate: must be empty and not player position
                if (grappleCell == null || !isEmptyCell(grappleCell) || grappleCell == playerPos) {
                    debug("GRAPPLE target cell invalid (occupied or null): " + grappleCell)
                    grappleCell = null
                }

                var grappleCD = getCooldown(CHIP_GRAPPLE, getEntity())
                if (grappleCell != null && grappleCD == 0 && getTP() >= 3) {
                    debug("✅ Using GRAPPLE - pulling crystal toward target cell " + grappleCell + " (1 step closer)")
                    var result = useChipOnCell(CHIP_GRAPPLE, grappleCell)
                    debug("GRAPPLE result: " + result)
                    return
                } else {
                    if (grappleCell == null) {
                        debug("GRAPPLE skipped - no valid target cell")
                    } else {
                        debug("GRAPPLE not ready (CD=" + grappleCD + " TP=" + getTP() + ")")
                    }
                }
            } else if (!shouldPull && hasBoxing) {
                // BOXING_GLOVE: Push crystal away toward target
                // Calculate direction from player to crystal (push direction)
                var dx = crystalX - playerX
                var dy = crystalY - playerY
                if (dx != 0) dx = dx / abs(dx)
                if (dy != 0) dy = dy / abs(dy)

                // Target cell: crystal position + push direction (pushes away from player)
                // Use distance 1-2 cells beyond crystal
                var boxingTargetX = crystalX + dx * 1
                var boxingTargetY = crystalY + dy * 1
                var boxingCell = getCellFromXY(boxingTargetX, boxingTargetY)

                if (boxingCell == null || !isEmptyCell(boxingCell)) {
                    // Try 2 cells beyond
                    boxingTargetX = crystalX + dx * 2
                    boxingTargetY = crystalY + dy * 2
                    boxingCell = getCellFromXY(boxingTargetX, boxingTargetY)
                }

                var boxingCD = getCooldown(CHIP_BOXING_GLOVE, getEntity())
                if (boxingCD == 0 && getTP() >= 3 && distToCrystal >= 2 && boxingCell != null) {
                    debug("✅ Using BOXING_GLOVE - pushing crystal toward cell " + boxingCell + " (away from player)")
                    var result = useChipOnCell(CHIP_BOXING_GLOVE, boxingCell)
                    debug("BOXING_GLOVE result: " + result)
                    return
                } else {
                    debug("BOXING_GLOVE not ready (CD=" + boxingCD + " TP=" + getTP() + " dist=" + distToCrystal + " validCell=" + (boxingCell != null) + ")")
                }
            }
        }

        // FALLBACK: Move to get on axis with crystal in range 2-7
        debug("Not in position to use chips - repositioning...")

        var accessible = fieldMap.getAccessibleCells(player)
        var bestCell = null
        var bestScore = -999

        // Find best cell that is:
        // 1. On axis with crystal
        // 2. In range 2-7 from crystal
        // 3. Closest to current position
        for (var cell in accessible) {
            var cellX = getCellX(cell)
            var cellY = getCellY(cell)
            var cellDist = getCellDistance(cell, crystalPos)

            var cellOnAxis = (cellX == crystalX) || (cellY == crystalY)

            if (cellOnAxis && cellDist >= 2 && cellDist <= 7) {
                // Prioritize closer distances (less movement)
                var score = 100 - getCellDistance(playerPos, cell)
                if (score > bestScore) {
                    bestScore = score
                    bestCell = cell
                }
            }
        }

        if (bestCell != null) {
            debug("Moving to axis position: " + bestCell + " (will be on axis with crystal)")
            this.createMovementAction(Action.MOVEMENT_APPROACH, bestCell, null)
        } else {
            // Can't reach axis - just move closer to crystal
            debug("Cannot reach axis - moving closer to crystal")
            var closestCell = null
            var closestDist = 999

            for (var cell in accessible) {
                var dist = getCellDistance(cell, crystalPos)
                if (dist < closestDist) {
                    closestDist = dist
                    closestCell = cell
                }
            }

            if (closestCell != null && closestCell != playerPos) {
                debug("Moving closer to crystal: " + closestCell)
                this.createMovementAction(Action.MOVEMENT_APPROACH, closestCell, null)
            }
        }
    }

    // Combat specialist scenario (stay back, conserve TP)
    createCombatSpecialistScenario(target) {
        debug("=== COMBAT SPECIALIST (staying back for Phase 2) ===")

        // Stay far from combat, conserve resources

        // Priority 1: Stay alive (heal if needed)
        if (getLife() < getTotalLife() * 0.5) {
            // Use healing chips
            if (canUseChip(CHIP_CURE, getEntity())) {
                debug("Using CURE (low HP)")
                useChip(CHIP_CURE, getEntity())
            } else if (canUseChip(CHIP_REGENERATION, getEntity())) {
                debug("Using REGENERATION (low HP)")
                useChip(CHIP_REGENERATION, getEntity())
            } else if (canUseChip(CHIP_BANDAGE, getEntity())) {
                debug("Using BANDAGE (low HP)")
                useChip(CHIP_BANDAGE, getEntity())
            }
        }

        // Priority 2: Stay away from all entities (grail, crystals, enemies)
        var allEntityIds = mapKeys(fieldMap.entities)
        var myPos = getCell()

        // Find safest cell (maximum distance from all entities)
        var safeCell = this.findSafestCell(myPos, allEntityIds)

        if (safeCell != null && safeCell != -1 && safeCell != myPos) {
            debug("Moving to safe position: " + safeCell)
            this.createMovementAction(Action.MOVEMENT_HNS, safeCell, target)
        }

        // Priority 3: DO NOT attack (conserve TP for Phase 2)
        // DO NOT use buffs (save TP)
        // Just wait for puzzle completion

        debug("Conserving TP=" + getTP() + " for Phase 2 combat")
    }

    // ============================================================
    // MAIN SCENARIO ROUTER
    // ============================================================

    // Override main scenario execution
    createOffensiveScenario(target, targetHitCell) {
        // Check if Grail still exists
        var grail = this.findGrailEntity()

        if (grail == null) {
            // Phase 2: Grail destroyed, enemies vulnerable
            debug("=== BOSS PHASE 2: COMBAT MODE ===")

            // ALL team members now fight
            // Fall back to build-specific strategies
            return super.createOffensiveScenario(target, targetHitCell)
        }

        // Phase 1: Puzzle solving
        var myRole = this.assignTeamRole()

        if (myRole == "PUZZLE_SOLVER") {
            return this.createPuzzleSolvingScenario(target)
        } else if (myRole == "COMBAT_SPECIALIST") {
            return this.createCombatSpecialistScenario(target)
        }
    }
}
