
include('../game_entity.lk')
include('../field_map_core.lk')

function detectBossFight() {
    var entities = getAliveEnemies()
    for (var eid in entities) {
        var entityType = getName(eid)
        if (entityType == "graal") {
            return true
        }
    }
    return false
}

class BossFightStrategy {

    _grail = null
    _crystals = [:]  
    _myAssignedCrystal = null
    _usedInversion = false
    _fieldMap = null

    constructor() {
        debug("[BOSS] Initializing BossFightStrategy")
        this._fieldMap = new FieldMap()
    }

    shouldBuildDamageMap() {
        return false;  
    }

    createAndExecuteScenario(target, targetHitCell) {
        
        debug("[BOSS] createAndExecuteScenario called")
        this.playTurn()
        debug("[BOSS] playTurn completed")
    }

    playTurn() {
        debug("[BOSS] playTurn START")
        debug("\n[BOSS] ========== TURN " + getTurn() + " ==========")
        debug("[BOSS] MP: " + getMP() + ", TP: " + getTP())

        this.detectGrailAndCrystals()
        debug("[BOSS] Detected grail: " + (this._grail != null))

        var crystalCount = 0
        for (var c in this._crystals) crystalCount++
        debug("[BOSS] Crystal count: " + crystalCount)

        if (this._grail == null) {
            debug("[BOSS] ⚠️ No grail detected, passing turn")
            return
        }

        this.assignCrystal()
        debug("[BOSS] Assigned crystal: " + (this._myAssignedCrystal != null))

        if (this._myAssignedCrystal == null) {
            debug("[BOSS] ⚠️ No crystal assigned, passing turn")
            return
        }

        var solved = this.isCrystalSolved(this._myAssignedCrystal)
        debug("[BOSS] Crystal solved: " + solved)

        if (solved) {
            debug("[BOSS] ✅ My crystal is solved, passing turn")
            return
        }

        debug("[BOSS] Executing action...")
        this.decideAndExecuteAction()

        debug("[BOSS] ========== END TURN ==========\n")
    }

    detectGrailAndCrystals() {
        
        for (var cellId = 0; cellId < 613; cellId++) {
            if (!isEntity(cellId)) continue

            var eid = getEntityOnCell(cellId)
            var entityType = getName(eid)

            if (entityType == "graal") {
                this._grail = {
                    id: eid,
                    cell: cellId,
                    x: getCellX(cellId),
                    y: getCellY(cellId)
                }
                debug("[BOSS] Grail at (" + this._grail.x + ", " + this._grail.y + ")")
            }
            else if (entityType == "red_crystal" || entityType == "blue_crystal" ||
                     entityType == "yellow_crystal" || entityType == "green_crystal") {
                var color = substring(entityType, 0, indexOf(entityType, "_"))
                var goalAxis = this.getGoalAxis(color)

                this._crystals[eid] = {
                    id: eid,
                    color: color,
                    goalAxis: goalAxis,
                    cell: cellId,
                    x: getCellX(cellId),
                    y: getCellY(cellId)
                }

                debug("[BOSS] " + color + " crystal at (" + this._crystals[eid].x + ", " + this._crystals[eid].y + ") [goal: " + goalAxis + "]")
            }
        }
    }

    assignCrystal() {
        
        var myID = getEntity()
        var allAllies = []
        push(allAllies, myID)
        var allies = getAliveAllies()
        for (var aid in allies) {
            push(allAllies, aid)
        }

        sort(allAllies)

        var myIndex = -1
        for (var i = 0; i < count(allAllies); i++) {
            if (allAllies[i] == myID) {
                myIndex = i
                break
            }
        }

        var crystalCount = 0
        for (var c in this._crystals) crystalCount++

        if (myIndex < 0 || myIndex >= crystalCount) {
            debug("[BOSS] ⚠️ Invalid entity index: " + myIndex + " (total allies: " + count(allAllies) + ", crystals: " + crystalCount + ")")
            return
        }

        var colorOrder = ["red", "blue", "yellow", "green"]
        var targetColor = colorOrder[myIndex]

        debug("[BOSS] Looking for " + targetColor + " crystal (myIndex=" + myIndex + ")")

        for (var crystal in this._crystals) {
            debug("[BOSS]   Checking crystal color=" + crystal.color + " vs target=" + targetColor)

            if (crystal != null && crystal.color == targetColor) {
                this._myAssignedCrystal = crystal
                debug("[BOSS] ✅ Assigned to " + targetColor + " crystal (ID=" + crystal.id + ")")
                return
            }
        }

        debug("[BOSS] ⚠️ Could not find " + targetColor + " crystal")
    }

    getGoalAxis(color) {
        if (color == "red") return "south";
        if (color == "blue") return "east";
        if (color == "yellow") return "west";
        if (color == "green") return "north";
        return "unknown";
    }

    isCrystalSolved(crystal) {
        return this.isOnGoalAxis(crystal) && this.hasLOSToGrail(crystal);
    }

    isOnGoalAxis(crystal) {
        if (this._grail == null) return false;

        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north") {
            return cx == gx && cy < gy;
        } else if (axis == "south") {
            return cx == gx && cy > gy;
        } else if (axis == "east") {
            return cy == gy && cx > gx;
        } else if (axis == "west") {
            return cy == gy && cx < gx;
        }

        return false;
    }

    hasLOSToGrail(crystal) {
        if (this._grail == null) return false;
        return lineOfSight(crystal.cell, this._grail.cell);
    }

    getDistanceToAxis(crystal) {
        if (this._grail == null) return 999;

        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north" || axis == "south") {
            return abs(cx - gx);  
        } else {
            return abs(cy - gy);  
        }
    }

    decideAndExecuteAction() {
        var crystal = this._myAssignedCrystal;
        var distToAxis = this.getDistanceToAxis(crystal);

        debug("[BOSS] Crystal distance to axis: " + distToAxis);
        debug("[BOSS] Used INVERSION: " + this._usedInversion);
        debug("[BOSS] Current TP: " + getTP() + ", MP: " + getMP());

        if (distToAxis > 8 && !this._usedInversion && getTP() >= 4) {
            debug("[BOSS] Phase 1: Using INVERSION (distance > 8)");
            this.executeInversion(crystal);
            return;
        }

        debug("[BOSS] Phase 2: Using GRAPPLE/BOXING_GLOVE to slide crystal");
        this.executeSlideTowardGoal(crystal);
    }

    executeInversion(crystal) {
        var playerCell = getCell();
        var dist = getCellDistance(playerCell, crystal.cell);

        debug("[BOSS] Distance to crystal: " + dist);

        if (dist > 14) {
            debug("[BOSS] Walking toward crystal (dist=" + dist + ")");
            var moved = moveTowardCell(crystal.cell, getMP());
            debug("[BOSS] Moved " + moved + " cells");

            playerCell = getCell();
            dist = getCellDistance(playerCell, crystal.cell);

            if (dist > 14) {
                debug("[BOSS] Still out of range after moving, will retry next turn");
                return;
            }
        }

        if (getTP() >= 4 && lineOfSight(playerCell, crystal.cell)) {
            debug("[BOSS] ✅ Using INVERSION on crystal at cell " + crystal.cell);
            var result = useChipOnCell(CHIP_INVERSION, crystal.cell);

            if (result == USE_SUCCESS) {
                this._usedInversion = true;
                debug("[BOSS] ✅ INVERSION successful!");
            } else {
                debug("[BOSS] ⚠️ INVERSION failed: " + result);
            }
        } else {
            debug("[BOSS] ⚠️ Cannot use INVERSION: TP=" + getTP() + ", LOS=" + lineOfSight(playerCell, crystal.cell));
        }
    }

    executeSlideTowardGoal(crystal) {
        var axis = crystal.goalAxis;

        var direction = this.getDirectionToSlide(crystal);

        if (direction == null) {
            debug("[BOSS] ⚠️ No valid slide direction found");
            return;
        }

        debug("[BOSS] Slide direction: " + direction);

        if (direction == "pull") {
            this.executeGrapple(crystal);
        } else {
            this.executeBoxingGlove(crystal);
        }
    }

    getDirectionToSlide(crystal) {
        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north" || axis == "south") {
            
            if (cx < gx) return "pull";  
            if (cx > gx) return "push";  

            if (axis == "north" && cy >= gy) return "push";  
            if (axis == "south" && cy <= gy) return "pull";  
        } else {
            
            if (cy < gy) return "pull";  
            if (cy > gy) return "push";  

            if (axis == "east" && cx <= gx) return "pull";  
            if (axis == "west" && cx >= gx) return "push";  
        }

        return null;
    }

    executeGrapple(crystal) {
        var playerCell = getCell();
        var px = getCellX(playerCell);
        var py = getCellY(playerCell);

        var dx = crystal.x;
        var dy = crystal.y;

        if (crystal.x < px) dx++;
        else if (crystal.x > px) dx--;

        if (crystal.y < py) dy++;
        else if (crystal.y > py) dy--;

        var destCell = getCellFromXY(dx, dy);

        if (destCell == null || !(!isObstacle(destCell) && !isEntity(destCell))) {
            debug("[BOSS] ⚠️ Destination cell blocked or invalid: (" + dx + ", " + dy + ")");
            return;
        }

        var dist = getCellDistance(playerCell, crystal.cell);
        var onSameLine = isOnSameLine(playerCell, crystal.cell);

        debug("[BOSS] GRAPPLE check: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());

        if (dist < 1 || dist > 8 || !onSameLine) {
            debug("[BOSS] Need to position for GRAPPLE");

            var cx = crystal.x;
            var cy = crystal.y;

            var targetCell = getCellFromXY(cx - 4, cy);
            if (targetCell == null || isObstacle(targetCell)) {
                
                targetCell = getCellFromXY(cx, cy - 4);
            }

            if (targetCell != null && !isObstacle(targetCell)) {
                var moved = moveTowardCell(targetCell, getMP());
                debug("[BOSS] Moved " + moved + " cells to align with crystal");

                playerCell = getCell();
                dist = getCellDistance(playerCell, crystal.cell);
                onSameLine = isOnSameLine(playerCell, crystal.cell);
            }
        }

        if (dist >= 1 && dist <= 8 && onSameLine && getTP() >= 4) {
            debug("[BOSS] ✅ Using GRAPPLE to cell " + destCell);
            var result = useChipOnCell(CHIP_GRAPPLE, destCell);

            if (result == USE_SUCCESS) {
                debug("[BOSS] ✅ GRAPPLE successful!");
            } else {
                debug("[BOSS] ⚠️ GRAPPLE failed: " + result);
            }
        } else {
            debug("[BOSS] ⚠️ Cannot use GRAPPLE: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());
        }
    }

    executeBoxingGlove(crystal) {
        var playerCell = getCell();
        var px = getCellX(playerCell);
        var py = getCellY(playerCell);

        var dx = crystal.x;
        var dy = crystal.y;

        if (crystal.x < px) dx--;
        else if (crystal.x > px) dx++;

        if (crystal.y < py) dy--;
        else if (crystal.y > py) dy++;

        var destCell = getCellFromXY(dx, dy);

        if (destCell == null || !(!isObstacle(destCell) && !isEntity(destCell))) {
            debug("[BOSS] ⚠️ Destination cell blocked or invalid: (" + dx + ", " + dy + ")");
            return;
        }

        var dist = getCellDistance(playerCell, crystal.cell);
        var onSameLine = isOnSameLine(playerCell, crystal.cell);

        debug("[BOSS] BOXING_GLOVE check: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());

        if (dist < 2 || dist > 8 || !onSameLine) {
            debug("[BOSS] Need to position for BOXING_GLOVE");

            var cx = crystal.x;
            var cy = crystal.y;

            var targetCell = getCellFromXY(cx + 4, cy);
            if (targetCell == null || isObstacle(targetCell)) {
                
                targetCell = getCellFromXY(cx, cy + 4);
            }

            if (targetCell != null && !isObstacle(targetCell)) {
                var moved = moveTowardCell(targetCell, getMP());
                debug("[BOSS] Moved " + moved + " cells to align with crystal");

                playerCell = getCell();
                dist = getCellDistance(playerCell, crystal.cell);
                onSameLine = isOnSameLine(playerCell, crystal.cell);
            }
        }

        if (dist >= 2 && dist <= 8 && onSameLine && getTP() >= 3) {
            debug("[BOSS] ✅ Using BOXING_GLOVE to cell " + destCell);
            var result = useChipOnCell(CHIP_BOXING_GLOVE, destCell);

            if (result == USE_SUCCESS) {
                debug("[BOSS] ✅ BOXING_GLOVE successful!");
            } else {
                debug("[BOSS] ⚠️ BOXING_GLOVE failed: " + result);
            }
        } else {
            debug("[BOSS] ⚠️ Cannot use BOXING_GLOVE: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());
        }
    }
}
