
include('../game_entity.lk')
include('../field_map_core.lk')

function detectBossFight() {
    var entities = getAliveEnemies()
    for (var eid in entities) {
        var entityType = getName(eid)
        if (entityType == "graal") {
            return true
        }
    }
    return false
}

class BossFightStrategy {

    _grail = null
    _crystals = [:]  
    _myAssignedCrystal = null
    _usedInversion = false
    _fieldMap = null

    constructor() {
        this._fieldMap = new FieldMap()
    }

    shouldBuildDamageMap() {
        return false;  
    }

    createAndExecuteScenario(target, targetHitCell) {
        
        this.playTurn()
    }

    playTurn() {

        this.detectGrailAndCrystals()

        var crystalCount = 0
        for (var c in this._crystals) crystalCount++

        if (this._grail == null) {
            return
        }

        this.assignCrystal()

        if (this._myAssignedCrystal == null) {
            return
        }

        var solved = this.isCrystalSolved(this._myAssignedCrystal)

        if (solved) {
            return
        }

        this.decideAndExecuteAction()

    }

    detectGrailAndCrystals() {
        
        for (var cellId = 0; cellId < 613; cellId++) {
            if (!isEntity(cellId)) continue

            var eid = getEntityOnCell(cellId)
            var entityType = getName(eid)

            if (entityType == "graal") {
                this._grail = {
                    id: eid,
                    cell: cellId,
                    x: getCellX(cellId),
                    y: getCellY(cellId)
                }
            }
            else if (entityType == "red_crystal" || entityType == "blue_crystal" ||
                     entityType == "yellow_crystal" || entityType == "green_crystal") {
                var color = substring(entityType, 0, indexOf(entityType, "_"))
                var goalAxis = this.getGoalAxis(color)

                this._crystals[eid] = {
                    id: eid,
                    color: color,
                    goalAxis: goalAxis,
                    cell: cellId,
                    x: getCellX(cellId),
                    y: getCellY(cellId)
                }

            }
        }
    }

    assignCrystal() {
        
        var myID = getEntity()
        var allAllies = []
        push(allAllies, myID)
        var allies = getAliveAllies()
        for (var aid in allies) {
            push(allAllies, aid)
        }

        sort(allAllies)

        var myIndex = -1
        for (var i = 0; i < count(allAllies); i++) {
            if (allAllies[i] == myID) {
                myIndex = i
                break
            }
        }

        var crystalCount = 0
        for (var c in this._crystals) crystalCount++

        if (myIndex < 0 || myIndex >= crystalCount) {
            return
        }

        var colorOrder = ["red", "blue", "yellow", "green"]
        var targetColor = colorOrder[myIndex]


        for (var crystal in this._crystals) {

            if (crystal != null && crystal.color == targetColor) {
                this._myAssignedCrystal = crystal
                return
            }
        }

    }

    getGoalAxis(color) {
        if (color == "red") return "south";
        if (color == "blue") return "east";
        if (color == "yellow") return "west";
        if (color == "green") return "north";
        return "unknown";
    }

    isCrystalSolved(crystal) {
        return this.isOnGoalAxis(crystal) && this.hasLOSToGrail(crystal);
    }

    isOnGoalAxis(crystal) {
        if (this._grail == null) return false;

        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north") {
            return cx == gx && cy < gy;
        } else if (axis == "south") {
            return cx == gx && cy > gy;
        } else if (axis == "east") {
            return cy == gy && cx > gx;
        } else if (axis == "west") {
            return cy == gy && cx < gx;
        }

        return false;
    }

    hasLOSToGrail(crystal) {
        if (this._grail == null) return false;
        return lineOfSight(crystal.cell, this._grail.cell);
    }

    getDistanceToAxis(crystal) {
        if (this._grail == null) return 999;

        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north" || axis == "south") {
            return abs(cx - gx);  
        } else {
            return abs(cy - gy);  
        }
    }

    decideAndExecuteAction() {
        var crystal = this._myAssignedCrystal;
        var distToAxis = this.getDistanceToAxis(crystal);


        if (distToAxis > 8 && !this._usedInversion && getTP() >= 4) {
            this.executeInversion(crystal);
            return;
        }

        this.executeSlideTowardGoal(crystal);
    }

    executeInversion(crystal) {
        var playerCell = getCell();
        var dist = getCellDistance(playerCell, crystal.cell);


        if (dist > 14) {
            var moved = moveTowardCell(crystal.cell, getMP());

            playerCell = getCell();
            dist = getCellDistance(playerCell, crystal.cell);

            if (dist > 14) {
                return;
            }
        }

        if (getTP() >= 4 && lineOfSight(playerCell, crystal.cell)) {
            var result = useChipOnCell(CHIP_INVERSION, crystal.cell);

            if (result == USE_SUCCESS) {
                this._usedInversion = true;
            } else {
            }
        } else {
        }
    }

    executeSlideTowardGoal(crystal) {
        var axis = crystal.goalAxis;

        var direction = this.getDirectionToSlide(crystal);

        if (direction == null) {
            return;
        }


        if (direction == "pull") {
            this.executeGrapple(crystal);
        } else {
            this.executeBoxingGlove(crystal);
        }
    }

    getDirectionToSlide(crystal) {
        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north" || axis == "south") {
            
            if (cx < gx) return "pull";  
            if (cx > gx) return "push";  

            if (axis == "north" && cy >= gy) return "push";  
            if (axis == "south" && cy <= gy) return "pull";  
        } else {
            
            if (cy < gy) return "pull";  
            if (cy > gy) return "push";  

            if (axis == "east" && cx <= gx) return "pull";  
            if (axis == "west" && cx >= gx) return "push";  
        }

        return null;
    }

    executeGrapple(crystal) {
        var playerCell = getCell();
        var px = getCellX(playerCell);
        var py = getCellY(playerCell);

        var dx = crystal.x;
        var dy = crystal.y;

        if (crystal.x < px) dx++;
        else if (crystal.x > px) dx--;

        if (crystal.y < py) dy++;
        else if (crystal.y > py) dy--;

        var destCell = getCellFromXY(dx, dy);

        if (destCell == null || !(!isObstacle(destCell) && !isEntity(destCell))) {
            return;
        }

        var dist = getCellDistance(playerCell, crystal.cell);
        var onSameLine = isOnSameLine(playerCell, crystal.cell);


        if (dist < 1 || dist > 8 || !onSameLine) {

            var cx = crystal.x;
            var cy = crystal.y;

            var targetCell = getCellFromXY(cx - 4, cy);
            if (targetCell == null || isObstacle(targetCell)) {
                
                targetCell = getCellFromXY(cx, cy - 4);
            }

            if (targetCell != null && !isObstacle(targetCell)) {
                var moved = moveTowardCell(targetCell, getMP());

                playerCell = getCell();
                dist = getCellDistance(playerCell, crystal.cell);
                onSameLine = isOnSameLine(playerCell, crystal.cell);
            }
        }

        if (dist >= 1 && dist <= 8 && onSameLine && getTP() >= 4) {
            var result = useChipOnCell(CHIP_GRAPPLE, destCell);

            if (result == USE_SUCCESS) {
            } else {
            }
        } else {
        }
    }

    executeBoxingGlove(crystal) {
        var playerCell = getCell();
        var px = getCellX(playerCell);
        var py = getCellY(playerCell);

        var dx = crystal.x;
        var dy = crystal.y;

        if (crystal.x < px) dx--;
        else if (crystal.x > px) dx++;

        if (crystal.y < py) dy--;
        else if (crystal.y > py) dy++;

        var destCell = getCellFromXY(dx, dy);

        if (destCell == null || !(!isObstacle(destCell) && !isEntity(destCell))) {
            return;
        }

        var dist = getCellDistance(playerCell, crystal.cell);
        var onSameLine = isOnSameLine(playerCell, crystal.cell);


        if (dist < 2 || dist > 8 || !onSameLine) {

            var cx = crystal.x;
            var cy = crystal.y;

            var targetCell = getCellFromXY(cx + 4, cy);
            if (targetCell == null || isObstacle(targetCell)) {
                
                targetCell = getCellFromXY(cx, cy + 4);
            }

            if (targetCell != null && !isObstacle(targetCell)) {
                var moved = moveTowardCell(targetCell, getMP());

                playerCell = getCell();
                dist = getCellDistance(playerCell, crystal.cell);
                onSameLine = isOnSameLine(playerCell, crystal.cell);
            }
        }

        if (dist >= 2 && dist <= 8 && onSameLine && getTP() >= 3) {
            var result = useChipOnCell(CHIP_BOXING_GLOVE, destCell);

            if (result == USE_SUCCESS) {
            } else {
            }
        } else {
        }
    }
}
