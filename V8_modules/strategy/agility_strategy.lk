include('action.lk')
include('base_strategy.lk')

class AgilityStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "AGI"
    }

    // Select best available damage return chip (priority: MIRROR > THORN)
    selectBestReturnChip() {
        // CHIP_MIRROR: 5-6% return, 3 turn duration, 5 TP cost
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR)) {
            var mirror = arsenal.playerEquippedChips[CHIP_MIRROR]
            if (getCooldown(CHIP_MIRROR, player._id) == 0 && player._currTp >= mirror._cost) {
                var returnVal = arsenal.getDamageReturnValue(player._agility, CHIP_MIRROR)
                debug("[AGILITY] CHIP_MIRROR available: " + returnVal + "% return (scaled by agility)")
                return CHIP_MIRROR
            }
        }

        // CHIP_THORN: 3-4% return, 2 turn duration, 4 TP cost
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN)) {
            var thorn = arsenal.playerEquippedChips[CHIP_THORN]
            if (getCooldown(CHIP_THORN, player._id) == 0 && player._currTp >= thorn._cost) {
                var returnVal2 = arsenal.getDamageReturnValue(player._agility, CHIP_THORN)
                debug("[AGILITY] CHIP_THORN available: " + returnVal2 + "% return (scaled by agility)")
                return CHIP_THORN
            }
        }

        return -1
    }

    // Check if CHIP_WARM_UP should be used (agility buff)
    shouldUseWarmUp() {
        // CHIP_WARM_UP: 7 TP cost, need 14 TP minimum (7 + 5-7 for MIRROR/THORN + attacks)
        if (!this.shouldApplyStatBuff(CHIP_WARM_UP, EFFECT_BUFF_AGILITY, 14)) return false

        // Validate TP budget (7 TP for WARM_UP + minimum for attacks)
        if (!this.validateTPBudget(7)) return false

        return true
    }



    // Check if we should reapply damage return buff
    shouldReapplyReturnBuff() {
        var hasReturn = player.hasDamageReturn()
        var returnRemaining = player.getDamageReturnRemaining()

        // No active return buff
        if (!hasReturn) {
            debug("[AGILITY] No damage return active - MUST reapply")
            return true
        }

        // Return buff expiring soon (â‰¤1 turn remaining)
        if (returnRemaining <= 1) {
            debug("[AGILITY] Damage return expiring in " + returnRemaining + " turn(s) - reapplying")
            return true
        }

        debug("[AGILITY] Damage return active with " + returnRemaining + " turns remaining")
        return false
    }

    // WEEK 2: Check if CHIP_LIBERATION is tactically valuable (same as strength)
    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        // Check range to target
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        // Priority 1: Remove critical player debuffs (shackles reducing our combat effectiveness)
        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        // Priority 2: Remove player poison if significant
        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        // Priority 3: Remove enemy buffs/shields/damage return
        var enemyShielded = target._relShield > 15 || target._absShield > 30
        var enemyHasDamageReturn = target.hasEffect(EFFECT_DAMAGE_RETURN)

        // Use if we have critical debuffs OR poison with 3+ turns OR enemy heavily buffed
        if (hasDebuff) {
            debug("[AGI][LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[AGI][LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyShielded) {
            debug("[AGI][LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }
        if (enemyHasDamageReturn) {
            debug("[AGI][LIBERATION] Should use to strip enemy damage return (mirror vs mirror)")
            return true
        }

        return false
    }

    // Override offensive scenario for agility builds
    // Strategy: Apply CHIP_MIRROR/THORN damage return buff, then fight like strength builds
    createOffensiveScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            // Rebuild hit map for chest position
            fieldMap.buildHitMap(chest._cellPos)
            targetHitCell = fieldMap.getBestWeaponOrChipCell()
        }

        var playerPos = player._cellPos
        var playerMP = player._currMp
        var playerTP = player._currTp

        // STEP 0: Apply CHIP_WARM_UP before damage return buff if needed
        if (this.shouldUseWarmUp()) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_WARM_UP)
            playerTP -= 7
            debug("[AGILITY] Applied CHIP_WARM_UP (+170-190 Agility for 3 turns)")
        }

        // STEP 0.5: Check for CHIP_LEATHER_BOOTS if target cell unreachable
        if (targetHitCell != -1 && targetHitCell != null && this.shouldUseLeatherBoots(targetHitCell._id)) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_LEATHER_BOOTS)
            playerTP -= 3
            playerMP += 2  // Immediate MP boost
            debug("[AGILITY] Applied CHIP_LEATHER_BOOTS (+2 MP for 2 turns)")
        }

        // STEP 1: Apply damage return buff (CHIP_MIRROR or CHIP_THORN) if needed
        // Only apply if we have enough TP left for attacks (minimum 7 TP: 1 swap + 6 weapon use)
        if (this.shouldReapplyReturnBuff()) {
            var chipToUse = this.selectBestReturnChip()
            if (chipToUse != -1) {
                var chipObj = arsenal.playerEquippedChips[chipToUse]
                var minAttackTP = 7  // Reserve TP for at least one weapon swap + use

                // Only apply buff if we have enough TP for meaningful attacks after
                if (playerTP >= chipObj._cost + minAttackTP) {
                    debug("[AGILITY] Applying damage return chip: " + getChipName(chipToUse) + " (cost: " + chipObj._cost + " TP, remaining: " + (playerTP - chipObj._cost) + " TP)")
                    this.createAttackAction(Action.ACTION_BUFF, player, -1, chipToUse)
                    playerTP -= chipObj._cost
                } else {
                    debug("[AGILITY] Skipping buff reapplication - need TP for attacks (have " + playerTP + " TP, need " + (chipObj._cost + minAttackTP) + " TP)")
                }
            } else {
                debug("[AGILITY] WARNING: No return chip available (MIRROR/THORN on cooldown or insufficient TP)")
            }
        }

        // WEEK 2 STEP 1.5: Check for tactical CHIP_LIBERATION usage BEFORE combat
        if (this.shouldUseLiberation(target)) {
            // Use on enemy to remove their buffs, or on self to remove debuffs
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[AGI] Using Liberation on self to remove debuffs")
            } else {
                debug("[AGI] Using Liberation on enemy to remove buffs/shields/damage return")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            // Update action with correct target cell
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            playerTP -= 5
        }

        // STEP 2: WEEK 2 - Select best tactical cell (hit-and-run: damage vs threat)
        // Agility builds leverage mobility to maximize damage while minimizing risk
        var tacticalCell = fieldMap.findBestTacticalCell(playerMP, 0.4)  // Threat weighted 40% (less risk-averse than magic)

        var bestWeaponCell = -1
        if (tacticalCell != null && tacticalCell != -1 && tacticalCell._highestDamageWeapon != -1) {
            bestWeaponCell = tacticalCell
            debug("[AGILITY][TACTICAL] Using threat-aware positioning: cell=" + tacticalCell._id + " damage=" + tacticalCell._totalDamage + " threat=" + fieldMap.getThreatAtCell(tacticalCell._id))
        } else {
            // Fallback: Select pure damage cell (legacy behavior)
            var bestWeaponDamage = -1
            var bestDist = 99999
            for (var c in fieldMap.damageMap) {
                if (c._highestDamageWeapon == -1) continue  // Skip chip-only cells
                var dist = getPathLength(playerPos, c._id)
                if (dist == null) continue  // Skip completely unreachable cells
                // Prefer higher weaponDamage, tie-break shorter distance
                if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                    bestWeaponDamage = c._weaponDamage
                    bestWeaponCell = c
                    bestDist = dist
                }
            }
            debug("[AGILITY][FALLBACK] Using pure damage cell (no tactical cell available)")
        }
        // Fallback to incoming targetHitCell if no weapon cell found
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) {
            bestWeaponCell = targetHitCell
        }
        if (bestWeaponCell == -1) {
            debug("[AGILITY] No valid weapon cell found, aborting offensive")
            return
        }

        // STEP 2.5: Check if CHIP_ADRENALINE can help with weapon spam
        if (this.shouldUseAdrenaline(playerTP + 4)) {  // Check if +4 TP would enable more attacks
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
            playerTP -= 1
            playerTP += 5  // Net gain of 4 TP
            debug("[AGILITY][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")
        }

        // STEP 3: Execute shared weapon-focused combat logic (exclude CHIP_MIRROR/THORN from damage chips)
        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [CHIP_MIRROR, CHIP_THORN], "AGILITY")

        debug("[AGILITY] Offensive scenario complete. Remaining TP: " + result['playerTP'] + ", MP: " + result['playerMP'])
    }
}
