include('action.lk')
include('base_strategy.lk')

class AgilityStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "AGI"
    }

    createOTKOScenario(target, targetHitCell) {
        
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST-OTKO] Chest detected! Switching OTKO target from enemy to chest (ID: " + chest._id + ")")
            target = chest
        }

        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
            debug("[OTKO] Teleportation not equipped")
            return false
        }

        var cooldown = getCooldown(CHIP_TELEPORTATION, getEntity())
        if (cooldown > 0) {
            debug("[OTKO] Teleportation on cooldown: " + cooldown + " turns")
            return false
        }

        var playerTP = player._currTp
        if (playerTP < 15) {  
            debug("[OTKO] Insufficient TP for teleport OTKO: " + playerTP)
            return false
        }

        var teleportInfo = fieldMap.findOptimalTeleportCell(target)
        if (teleportInfo == null) {
            debug("[OTKO] No valid teleport cells found")
            return false
        }

        var killProb = teleportInfo['killProbability']
        if (killProb < 0.85 && !(target instanceof Chest)) {
            debug("[OTKO] Kill probability too low: " + round(killProb * 100) + "% (damage: " + teleportInfo['damage'] + " vs HP: " + target._currHealth + ")")

            if (this.shouldUseAdrenaline(15)) {  
                this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
                playerTP -= 1
                playerTP += 5  
                player._currTp = playerTP  
                debug("[OTKO][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")

                teleportInfo = fieldMap.findOptimalTeleportCell(target)
                if (teleportInfo == null) {
                    debug("[OTKO][ADRENALINE] Recalculation failed")
                    return false
                }

                var newKillProb = teleportInfo['killProbability']
                if (newKillProb < 0.85) {
                    debug("[OTKO][ADRENALINE] Still insufficient kill probability after Adrenaline: " + round(newKillProb * 100) + "% (damage: " + teleportInfo['damage'] + " vs HP: " + target._currHealth + ")")
                    return false
                }
                debug("[OTKO][ADRENALINE] Recalculated kill probability: " + round(newKillProb * 100) + "% (sufficient for OTKO)")
            } else {
                return false
            }
        }

        var teleCell = teleportInfo['cell']
        debug("[OTKO] Executing teleport OTKO to cell " + teleCell + " projected damage: " + teleportInfo['damage'])

        var plannedWeapon = getWeapon()

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO) && playerTP >= 21) {
            var preTeleportDist = getCellDistance(player._cellPos, target._cellPos)
            var preTeleportAligned = this.isDiagonal(player._cellPos, target._cellPos)

            if (preTeleportDist != null && preTeleportDist >= 2 && preTeleportDist <= 6 &&
                preTeleportAligned && lineOfSight(player._cellPos, target._cellPos)) {

                debug("[OTKO][NEUTRINO] Pre-stacking vulnerability before teleport for amplified OTKO")

                if (plannedWeapon != WEAPON_NEUTRINO) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, WEAPON_NEUTRINO, -1)
                    playerTP -= 1
                    plannedWeapon = WEAPON_NEUTRINO
                }

                for (var nStack = 0; nStack < 3; nStack++) {
                    if (playerTP >= 4) {
                        this.createAttackAction(Action.ACTION_DIRECT, target, WEAPON_NEUTRINO, -1)
                        playerTP -= 4
                    }
                }

                debug("[OTKO][NEUTRINO] Queued 3x Neutrino for 24% vulnerability stacking, TP remaining: " + playerTP + " - now queueing teleport + burst")
            } else {
                debug("[OTKO][NEUTRINO] Cannot pre-stack: dist=" + preTeleportDist + " (need 2-6), diagonal=" + preTeleportAligned + ", TP=" + playerTP)
            }
        }

        this.createAttackAction(Action.ACTION_TELEPORT, target, -1, CHIP_TELEPORTATION)
        
        this._actions[count(this._actions) - 1].targetCell = teleCell
        playerTP -= 9

        var playerPos = teleCell

        var weaponDmgList = []
        var distToTarget = getCellDistance(teleCell, target._cellPos)
        debug("[OTKO][WEAPONS] From teleport cell " + teleCell + " to target " + target._cellPos + " dist=" + distToTarget + " TP=" + playerTP)
        debug("[OTKO][WEAPONS] Equipped weapons: " + count(mapKeys(arsenal.playerEquippedWeapons)))

        for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue

            if (distToTarget == null) continue

            var minR = getWeaponMinRange(wid)
            var maxR = getWeaponMaxRange(wid)
            var dist = distToTarget

            if (dist < minR || dist > maxR) {
                debug("[OTKO][WEAPONS] Skip " + getWeaponName(wid) + " - out of range (need " + minR + "-" + maxR + ", have " + dist + ")")
                continue
            }
            if (!lineOfSight(teleCell, target._cellPos)) {
                debug("[OTKO][WEAPONS] Skip " + getWeaponName(wid) + " - no LOS")
                continue
            }

            var netDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, player._science, wid, target)
            debug("[OTKO][WEAPONS] Add " + getWeaponName(wid) + " - dmg=" + netDmg + " cost=" + wObj._cost + " maxUses=" + wObj._maxUse)
            push(weaponDmgList, ['weapon': wObj, 'netDmg': netDmg])
        }

        debug("[OTKO][WEAPONS] Total usable weapons: " + count(weaponDmgList))

        for (var i = 0; i < count(weaponDmgList); i++) {
            var bestIdx = i
            for (var j = i + 1; j < count(weaponDmgList); j++) {
                if (weaponDmgList[j]['netDmg'] > weaponDmgList[bestIdx]['netDmg']) bestIdx = j
            }
            if (bestIdx != i) {
                var tmp = weaponDmgList[i]
                weaponDmgList[i] = weaponDmgList[bestIdx]
                weaponDmgList[bestIdx] = tmp
            }
        }

        for (var wi = 0; wi < count(weaponDmgList); wi++) {
            var wRec = weaponDmgList[wi]
            var wObj = wRec['weapon']

            if (plannedWeapon != wObj._id) {
                if (playerTP >= 1 + wObj._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                    plannedWeapon = wObj._id
                } else {
                    continue  
                }
            }

            var uses = min(wObj._maxUse, floor(playerTP / wObj._cost))
            while (uses > 0 && playerTP >= wObj._cost) {
                this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                playerTP -= wObj._cost
                uses -= 1
            }

            if (playerTP <= 0) break
        }

        if (playerTP > 0) {
            var chipDmgList = []
            for (var cid in mapKeys(arsenal.playerEquippedChips)) {
                var chipObj = arsenal.playerEquippedChips[cid]
                if (chipObj == null) continue
                if (cid == CHIP_TELEPORTATION) continue

                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                var distChip = getCellDistance(teleCell, target._cellPos)
                if (distChip == null) continue
                if (distChip < chipObj._minRange || distChip > chipObj._maxRange) continue
                if (!lineOfSight(teleCell, target._cellPos)) continue

                var netChipDmg = arsenal.getNetDamageAgainstTarget(player._strength, player._magic, player._wisdom, player._science, cid, target)
                push(chipDmgList, ['chip': chipObj, 'netDmg': netChipDmg])
            }

            for (var ci = 0; ci < count(chipDmgList); ci++) {
                var bestCIdx = ci
                for (var cj = ci + 1; cj < count(chipDmgList); cj++) {
                    if (chipDmgList[cj]['netDmg'] > chipDmgList[bestCIdx]['netDmg']) bestCIdx = cj
                }
                if (bestCIdx != ci) {
                    var tmpC = chipDmgList[ci]
                    chipDmgList[ci] = chipDmgList[bestCIdx]
                    chipDmgList[bestCIdx] = tmpC
                }
            }

            for (var chipIdx = 0; chipIdx < count(chipDmgList); chipIdx++) {
                var cRec = chipDmgList[chipIdx]
                var chipUse = cRec['chip']
                if (playerTP < chipUse._cost) continue
                
                var actualUsesC = 0
                while (actualUsesC < chipUse._maxUse && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    actualUsesC += 1
                }
                if (playerTP <= 0) break
            }
        }

        debug("[OTKO] OTKO scenario complete, remaining TP: " + playerTP)
        return true
    }

    selectBestReturnChip(distanceToEnemy) {
        var inCloseCombat = distanceToEnemy <= 8
        var currentTP = player._currTp

        var hasMirror = mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR)
        var hasThorn = mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN)
        var hasBramble = mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE)

        var mirrorCd = hasMirror ? getCooldown(CHIP_MIRROR, player._id) : 999
        var thornCd = hasThorn ? getCooldown(CHIP_THORN, player._id) : 999
        var brambleCd = hasBramble ? getCooldown(CHIP_BRAMBLE, player._id) : 999

        var mirrorReady = mirrorCd == 0 && hasMirror && currentTP >= 5
        var thornReady = thornCd == 0 && hasThorn && currentTP >= 4
        var brambleReady = brambleCd == 0 && hasBramble && currentTP >= 4

        if (brambleReady && inCloseCombat && currentTP >= 10) {
            debug("[AGILITY][CYCLE] BRAMBLE active combat: 25% return × 1t (melee range, TP=" + currentTP + ")")
            return CHIP_BRAMBLE
        }

        if (currentTP < 15) {
            if (thornReady) {
                debug("[AGILITY][CYCLE] THORN (low TP): 3-4% return × 2t (TP=" + currentTP + ", cheaper than MIRROR)")
                return CHIP_THORN
            }
            if (mirrorReady && currentTP >= 10) {
                debug("[AGILITY][CYCLE] MIRROR (low TP): 5-6% return × 3t (TP=" + currentTP + ", using anyway)")
                return CHIP_MIRROR
            }
            
            debug("[AGILITY][CYCLE] SKIP: TP too low (" + currentTP + "), attack directly")
            return -1
        }

        if (mirrorReady && thornReady && currentTP >= 15) {
            debug("[AGILITY][CYCLE] Both available: MIRROR (3t > 2t, TP=" + currentTP + ")")
            return CHIP_MIRROR
        }

        if (mirrorReady) {
            debug("[AGILITY][CYCLE] MIRROR: 5-6% return × 3t (THORN cd=" + thornCd + ")")
            return CHIP_MIRROR
        }

        if (thornReady) {
            debug("[AGILITY][CYCLE] THORN: 3-4% return × 2t (MIRROR cd=" + mirrorCd + ")")
            return CHIP_THORN
        }

        debug("[AGILITY][CYCLE] GAP: All on cooldown (MIRROR=" + mirrorCd + ", THORN=" + thornCd + ", BRAMBLE=" + brambleCd + ")")
        return -1
    }

    shouldUseWarmUp() {
        
        if (!this.shouldApplyStatBuff(CHIP_WARM_UP, EFFECT_BUFF_AGILITY, 14)) return false

        if (!this.validateTPBudget(7)) return false

        return true
    }

    shouldReapplyReturnBuff() {
        var hasReturn = player.hasDamageReturn()
        var returnRemaining = player.getDamageReturnRemaining()
        var currentTP = player._currTp

        if (!hasReturn) {
            if (currentTP >= 10) {
                debug("[AGILITY][CYCLE] No damage return active - reapply (TP=" + currentTP + ")")
                return true
            } else {
                debug("[AGILITY][CYCLE] No damage return but TP too low (" + currentTP + "), skip and attack directly")
                return false
            }
        }

        var hasMirror = mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR)
        var hasThorn = mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN)
        var hasBramble = mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE)

        var mirrorReady = hasMirror && getCooldown(CHIP_MIRROR, player._id) == 0 && currentTP >= 5
        var thornReady = hasThorn && getCooldown(CHIP_THORN, player._id) == 0 && currentTP >= 4
        var brambleReady = hasBramble && getCooldown(CHIP_BRAMBLE, player._id) == 0 && currentTP >= 4

        if (returnRemaining <= 1 && (mirrorReady || thornReady || brambleReady) && currentTP >= 10) {
            debug("[AGILITY][CYCLE] Expiring in " + returnRemaining + " turn, switching chip early (TP=" + currentTP + ")")
            return true
        }

        debug("[AGILITY][CYCLE] Active with " + returnRemaining + " turns remaining, waiting")
        return false
    }

    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        var enemyShielded = target._relShield > 15 || target._absShield > 30
        var enemyHasDamageReturn = target.hasEffect(EFFECT_DAMAGE_RETURN)

        if (hasDebuff) {
            debug("[AGI][LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[AGI][LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyShielded) {
            debug("[AGI][LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }
        if (enemyHasDamageReturn) {
            debug("[AGI][LIBERATION] Should use to strip enemy damage return (mirror vs mirror)")
            return true
        }

        return false
    }

    shouldEnterEmergencyMode(target) {
        
        debug("[AGILITY][AGGRESSIVE] Never flee - always attack (HP=" + floor((getLife() * 100) / getTotalLife()) + "%)")
        return false
    }

    createOffensiveScenario(target, targetHitCell) {
        
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            
            fieldMap.buildHitMap(chest._cellPos)
            targetHitCell = fieldMap.getBestWeaponOrChipCell()
        }

        var playerPos = player._cellPos
        var playerMP = player._currMp
        var playerTP = player._currTp

        var distToTarget = getCellDistance(playerPos, target._cellPos)
        if (distToTarget == null) distToTarget = 99

        var canTeleport = mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION) &&
                         getCooldown(CHIP_TELEPORTATION, getEntity()) == 0 &&
                         player._currTp >= 15  

        if (canTeleport) {
            
            var teleportInfo = fieldMap.findOptimalTeleportCell(target)
            if (teleportInfo != null) {
                var teleCell = teleportInfo['cell']
                var killProb = teleportInfo['killProbability']
                var projectedDamage = teleportInfo['damage']
                var enemyHP = target._currHealth

                debug("[AGI][OTKO-ATTRITION] Enemy HP: " + enemyHP + ", Projected damage: " + floor(projectedDamage) + ", Kill prob: " + round(killProb * 100) + "%")

                if (killProb >= 0.85) {
                    debug("[AGI][OTKO-ATTRITION] OTKO NOW VIABLE! Enemy weakened to " + enemyHP + " HP, executing kill shot!")
                    var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
                    if (otkoExecuted) {
                        debug("[AGI] OTKO scenario executed successfully (attrition-based)")
                        return  
                    }
                    debug("[AGI] OTKO execution failed, falling back to normal offensive scenario")
                }
                
                else if (enemyHP < 1500) {
                    debug("[AGI][OTKO-ATTRITION] Enemy at " + enemyHP + " HP, need " + round((killProb * 100)) + "% → 85% kill prob (continue attrition)")
                }
            }
        }

        var returnChipApplied = false
        if (this.shouldReapplyReturnBuff()) {
            var chipToUse = this.selectBestReturnChip(distToTarget)
            if (chipToUse != -1) {
                var chipObj = arsenal.playerEquippedChips[chipToUse]
                debug("[AGILITY][AGGRESSIVE] Applying damage return chip: " + getChipName(chipToUse) + " (cost: " + chipObj._cost + " TP, dist: " + distToTarget + ")")
                this.createAttackAction(Action.ACTION_BUFF, player, -1, chipToUse)
                playerTP -= chipObj._cost
                returnChipApplied = true

                this.executeAndFlushActions()
                player.updateEntity()
                debug("[AGILITY][AGGRESSIVE] Damage return buff applied and flushed, TP remaining: " + player._currTp)
            } else {
                debug("[AGILITY] WARNING: No return chip available (BRAMBLE/MIRROR/THORN on cooldown or insufficient TP)")
            }
        }

        if (this.shouldUseWarmUp() && playerTP >= 14) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_WARM_UP)
            playerTP -= 7
            debug("[AGILITY] Applied CHIP_WARM_UP (+170-190 Agility for 3 turns, remaining TP: " + playerTP + ")")

            if (canTeleport && player._currTp >= 15) {
                var teleportInfoBuffed = fieldMap.findOptimalTeleportCell(target)
                if (teleportInfoBuffed != null) {
                    var killProbBuffed = teleportInfoBuffed['killProbability']
                    var dmgBuffed = teleportInfoBuffed['damage']

                    debug("[AGI][OTKO-RECHECK] With WARM_UP: damage=" + floor(dmgBuffed) + " vs HP=" + target._currHealth + ", kill prob=" + round(killProbBuffed * 100) + "%")

                    if (killProbBuffed >= 0.85) {
                        debug("[AGI][OTKO-RECHECK] WARM_UP enabled OTKO! Executing...")
                        var otkoExecuted = this.createOTKOScenario(target, targetHitCell)
                        if (otkoExecuted) {
                            debug("[AGI] OTKO with WARM_UP executed successfully")
                            return  
                        }
                    }
                }
            }
        } else if (playerTP < 14) {
            debug("[AGILITY] Skipping WARM_UP - not enough TP for attacks after buff (have " + playerTP + " TP, need 14)")
        }

        if (!target.hasVulnerability() && mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            var neutrinoWeapon = arsenal.playerEquippedWeapons[WEAPON_NEUTRINO]
            
            if (distToTarget != null && distToTarget >= neutrinoWeapon._minRange && distToTarget <= neutrinoWeapon._maxRange) {
                if (playerTP >= neutrinoWeapon._cost) {
                    debug("[AGILITY][AGGRESSIVE] Applying WEAPON_NEUTRINO vulnerability debuff (dist=" + distToTarget + ", amplifies damage)")
                    
                }
            }
        }

        if (targetHitCell != -1 && targetHitCell != null && this.shouldUseLeatherBoots(targetHitCell._id)) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_LEATHER_BOOTS)
            playerTP -= 3
            playerMP += 2  
            debug("[AGILITY] Applied CHIP_LEATHER_BOOTS (+2 MP for 2 turns)")
        }

        if (this.shouldUseLiberation(target)) {
            
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[AGI] Using Liberation on self to remove debuffs")
            } else {
                debug("[AGI] Using Liberation on enemy to remove buffs/shields/damage return")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            playerTP -= 5
        }

        var tacticalCell = fieldMap.findBestTacticalCell(playerMP, 0.4)  

        var bestWeaponCell = -1
        if (tacticalCell != null && tacticalCell != -1 && tacticalCell._highestDamageWeapon != -1) {
            bestWeaponCell = tacticalCell
            debug("[AGILITY][TACTICAL] Using threat-aware positioning: cell=" + tacticalCell._id + " damage=" + tacticalCell._totalDamage + " threat=" + fieldMap.getThreatAtCell(tacticalCell._id))
        } else {
            
            var bestWeaponDamage = -1
            var bestDist = 99999
            for (var c in fieldMap.damageMap) {
                if (c._highestDamageWeapon == -1) continue  
                var dist = getCachedPathLength(playerPos, c._id)
                if (dist == null) continue  
                
                if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                    bestWeaponDamage = c._weaponDamage
                    bestWeaponCell = c
                    bestDist = dist
                }
            }
            debug("[AGILITY][FALLBACK] Using pure damage cell (no tactical cell available)")
        }
        
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) {
            bestWeaponCell = targetHitCell
        }
        if (bestWeaponCell == -1) {
            debug("[AGILITY] No valid weapon cell found, aborting offensive")
            return
        }

        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [CHIP_BRAMBLE, CHIP_MIRROR, CHIP_THORN], "AGILITY", true)

        playerTP = result['playerTP']
        playerMP = result['playerMP']
        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_SWORD)) {
            var swordWeapon = arsenal.playerEquippedWeapons[WEAPON_SWORD]
            
            distToTarget = getCellDistance(player._cellPos, target._cellPos)

            if (distToTarget != null && distToTarget >= swordWeapon._minRange && distToTarget <= swordWeapon._maxRange) {
                var shieldsStacked = 0
                while (playerTP >= swordWeapon._cost && shieldsStacked < 3) {  
                    debug("[AGILITY][SHIELD-STACK] Using WEAPON_SWORD for defensive layering (8% shield, stack #" + (shieldsStacked + 1) + ")")
                    this.createAttackAction(Action.ACTION_DIRECT, target, swordWeapon._id, -1)
                    playerTP -= swordWeapon._cost
                    shieldsStacked++
                }
                if (shieldsStacked > 0) {
                    debug("[AGILITY][SHIELD-STACK] Stacked " + shieldsStacked + " shields (~" + (shieldsStacked * 8) + "% total), remaining TP: " + playerTP)
                }
            }
        }

        debug("[AGILITY] Offensive scenario complete. Remaining TP: " + playerTP + ", MP: " + playerMP)
        debug("[AGILITY] AGGRESSIVE MODE: Stay in combat range, no defensive retreat")
    }
}
