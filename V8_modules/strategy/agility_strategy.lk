include('action.lk')
include('base_strategy.lk')

class AgilityStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "AGI"
    }

    // Select best available damage return chip based on combat situation
    // BRAMBLE (1 turn, 25% return) - Use when in close combat (enemy within attack range)
    // MIRROR (3 turns, 5-6% return) - Use when approaching (enemy far, need sustained protection)
    // THORN (2 turns, 3-4% return) - Fallback option
    selectBestReturnChip(distanceToEnemy) {
        // Determine if we're in close combat (enemy can attack us or we can attack them)
        var inCloseCombat = distanceToEnemy <= 8  // Most weapons have range 1-8

        // CHIP_BRAMBLE: Best for close combat (1 turn duration, highest return per turn)
        if (inCloseCombat && mapContainsKey(arsenal.playerEquippedChips, CHIP_BRAMBLE)) {
            var bramble = arsenal.playerEquippedChips[CHIP_BRAMBLE]
            if (getCooldown(CHIP_BRAMBLE, player._id) == 0 && player._currTp >= bramble._cost) {
                var returnVal = arsenal.getDamageReturnValue(player._agility, CHIP_BRAMBLE)
                debug("[AGILITY] CHIP_BRAMBLE selected for close combat: " + returnVal + "% return, dist=" + distanceToEnemy)
                return CHIP_BRAMBLE
            }
        }

        // CHIP_MIRROR: Best for approaching (3 turn duration, sustained protection)
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR)) {
            var mirror = arsenal.playerEquippedChips[CHIP_MIRROR]
            if (getCooldown(CHIP_MIRROR, player._id) == 0 && player._currTp >= mirror._cost) {
                var returnVal2 = arsenal.getDamageReturnValue(player._agility, CHIP_MIRROR)
                debug("[AGILITY] CHIP_MIRROR selected: " + returnVal2 + "% return for 3 turns, dist=" + distanceToEnemy)
                return CHIP_MIRROR
            }
        }

        // CHIP_THORN: Fallback (2 turn duration)
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_THORN)) {
            var thorn = arsenal.playerEquippedChips[CHIP_THORN]
            if (getCooldown(CHIP_THORN, player._id) == 0 && player._currTp >= thorn._cost) {
                var returnVal3 = arsenal.getDamageReturnValue(player._agility, CHIP_THORN)
                debug("[AGILITY] CHIP_THORN selected: " + returnVal3 + "% return for 2 turns, dist=" + distanceToEnemy)
                return CHIP_THORN
            }
        }

        return -1
    }

    // Check if CHIP_WARM_UP should be used (agility buff)
    shouldUseWarmUp() {
        // CHIP_WARM_UP: 7 TP cost, need 14 TP minimum (7 + 5-7 for MIRROR/THORN + attacks)
        if (!this.shouldApplyStatBuff(CHIP_WARM_UP, EFFECT_BUFF_AGILITY, 14)) return false

        // Validate TP budget (7 TP for WARM_UP + minimum for attacks)
        if (!this.validateTPBudget(7)) return false

        return true
    }



    // Check if we should reapply damage return buff
    shouldReapplyReturnBuff() {
        var hasReturn = player.hasDamageReturn()
        var returnRemaining = player.getDamageReturnRemaining()

        // No active return buff
        if (!hasReturn) {
            debug("[AGILITY] No damage return active - MUST reapply")
            return true
        }

        // Return buff expiring soon (â‰¤1 turn remaining)
        if (returnRemaining <= 1) {
            debug("[AGILITY] Damage return expiring in " + returnRemaining + " turn(s) - reapplying")
            return true
        }

        debug("[AGILITY] Damage return active with " + returnRemaining + " turns remaining")
        return false
    }

    // WEEK 2: Check if CHIP_LIBERATION is tactically valuable (same as strength)
    shouldUseLiberation(target) {
        if (!mapContainsKey(arsenal.playerEquippedChips, CHIP_LIBERATION)) return false

        var cooldown = getCooldown(CHIP_LIBERATION, getEntity())
        if (cooldown > 0) return false

        var playerTP = player._currTp
        if (playerTP < 5) return false

        // Check range to target
        var dist = getCellDistance(player._cellPos, target._cellPos)
        if (dist == null || dist > 6) return false

        // Priority 1: Remove critical player debuffs (shackles reducing our combat effectiveness)
        var hasDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                       player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                       player.hasEffect(EFFECT_SHACKLE_MP) ||
                       player.hasEffect(EFFECT_SHACKLE_AGILITY)

        // Priority 2: Remove player poison if significant
        var hasPoison = player.hasEffect(EFFECT_POISON)
        var poisonRemaining = player.getEffectRemaining(EFFECT_POISON)

        // Priority 3: Remove enemy buffs/shields/damage return
        var enemyShielded = target._relShield > 15 || target._absShield > 30
        var enemyHasDamageReturn = target.hasEffect(EFFECT_DAMAGE_RETURN)

        // Use if we have critical debuffs OR poison with 3+ turns OR enemy heavily buffed
        if (hasDebuff) {
            debug("[AGI][LIBERATION] Should use to remove player debuffs")
            return true
        }
        if (hasPoison && poisonRemaining >= 3) {
            debug("[AGI][LIBERATION] Should use to reduce poison (remaining: " + poisonRemaining + " turns)")
            return true
        }
        if (enemyShielded) {
            debug("[AGI][LIBERATION] Should use to strip enemy shields (rel: " + target._relShield + "%, abs: " + target._absShield + ")")
            return true
        }
        if (enemyHasDamageReturn) {
            debug("[AGI][LIBERATION] Should use to strip enemy damage return (mirror vs mirror)")
            return true
        }

        return false
    }

    // Override offensive scenario for agility builds
    // Strategy: Apply CHIP_MIRROR/THORN damage return buff, then fight like strength builds
    createOffensiveScenario(target, targetHitCell) {
        // PRIORITY 1: Check for chest - if exists, switch target to chest immediately
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target from enemy to chest (ID: " + chest._id + ")")
            target = chest
            // Rebuild hit map for chest position
            fieldMap.buildHitMap(chest._cellPos)
            targetHitCell = fieldMap.getBestWeaponOrChipCell()
        }

        var playerPos = player._cellPos
        var playerMP = player._currMp
        var playerTP = player._currTp

        // Calculate distance to target for smart chip selection
        var distToTarget = getCellDistance(playerPos, target._cellPos)
        if (distToTarget == null) distToTarget = 99

        // AGGRESSIVE STRATEGY: Damage return FIRST (always maintain return buff for aggressive play)
        // STEP 1: Apply damage return buff (BRAMBLE in close combat, MIRROR/THORN when far)
        var returnChipApplied = false
        if (this.shouldReapplyReturnBuff()) {
            var chipToUse = this.selectBestReturnChip(distToTarget)
            if (chipToUse != -1) {
                var chipObj = arsenal.playerEquippedChips[chipToUse]
                debug("[AGILITY][AGGRESSIVE] Applying damage return chip: " + getChipName(chipToUse) + " (cost: " + chipObj._cost + " TP, dist: " + distToTarget + ")")
                this.createAttackAction(Action.ACTION_BUFF, player, -1, chipToUse)
                playerTP -= chipObj._cost
                returnChipApplied = true

                // Execute immediately so the buff is active for rest of turn planning
                this.executeAndFlushActions()
                player.updateEntity()
                debug("[AGILITY][AGGRESSIVE] Damage return buff applied and flushed, TP remaining: " + player._currTp)
            } else {
                debug("[AGILITY] WARNING: No return chip available (BRAMBLE/MIRROR/THORN on cooldown or insufficient TP)")
            }
        }

        // STEP 2: Apply CHIP_WARM_UP if enough TP remains (requires 14 TP after return chip)
        if (this.shouldUseWarmUp() && playerTP >= 14) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_WARM_UP)
            playerTP -= 7
            debug("[AGILITY] Applied CHIP_WARM_UP (+170-190 Agility for 3 turns, remaining TP: " + playerTP + ")")
        } else if (playerTP < 14) {
            debug("[AGILITY] Skipping WARM_UP - not enough TP for attacks after buff (have " + playerTP + " TP, need 14)")
        }

        // STEP 2.5: Apply WEAPON_NEUTRINO vulnerability debuff if not active (amplifies ALL damage)
        if (!target.hasVulnerability() && mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_NEUTRINO)) {
            var neutrinoWeapon = arsenal.playerEquippedWeapons[WEAPON_NEUTRINO]
            // distToTarget already defined above, reuse it
            if (distToTarget != null && distToTarget >= neutrinoWeapon._minRange && distToTarget <= neutrinoWeapon._maxRange) {
                if (playerTP >= neutrinoWeapon._cost) {
                    debug("[AGILITY][AGGRESSIVE] Applying WEAPON_NEUTRINO vulnerability debuff (dist=" + distToTarget + ", amplifies damage)")
                    // Use Neutrino to apply vulnerability - weapon swap + use happens in execution phase
                    // For now, just note that we should prioritize Neutrino in weapon spam
                    // This will be handled by weapon priority in executeWeaponFocusedOffensive
                }
            }
        }

        // STEP 3: Check for CHIP_LEATHER_BOOTS if target cell unreachable
        if (targetHitCell != -1 && targetHitCell != null && this.shouldUseLeatherBoots(targetHitCell._id)) {
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_LEATHER_BOOTS)
            playerTP -= 3
            playerMP += 2  // Immediate MP boost
            debug("[AGILITY] Applied CHIP_LEATHER_BOOTS (+2 MP for 2 turns)")
        }

        // STEP 4: Check for tactical CHIP_LIBERATION usage BEFORE combat
        if (this.shouldUseLiberation(target)) {
            // Use on enemy to remove their buffs, or on self to remove debuffs
            var liberationTarget = target._cellPos
            var hasPlayerDebuff = player.hasEffect(EFFECT_SHACKLE_TP) ||
                                 player.hasEffect(EFFECT_SHACKLE_STRENGTH) ||
                                 player.hasEffect(EFFECT_SHACKLE_MP) ||
                                 player.hasEffect(EFFECT_SHACKLE_AGILITY) ||
                                 player.hasEffect(EFFECT_POISON)

            if (hasPlayerDebuff) {
                liberationTarget = player._cellPos
                debug("[AGI] Using Liberation on self to remove debuffs")
            } else {
                debug("[AGI] Using Liberation on enemy to remove buffs/shields/damage return")
            }

            this.createAttackAction(Action.ACTION_BUFF, target, -1, CHIP_LIBERATION)
            // Update action with correct target cell
            this._actions[count(this._actions) - 1].targetCell = liberationTarget
            playerTP -= 5
        }

        // STEP 5: Select best tactical cell (hit-and-run: damage vs threat)
        // Agility builds leverage mobility to maximize damage while minimizing risk
        var tacticalCell = fieldMap.findBestTacticalCell(playerMP, 0.4)  // Threat weighted 40% (less risk-averse than magic)

        var bestWeaponCell = -1
        if (tacticalCell != null && tacticalCell != -1 && tacticalCell._highestDamageWeapon != -1) {
            bestWeaponCell = tacticalCell
            debug("[AGILITY][TACTICAL] Using threat-aware positioning: cell=" + tacticalCell._id + " damage=" + tacticalCell._totalDamage + " threat=" + fieldMap.getThreatAtCell(tacticalCell._id))
        } else {
            // Fallback: Select pure damage cell (legacy behavior)
            var bestWeaponDamage = -1
            var bestDist = 99999
            for (var c in fieldMap.damageMap) {
                if (c._highestDamageWeapon == -1) continue  // Skip chip-only cells
                var dist = getPathLength(playerPos, c._id)
                if (dist == null) continue  // Skip completely unreachable cells
                // Prefer higher weaponDamage, tie-break shorter distance
                if (c._weaponDamage > bestWeaponDamage || (c._weaponDamage == bestWeaponDamage && dist < bestDist)) {
                    bestWeaponDamage = c._weaponDamage
                    bestWeaponCell = c
                    bestDist = dist
                }
            }
            debug("[AGILITY][FALLBACK] Using pure damage cell (no tactical cell available)")
        }
        // Fallback to incoming targetHitCell if no weapon cell found
        if (bestWeaponCell == -1 && targetHitCell != -1 && targetHitCell != null) {
            bestWeaponCell = targetHitCell
        }
        if (bestWeaponCell == -1) {
            debug("[AGILITY] No valid weapon cell found, aborting offensive")
            return
        }

        // STEP 6: Check if CHIP_ADRENALINE can help with weapon spam
        if (this.shouldUseAdrenaline(playerTP + 4)) {  // Check if +4 TP would enable more attacks
            this.createAttackAction(Action.ACTION_BUFF, player, -1, CHIP_ADRENALINE)
            playerTP -= 1
            playerTP += 5  // Net gain of 4 TP
            debug("[AGILITY][ADRENALINE] Used Adrenaline, now have " + playerTP + " TP")
        }

        // STEP 7: Execute shared weapon-focused combat logic (exclude return damage chips, skip hide-and-seek for aggressive play)
        var result = this.executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, [CHIP_BRAMBLE, CHIP_MIRROR, CHIP_THORN], "AGILITY", true)

        // STEP 8: AGGRESSIVE SHIELD STACKING - Use leftover TP for WEAPON_SWORD (8% relative shield per use, stackable)
        playerTP = result['playerTP']
        playerMP = result['playerMP']

        if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_SWORD)) {
            var swordWeapon = arsenal.playerEquippedWeapons[WEAPON_SWORD]
            // Recalculate distance (player position might have changed after combat)
            distToTarget = getCellDistance(player._cellPos, target._cellPos)

            // Stack shields with WEAPON_SWORD if we have leftover TP
            if (distToTarget != null && distToTarget >= swordWeapon._minRange && distToTarget <= swordWeapon._maxRange) {
                var shieldsStacked = 0
                while (playerTP >= swordWeapon._cost && shieldsStacked < 3) {  // Max 3 stacks per turn
                    debug("[AGILITY][SHIELD-STACK] Using WEAPON_SWORD for defensive layering (8% shield, stack #" + (shieldsStacked + 1) + ")")
                    this.createAttackAction(Action.ACTION_DIRECT, target, swordWeapon._id, -1)
                    playerTP -= swordWeapon._cost
                    shieldsStacked++
                }
                if (shieldsStacked > 0) {
                    debug("[AGILITY][SHIELD-STACK] Stacked " + shieldsStacked + " shields (~" + (shieldsStacked * 8) + "% total), remaining TP: " + playerTP)
                }
            }
        }

        debug("[AGILITY] Offensive scenario complete. Remaining TP: " + playerTP + ", MP: " + playerMP)
        debug("[AGILITY] AGGRESSIVE MODE: Stay in combat range, no defensive retreat")
    }
}
