include('action.lk')
include('../weight_profiles.lk')
include('../strategic_depth.lk')
include('../beam_search_planner.lk')
include('../atomic_action_executor.lk')

class UnifiedStrategy extends Strategy {
    _weights = null
    _player = null
    _target = null
    _arsenal = null
    _turnContext = null

    constructor(weights, playerEntity, targetEntity, arsenalObj, fieldMapObj) {
        super()
        this._weights = weights
        this._player = playerEntity
        this._target = targetEntity
        this._arsenal = arsenalObj
        this._fieldMap = fieldMapObj

        this.initializeTurnContext()
    }

    initializeTurnContext() {
        this._turnContext = [
            'poisonRemaining': [],
            'antidoteUsed': false,
            'lastShieldChip': null,
            'baitMode': false,
            'lastReturnChip': null,
            'returnChipTurn': 0
        ]
    }

    resetTurnContext() {
        this.initializeTurnContext()
        debug("[UNIFIED] Turn context reset")
    }

    createAndExecuteScenario(target, targetHitCell) {
        arrayClear(this._actions)

        this._originalTP = player._currTp
        this._originalMP = player._currMp

        debug("[UNIFIED] Player TP=" + player._currTp + " MP=" + player._currMp + " at start of turn")
        debug("[UNIFIED] Using weight-driven scenario generation")

        startOp()
        this.generateAndEvaluateBestScenario(target, targetHitCell)
        stopOp("Unified Multi-Scenario Evaluation")

        this.executeScenario()
    }

    generateAndEvaluateBestScenario(target, targetHitCell) {
        // ===== BEAM SEARCH INTEGRATION (SESSION 3 - FINAL STATUS: DISABLED) =====
        var USE_BEAM_SEARCH = false
        var currentTurn = getTurn()

        // ROOT CAUSE IDENTIFIED: Turn 1 TP=2 (turnOneBuffs() pre-spends 23 TP), Turn 2+ TP=25 âœ“
        // TESTED: Hybrid approach (scenarios T1, beam search T2+) with full 25 TP
        // RESULT: 0% WR (0W-10L) - beam search still underperforms vs scenarios (80% WR)
        // CONCLUSION: Beam search architecture unsuitable for LeekWars domain
        var canUseBeamSearch = (USE_BEAM_SEARCH && currentTurn >= 2)

        debug("[BEAM-SEARCH-FLAG] USE_BEAM_SEARCH=" + USE_BEAM_SEARCH + " turn=" + currentTurn + " enabled=" + canUseBeamSearch)

        if (canUseBeamSearch) {
            debug("[BEAM-SEARCH] Using beam search planner...")
            var beamResult = this.executeWithBeamSearch(target)
            debug("[BEAM-SEARCH] executeWithBeamSearch returned: " + beamResult)
            if (beamResult) {
                debug("[BEAM-SEARCH] Beam search succeeded")
                return
            }
            debug("[BEAM-SEARCH] Beam search failed, falling back to scenarios")
        }
        // ===== END BEAM SEARCH INTEGRATION =====

        var generator = new ScenarioGenerator(
            arsenal,
            player,
            target,
            this._fieldMap,
            this
        )

        startOp()
        var scenarios = generator.generateScenarios()
        var genOps = stopOp("Generate scenarios (" + count(scenarios) + " total)")

        if (count(scenarios) == 0) {
            debug("[UNIFIED] No scenarios generated - creating fallback")
            this.createFallbackScenario(target, targetHitCell)
            return
        }

        var quickScorer = new ScenarioQuickScorer(player, target, this._fieldMap, arsenal)

        startOp()
        var scenariosWithQuickScore = []
        for (var scenario in scenarios) {
            var qScore = quickScorer.quickScore(scenario)
            push(scenariosWithQuickScore, ['scenario': scenario, 'quickScore': qScore])
        }

        arraySort(scenariosWithQuickScore, function(a, b) {
            return b['quickScore'] - a['quickScore']
        })

        var topK = 50  // Increased from 12 for deeper search
        var evaluateCount = min(topK, count(scenariosWithQuickScore))
        var quickOps = stopOp("Quick Score & Sort (" + count(scenariosWithQuickScore) + " -> top " + evaluateCount + ")")

        debug("[UNIFIED-TOP-K] Quick scored " + count(scenariosWithQuickScore) + " scenarios, evaluating top " + evaluateCount)

        // Phase 3: Adapt weights to current situation
        var enemies = this._fieldMap.getEnemySubMap()
        var adaptedWeights = adaptWeightsToSituation(this._weights, player, enemies, this._fieldMap)

        var simulator = new ScenarioSimulator(arsenal, player, target, this._fieldMap)
        var scorer = new ScenarioScorer(player, target, this._fieldMap, adaptedWeights)

        // Phase 3: Monte Carlo simulator (100 iterations for efficiency)
        var monteCarloSim = new MonteCarloSimulator(arsenal, player, target, 100)

        var bestScore = -999999
        var bestScenario = null
        var bestSimResult = null
        var scenarioResults = []

        startOp()
        for (var i = 0; i < evaluateCount; i++) {
            var scenarioData = scenariosWithQuickScore[i]
            var scenario = scenarioData['scenario']
            var qScore = scenarioData['quickScore']

            var simResult = simulator.simulate(scenario)
            var score = scorer.score(simResult, scenario)

            // Store scenario with simulation result for lookahead
            push(scenarioResults, [
                'scenario': scenario,
                'simResult': simResult,
                'score': score,
                'quickScore': qScore
            ])

            debug("[UNIFIED-TOP-K] Scenario #" + (i+1) + ": quickScore=" + floor(qScore) + " fullScore=" + floor(score))

            if (score > bestScore) {
                bestScore = score
                bestScenario = scenario
                bestSimResult = simResult
            }
        }
        var simOps = stopOp("Simulate & score top " + evaluateCount)

        // Phase 4: Enemy Response Lookahead (optimized: 1 scenario only)
        if (count(scenarioResults) >= 1 && getOperations() < 10000000) {
            startOp()
            arraySort(scenarioResults, function(a, b) {
                return b['score'] - a['score']
            })

            var predictor = new EnemyPredictor(this._fieldMap, arsenal, player, target)
            var lookaheadCount = min(1, count(scenarioResults))

            debug("[LOOKAHEAD] Evaluating top " + lookaheadCount + " scenario with enemy prediction")

            for (var i = 0; i < lookaheadCount; i++) {
                var scenarioData = scenarioResults[i]
                var simResult = scenarioData['simResult']

                // Create end state map for predictor (can't add fields to class instance)
                var endState = [
                    'endPosition': simResult.finalPosition,
                    'endHP': player._currHealth + simResult.hpGained,  // HP after heals
                    'endTP': player._currTp - simResult.tpSpent,
                    'score': scenarioData['score']
                ]

                var lookahead = predictor.evaluateScenarioWithLookahead(endState, 0.7)

                // Update score with lookahead
                scenarioData['finalScore'] = lookahead['finalScore']
                scenarioData['enemyDamage'] = lookahead['enemyDamage']

                debug("[LOOKAHEAD] Scenario #" + (i+1) + ": base=" + floor(scenarioData['score']) +
                          " final=" + floor(lookahead['finalScore']) +
                          " enemyDmg=" + lookahead['enemyDamage'])
            }

            // Re-evaluate best scenario with lookahead scores
            for (var i = 0; i < lookaheadCount; i++) {
                var scenarioData = scenarioResults[i]
                if (mapContainsKey(scenarioData, 'finalScore')) {
                    if (scenarioData['finalScore'] > bestScore) {
                        bestScore = scenarioData['finalScore']
                        bestScenario = scenarioData['scenario']
                        bestSimResult = scenarioData['simResult']
                    }
                }
            }

            var lookaheadOps = stopOp("Enemy Response Lookahead (top " + lookaheadCount + ")")
            debug("[LOOKAHEAD] Complete - " + lookaheadOps + " ops")
        }

        if (bestScenario != null) {
            debug("[UNIFIED-BEST] Selected scenario: score=" + floor(bestScore) +
                  " dmg=" + floor(bestSimResult.damageDealt) +
                  " dot=" + floor(bestSimResult.dotDamageQueued) +
                  " tp=" + bestSimResult.tpSpent + " mp=" + bestSimResult.mpSpent)

            this._actions = bestScenario
        } else {
            debug("[UNIFIED] No valid scenario found - creating fallback")
            this.createFallbackScenario(target, targetHitCell)
        }
    }

    createFallbackScenario(target, targetHitCell) {
        debug("[UNIFIED-FALLBACK] Creating basic offensive scenario")

        if (targetHitCell != null) {
            var pathLen = getCachedPathLength(player._cellPos, targetHitCell)
            if (pathLen != null && pathLen > 0 && player._currMp >= pathLen) {
                var action = new Action(Action.MOVEMENT_APPROACH, -1, -1, targetHitCell, null)
                push(this._actions, action)
                player._currMp -= pathLen
                debug("[UNIFIED-FALLBACK] Move to hit cell " + targetHitCell)
            }
        }

        var weaponIds = mapKeys(arsenal.playerEquippedWeapons)
        if (count(weaponIds) > 0) {
            var weaponId = weaponIds[0]
            var weapon = arsenal.playerEquippedWeapons[weaponId]

            if (weapon._cost <= player._currTp) {
                var action = new Action(Action.ACTION_DIRECT, weaponId, -1, target._cellPos, null)
                push(this._actions, action)
                player._currTp -= weapon._cost
                debug("[UNIFIED-FALLBACK] Attack with " + getWeaponName(weaponId))
            }
        }
    }

    turnOneBuffs() {
        debug("[UNIFIED] Calling base turn one HP buffs")
        super.turnOneBuffs()
    }

    shouldBuildDamageMap() {
        return true
    }

    // =========================================================================
    // BEAM SEARCH INTEGRATION (SESSION 1)
    // =========================================================================

    executeWithBeamSearch(target) {
        debug("[BEAM-SEARCH] Player TP=" + this._player._currTp + " MP=" + this._player._currMp + " before planner")
        debug("[BEAM-SEARCH] Creating planner...")
        var planner = new BeamSearchPlanner(this._arsenal, this._fieldMap, this._player, target)
        debug("[BEAM-SEARCH] Finding best sequence...")
        var actionSequence = planner.findBestSequence()
        debug("[BEAM-SEARCH] Sequence length: " + (actionSequence == null ? "null" : count(actionSequence)))
        if (actionSequence == null || count(actionSequence) == 0) {
            debug("[BEAM-SEARCH] No valid sequence found")
            return false
        }
        debug("[BEAM-SEARCH] Creating executor...")
        var executor = new AtomicActionExecutor(this._arsenal, this._fieldMap, this._player)
        debug("[BEAM-SEARCH] Executing " + count(actionSequence) + " actions...")
        var successCount = executor.execute(actionSequence)
        debug("[BEAM-SEARCH] Executed " + successCount + " actions")
        return successCount > 0
    }
}
