include('action.lk')
include('../weight_profiles.lk')
include('../strategic_depth.lk')
include('../scenario_mutation.lk')

class UnifiedStrategy extends Strategy {
    _weights = null
    _player = null
    _target = null
    _arsenal = null
    _turnContext = null

    constructor(weights, playerEntity, targetEntity, arsenalObj, fieldMapObj) {
        super()
        this._weights = weights
        this._player = playerEntity
        this._target = targetEntity
        this._arsenal = arsenalObj
        this._fieldMap = fieldMapObj

        this.initializeTurnContext()
    }

    initializeTurnContext() {
        this._turnContext = [
            'poisonRemaining': [],
            'antidoteUsed': false,
            'lastShieldChip': null,
            'baitMode': false,
            'lastReturnChip': null,
            'returnChipTurn': 0
        ]
    }

    resetTurnContext() {
        this.initializeTurnContext()
        debugInfo("[UNIFIED] Turn context reset")
    }

    createAndExecuteScenario(target, targetHitCell) {
        arrayClear(this._actions)

        this._originalTP = player._currTp
        this._originalMP = player._currMp

        debugInfo("[UNIFIED] Player TP=" + player._currTp + " MP=" + player._currMp + " at start of turn")
        debugInfo("[UNIFIED] Using weight-driven scenario generation")

        startOp()
        this.generateAndEvaluateBestScenario(target, targetHitCell)
        stopOp("Unified Multi-Scenario Evaluation")

        var targetDied = this.executeScenario()

        // If target died mid-scenario, recalculate for remaining enemies
        if (targetDied) {
            var enemies = this._fieldMap.getEnemySubMap()
            var aliveEnemies = []

            for (var eid in mapKeys(enemies)) {
                if (!isDead(eid)) {
                    push(aliveEnemies, enemies[eid])
                }
            }

            if (count(aliveEnemies) > 0) {

                // Update player state
                player.updateEntity()

                // Pick new target (closest or lowest HP)
                var newTarget = aliveEnemies[0]
                for (var i = 1; i < count(aliveEnemies); i++) {
                    var e = aliveEnemies[i]
                    if (e._currHealth < newTarget._currHealth) {
                        newTarget = e
                    }
                }

                var newTargetHitCell = newTarget._cellPos

                // Clear actions and regenerate
                arrayClear(this._actions)
                this.generateAndEvaluateBestScenario(newTarget, newTargetHitCell)
                this.executeScenario()
            } else {
            }
        }
    }

    generateAndEvaluateBestScenario(target, targetHitCell) {
        var generator = new ScenarioGenerator(
            arsenal,
            player,
            target,
            this._fieldMap,
            this
        )

        startOp()
        var scenarios = generator.generateScenarios()
        var genOps = stopOp("Generate scenarios (" + count(scenarios) + " total)")

        if (count(scenarios) == 0) {
            debugInfo("[UNIFIED] No scenarios generated - creating fallback")
            this.createFallbackScenario(target, targetHitCell)
            return
        }

        var quickScorer = new ScenarioQuickScorer(player, target, this._fieldMap, arsenal)

        startOp()
        var scenariosWithQuickScore = []
        for (var scenario in scenarios) {
            var qScore = quickScorer.quickScore(scenario)
            var family = quickScorer.classifyFamily(scenario)
            push(scenariosWithQuickScore, ['scenario': scenario, 'quickScore': qScore, 'family': family])
        }

        arraySort(scenariosWithQuickScore, function(a, b) {
            return b['quickScore'] - a['quickScore']
        })

        // Ensure diversity: guarantee at least 1 scenario per represented family in top-K
        var familySeen = [:]
        var diverseList = []
        var overflow = []
        for (var entry in scenariosWithQuickScore) {
            var fam = entry['family']
            if (!mapContainsKey(familySeen, fam)) {
                familySeen[fam] = true
                push(diverseList, entry)  // First of each family goes to front
            } else {
                push(overflow, entry)
            }
        }
        // Merge: family representatives first, then rest by score
        scenariosWithQuickScore = []
        for (var d in diverseList) push(scenariosWithQuickScore, d)
        for (var o in overflow) push(scenariosWithQuickScore, o)

        // Adaptive Top-K: scale evaluation depth based on game state
        var aliveEnemies = count(getAliveEnemies())
        var topK
        if (getTurn() < 5 || aliveEnemies > 3) {
            topK = 35  // Early game / Battle Royale: moderate search
        } else if (aliveEnemies == 1) {
            topK = 80  // 1v1 endgame: deep search
        } else {
            topK = 55  // Mid-game: balanced
        }
        // Ops budget checkpoint: reduce topK if already expensive
        if (getOperations() > 11000000) {
            topK = max(8, floor(topK * 0.5))
        }
        var evaluateCount = min(topK, count(scenariosWithQuickScore))
        var quickOps = stopOp("Quick Score & Sort (" + count(scenariosWithQuickScore) + " -> top " + evaluateCount + ")")

        debugInfo("[UNIFIED-TOP-K] Quick scored " + count(scenariosWithQuickScore) + " scenarios, evaluating top " + evaluateCount)

        // ===== PHASE 2: HYBRID MUTATION SYSTEM =====
        var USE_MUTATIONS = true  // Enable/disable mutation system
        var mutationOpsLimit = 12500000  // Only run if under 12.5M ops (1.5M safety margin)

        if (USE_MUTATIONS && getOperations() < mutationOpsLimit && count(scenariosWithQuickScore) >= 1) {
            debugInfo("[MUTATION] Starting hybrid mutation pass (ops=" + getOperations() + ")")

            // Adapt weights BEFORE mutation (needed by scorer)
            var enemies = this._fieldMap.getEnemySubMap()
            var adaptedWeights = adaptWeightsToSituation(this._weights, player, enemies, this._fieldMap)
            var scorer = new ScenarioScorer(player, target, this._fieldMap, adaptedWeights)

            // Extract top scenarios as mutation seeds
            var mutationSeeds = []
            var seedLimit = min(6, count(scenariosWithQuickScore))
            for (var i = 0; i < seedLimit; i++) {
                push(mutationSeeds, scenariosWithQuickScore[i]['scenario'])
            }

            startOp()
            var mutationPlanner = new HybridMutationPlanner(arsenal, player, target, this._fieldMap, scorer)
            var bestMutatedScenario = mutationPlanner.planWithMutations(mutationSeeds)
            var mutationOps = stopOp("Hybrid mutation pass")

            debugInfo("[MUTATION] Mutation pass complete, ops=" + mutationOps)

            // Replace scenarios with mutated result + originals
            scenariosWithQuickScore = []
            push(scenariosWithQuickScore, ['scenario': bestMutatedScenario, 'quickScore': 9999])

            // Keep top 3 originals as fallback
            var origLimit = min(3, seedLimit)
            for (var i = 0; i < origLimit; i++) {
                push(scenariosWithQuickScore, ['scenario': mutationSeeds[i], 'quickScore': 8000 - i * 100])
            }

            evaluateCount = count(scenariosWithQuickScore)
        }
        // ===== END PHASE 2: HYBRID MUTATION SYSTEM =====

        // Phase 3: Adapt weights to current situation
        var enemies = this._fieldMap.getEnemySubMap()
        var adaptedWeights = adaptWeightsToSituation(this._weights, player, enemies, this._fieldMap)

        var simulator = new ScenarioSimulator(arsenal, player, target, this._fieldMap)
        var scorer = new ScenarioScorer(player, target, this._fieldMap, adaptedWeights)

        var bestScore = -999999
        var bestScenario = null
        var bestSimResult = null
        var scenarioResults = []

        startOp()
        for (var i = 0; i < evaluateCount; i++) {
            var scenarioData = scenariosWithQuickScore[i]
            var scenario = scenarioData['scenario']
            var qScore = scenarioData['quickScore']

            var simResult = simulator.simulate(scenario)
            var score = scorer.score(simResult, scenario)

            // Store scenario with simulation result for lookahead
            push(scenarioResults, [
                'scenario': scenario,
                'simResult': simResult,
                'score': score,
                'quickScore': qScore
            ])

            debugInfo("[UNIFIED-TOP-K] Scenario #" + (i+1) + ": quickScore=" + floor(qScore) + " fullScore=" + floor(score))

            if (score > bestScore) {
                bestScore = score
                bestScenario = scenario
                bestSimResult = simResult
            }

            // Early-exit: if best is far ahead after 10+ evaluations, stop searching
            if (i >= 10 && (bestScore - score) > 2000) {
                debugInfo("[EARLY-EXIT] Score gap > 2000 after " + (i + 1) + " scenarios, executing best")
                break
            }

            // Ops budget hard stop: prevent timeout
            if (getOperations() > 13000000) {
                debugInfo("[BUDGET-EXIT] Ops > 13M after " + (i + 1) + " scenarios, executing best")
                break
            }
        }
        var simOps = stopOp("Simulate & score top " + evaluateCount)

        // Phase 4: Enemy Response Lookahead (top 3 scenarios)
        if (count(scenarioResults) >= 1 && getOperations() < 12500000) {
            startOp()
            arraySort(scenarioResults, function(a, b) {
                return b['score'] - a['score']
            })

            var predictor = new EnemyPredictor(this._fieldMap, arsenal, player, target)
            var lookaheadCount = min(3, count(scenarioResults))


            for (var i = 0; i < lookaheadCount; i++) {
                var scenarioData = scenarioResults[i]
                var simResult = scenarioData['simResult']

                // Create end state map for predictor (can't add fields to class instance)
                var endState = [
                    'endPosition': simResult.finalPosition,
                    'endHP': player._currHealth + simResult.hpGained,  // HP after heals
                    'endTP': player._currTp - simResult.tpSpent,
                    'score': scenarioData['score']
                ]

                var lookahead = predictor.evaluateScenarioWithLookahead(endState, 0.7)

                // Update score with lookahead
                scenarioData['finalScore'] = lookahead['finalScore']
                scenarioData['enemyDamage'] = lookahead['enemyDamage']

                debugDetail("[LOOKAHEAD] Scenario " + i + ":" +
                          " final=" + floor(lookahead['finalScore']) +
                          " enemyDmg=" + lookahead['enemyDamage'])
            }

            // Re-evaluate best scenario with lookahead scores
            for (var i = 0; i < lookaheadCount; i++) {
                var scenarioData = scenarioResults[i]
                if (mapContainsKey(scenarioData, 'finalScore')) {
                    if (scenarioData['finalScore'] > bestScore) {
                        bestScore = scenarioData['finalScore']
                        bestScenario = scenarioData['scenario']
                        bestSimResult = scenarioData['simResult']
                    }
                }
            }

            var lookaheadOps = stopOp("Enemy Response Lookahead (top " + lookaheadCount + ")")
        }

        // If best scenario does 0 damage, use fallback instead (unless it's purely defensive)
        if (bestScenario != null) {
            var isDamaging = bestSimResult.damageDealt > 0 || bestSimResult.dotDamageQueued > 0
            var isHealing = bestSimResult.hpGained > 0
            var usesResources = bestSimResult.tpSpent > 0 || bestSimResult.mpSpent > 0

            if (!isDamaging && !isHealing && usesResources && bestScore < 500) {
                debugInfo("[UNIFIED] Rejecting 0-value scenario (score=" + floor(bestScore) + ", no damage/healing) - using fallback")
                this.createFallbackScenario(target, targetHitCell)
            } else {
                debugInfo("[UNIFIED-BEST] Selected scenario: score=" + floor(bestScore) +
                      " dmg=" + floor(bestSimResult.damageDealt) +
                      " dot=" + floor(bestSimResult.dotDamageQueued) +
                      " tp=" + bestSimResult.tpSpent + " mp=" + bestSimResult.mpSpent)

                this._actions = bestScenario
            }
        } else {
            debugInfo("[UNIFIED] No valid scenario found - creating fallback")
            this.createFallbackScenario(target, targetHitCell)
        }
    }

    createFallbackScenario(target, targetHitCell) {
        debugInfo("[UNIFIED-FALLBACK] Creating basic offensive scenario")

        // Step 1: Move toward enemy - try hit cell first, then just approach
        var moved = false
        if (targetHitCell != null) {
            var pathLen = getCachedPathLength(player._cellPos, targetHitCell)
            if (pathLen != null && pathLen > 0 && player._currMp >= pathLen) {
                var action = new Action(Action.MOVEMENT_APPROACH, -1, -1, targetHitCell, null)
                push(this._actions, action)
                player._currMp -= pathLen
                moved = true
                debugInfo("[UNIFIED-FALLBACK] Move to hit cell " + targetHitCell)
            }
        }

        if (!moved && player._currMp > 0) {
            // No hit cell available or can't reach it - just walk toward enemy
            var action = new Action(Action.MOVEMENT_APPROACH, -1, -1, target._cellPos, null)
            push(this._actions, action)
            debugInfo("[UNIFIED-FALLBACK] Approaching enemy at cell " + target._cellPos)
        }

        // Step 2: Spam all available weapons/chips with remaining TP
        var weaponIds = mapKeys(arsenal.playerEquippedWeapons)

        // Find best weapon (highest net damage per TP)
        var bestWeaponId = null
        var bestWeaponDPS = 0
        for (var wid in weaponIds) {
            var w = arsenal.playerEquippedWeapons[wid]
            if (w._cost <= player._currTp) {
                var dmg = arsenal.getNetDamageAgainstTarget(
                    player._strength, player._magic, player._wisdom, player._science,
                    wid, target)
                var dps = dmg / w._cost
                if (dps > bestWeaponDPS) {
                    bestWeaponDPS = dps
                    bestWeaponId = wid
                }
            }
        }

        if (bestWeaponId != null) {
            var weapon = arsenal.playerEquippedWeapons[bestWeaponId]
            var uses = 0
            while (weapon._cost <= player._currTp && uses < weapon._maxUse) {
                var action = new Action(Action.ACTION_DIRECT, bestWeaponId, -1, target._cellPos, null)
                push(this._actions, action)
                player._currTp -= weapon._cost
                uses++
            }
            debugInfo("[UNIFIED-FALLBACK] Attack " + uses + "x with " + getWeaponName(bestWeaponId))
        }
    }

    turnOneBuffs() {
        debugInfo("[UNIFIED] Calling base turn one HP buffs")
        super.turnOneBuffs()
    }

    shouldBuildDamageMap() {
        return true
    }

}
