
class PoisonPlanner {
    
    static selectBestPoisonCell(target) {
        var verbosePlan = false  
        var bestCell = -1
        var bestAdjustedScore = -1
        var bestChips = []
        var bestWeapons = []
        var bestRemainingTP = -1
        var bestPathLen = 9999
        var playerPos = player._cellPos
        var mpAvail = player._currMp
        var tpAvail = player._currTp
        var penaltyNoWeaponFactor = 0.15

        var weaponPreferred = false
        var requireWeaponIfAvailable = true
        for (var preC in fieldMap.damageMap) {
            var pLen = getCachedPathLength(playerPos, preC._id)
            if (pLen == null || pLen > mpAvail) continue
            if (preC._weaponsList == null) continue
            for (var pw = 0; pw < count(preC._weaponsList); pw++) {
                var wPre = preC._weaponsList[pw]
                if (wPre == null) continue
                var bdPre = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, wPre._id)
                if (bdPre['dot'] <= 0) continue
                var swapNeedPre = (getWeapon() != wPre._id)
                var swapCostPre = swapNeedPre ? 1 : 0
                if (tpAvail <= swapCostPre) continue
                var maxUsePre = min(wPre._maxUse, floor((tpAvail - swapCostPre) / wPre._cost))
                if (maxUsePre <= 0) continue
                weaponPreferred = true
                break
            }
            if (weaponPreferred) break
        }
        debug("[DoT-KITE][PLAN] weaponPreferred=" + weaponPreferred)

        var stayHighDot = false
        if (mapContainsKey(fieldMap.damageMap, playerPos)) {
            var stayCell = fieldMap.damageMap[playerPos]
            if (stayCell._weaponsList != null) {
                for (var sw = 0; sw < count(stayCell._weaponsList); sw++) {
                    var swW = stayCell._weaponsList[sw]
                    if (swW == null) continue
                    var bdStay = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, swW._id)
                    if (bdStay['dot'] > 0) { stayHighDot = true; break }
                }
            }
        }

        for (var c in fieldMap.damageMap) {
            var pathLen = getCachedPathLength(playerPos, c._id)
            if (pathLen == null || pathLen > mpAvail) continue
            var score = 0
            var chipPlan = []
            var weaponPlan = []
            var remainingTP = tpAvail
            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] id=" + c._id + " pathLen=" + pathLen + " baseTP=" + remainingTP)

            var topPoisonChip = null
            var topPoisonDot = -1
            var topPoisonTotal = 0
            var topPoisonCost = 0
            if (c._chipsList != null) {
                for (var preLC = 0; preLC < count(c._chipsList); preLC++) {
                    var preChip = c._chipsList[preLC]
                    if (preChip == null) continue
                    var bdPreChip = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, preChip._id)
                    if (bdPreChip['dot'] <= 0) continue
                    if (bdPreChip['dot'] > topPoisonDot) {
                        topPoisonDot = bdPreChip['dot']
                        topPoisonChip = preChip
                        topPoisonTotal = bdPreChip['total']
                        topPoisonCost = preChip._cost
                    }
                }
            }

            if (c._weaponsList != null) {
                var localDotWeapons = []
                for (var lw = 0; lw < count(c._weaponsList); lw++) {
                    var wLoc = c._weaponsList[lw]
                    if (wLoc == null) continue
                    var bdLoc = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, wLoc._id)
                    if (bdLoc['dot'] <= 0) continue
                    push(localDotWeapons, ['weapon': wLoc, 'total': bdLoc['total'], 'bd': bdLoc])
                }

                for (var ii = 0; ii < count(localDotWeapons); ii++) {
                    var bestIdx = ii
                    for (var jj = ii + 1; jj < count(localDotWeapons); jj++) {
                        if (localDotWeapons[jj]['total'] > localDotWeapons[bestIdx]['total']) bestIdx = jj
                    }
                    if (bestIdx != ii) {
                        var tmp = localDotWeapons[ii]
                        localDotWeapons[ii] = localDotWeapons[bestIdx]
                        localDotWeapons[bestIdx] = tmp
                    }
                }

                for (var lw2 = 0; lw2 < count(localDotWeapons); lw2++) {
                    if (remainingTP <= 0) break
                    var recW = localDotWeapons[lw2]
                    var wDOT = recW['weapon']
                    var bdW2 = recW['bd']

                    if (!PoisonPlanner.inRangeAndLOS(c._id, target._cellPos, wDOT._minRange, wDOT._maxRange)) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipWeaponRange=" + getWeaponName(wDOT._id))
                        continue
                    }

                    var swapNeededW = (getWeapon() != wDOT._id)
                    var swapCostW = swapNeededW ? 1 : 0
                    if (remainingTP <= swapCostW) continue
                    var usableTP2 = remainingTP - swapCostW
                    var maxWeaponUses2 = min(wDOT._maxUse, floor(usableTP2 / wDOT._cost))
                    if (maxWeaponUses2 <= 0) continue

                    var hasPoisonChipAvailable = false
                    if (mapContainsKey(arsenal.playerEquippedChips, CHIP_COVID) && getCooldown(CHIP_COVID, player._id) == 0) {
                        hasPoisonChipAvailable = true
                    }
                    if (mapContainsKey(arsenal.playerEquippedChips, CHIP_PLAGUE) && getCooldown(CHIP_PLAGUE, player._id) == 0) {
                        hasPoisonChipAvailable = true
                    }
                    if (mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN) && getCooldown(CHIP_TOXIN, player._id) == 0) {
                        hasPoisonChipAvailable = true
                    }

                    if (hasPoisonChipAvailable && maxWeaponUses2 > 1) {
                        maxWeaponUses2 = 1
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] capWeaponUses=" + getWeaponName(wDOT._id))
                    }

                    if (topPoisonChip != null && topPoisonCost > 0) {
                        while (maxWeaponUses2 > 0 && (remainingTP - swapCostW - (maxWeaponUses2 * wDOT._cost)) < topPoisonCost) {
                            maxWeaponUses2 -= 1
                        }
                        if (maxWeaponUses2 == 0) {
                            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] reserveForChip skipWeapon=" + getWeaponName(wDOT._id))
                            continue
                        }
                    }

                    var weaponContribution2 = maxWeaponUses2 * bdW2['total']
                    score += weaponContribution2
                    push(weaponPlan, ['weapon': wDOT, 'swap': swapNeededW, 'uses': maxWeaponUses2])
                    remainingTP -= swapCostW + maxWeaponUses2 * wDOT._cost
                    if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] +Weapon " + getWeaponName(wDOT._id) + " uses=" + maxWeaponUses2 + " add=" + floor(weaponContribution2) + " TP_left=" + remainingTP)
                }
            }

            if (c._chipsList != null) {
                if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] Processing " + count(c._chipsList) + " chips, remainingTP=" + remainingTP)
                var localPoisonChips = []
                for (var lc = 0; lc < count(c._chipsList); lc++) {
                    var chipObj = c._chipsList[lc]
                    if (chipObj == null) continue
                    var bdChip = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, chipObj._id)
                    if (bdChip['dot'] <= 0) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] Skipping " + getChipName(chipObj._id) + " (no DoT)")
                        continue
                    }
                    push(localPoisonChips, ['chip': chipObj, 'total': bdChip['total'], 'bd': bdChip])
                    if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] Added " + getChipName(chipObj._id) + " to poison chips (dot=" + bdChip['dot'] + ")")
                }

                for (var ci = 0; ci < count(localPoisonChips); ci++) {
                    var bestIdxC = ci
                    for (var cj = ci + 1; cj < count(localPoisonChips); cj++) {
                        if (localPoisonChips[cj]['total'] > localPoisonChips[bestIdxC]['total']) bestIdxC = cj
                    }
                    if (bestIdxC != ci) {
                        var tmpC = localPoisonChips[ci]
                        localPoisonChips[ci] = localPoisonChips[bestIdxC]
                        localPoisonChips[bestIdxC] = tmpC
                    }
                }

                if (topPoisonChip != null && count(localPoisonChips) > 1) {
                    var topIndex = -1
                    for (var tpi = 0; tpi < count(localPoisonChips); tpi++) {
                        if (localPoisonChips[tpi]['chip']._id == topPoisonChip._id) { topIndex = tpi; break }
                    }
                    if (topIndex > 0) {
                        
                        var hold = localPoisonChips[topIndex]
                        localPoisonChips[topIndex] = localPoisonChips[0]
                        localPoisonChips[0] = hold
                    }
                }

                if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] Sorted " + count(localPoisonChips) + " poison chips, starting allocation with TP=" + remainingTP)
                for (var lpc = 0; lpc < count(localPoisonChips); lpc++) {
                    if (remainingTP <= 0) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] Breaking chip loop: no TP remaining")
                        break
                    }
                    var recC = localPoisonChips[lpc]
                    var pc = recC['chip']
                    if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] Evaluating " + getChipName(pc._id) + " cost=" + pc._cost + " TP=" + remainingTP + " CD=" + getCooldown(pc._id, player._id))
                    if (getCooldown(pc._id, player._id) > 0) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipCD=" + getChipName(pc._id))
                        continue
                    }
                    if (remainingTP < pc._cost) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipTP=" + getChipName(pc._id) + " need=" + pc._cost + " have=" + remainingTP)
                        continue
                    }

                    if (!PoisonPlanner.inRangeAndLOS(c._id, target._cellPos, pc._minRange, pc._maxRange)) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipGeometry=" + getChipName(pc._id) + " from=" + c._id + " to=" + target._cellPos)
                        continue
                    }

                    var bdC2 = recC['bd']
                    
                    var chipUses = 1
                    if (bdC2['dot'] > 0) {
                        
                        chipUses = 1
                    } else {
                        
                        chipUses = floor(remainingTP / pc._cost)
                    }

                    if (chipUses <= 0 || remainingTP < pc._cost) {
                        if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] skipChipZeroUses=" + getChipName(pc._id) + " (insufficient TP)")
                        continue
                    }

                    var chipContribution = chipUses * bdC2['total']
                    var chip = arsenal.playerEquippedChips[pc._id]
                    if (chip != null && chip._aoeType != AREA_POINT) {
                        
                        var aoeCells = fieldMap.getAoEAffectedCells(target._cellPos, chip._aoeType, c._id)
                        var wouldHitPlayer = false
                        for (var aIdx = 0; aIdx < count(aoeCells); aIdx++) {
                            if (aoeCells[aIdx] == c._id) {
                                wouldHitPlayer = true
                                break
                            }
                        }
                        if (wouldHitPlayer) {
                            
                            chipContribution = chipContribution * 0.05  
                            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] AoE penalty for " + getChipName(pc._id) + " from cell " + c._id + " (would self-damage)")
                        }
                    }

                    score += chipContribution
                    push(chipPlan, pc)
                    remainingTP -= chipUses * pc._cost
                    if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] +Chip " + getChipName(pc._id) + " uses=" + chipUses + " add=" + floor(chipContribution) + " TP_left=" + remainingTP)
                }
            }

            if (weaponPreferred && count(weaponPlan) == 0 && count(chipPlan) > 0) {
                var penaltySafe = score * 0.05  
                score -= penaltySafe
                if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] penaltyNoWeapon cell=" + c._id + " penalty=" + floor(penaltySafe))
            }

            if (verbosePlan) debug("[DoT-KITE][PLAN][CELL] finalScore=" + floor(score) + " chips=" + count(chipPlan) + " weapons=" + count(weaponPlan) + " TP_rem=" + remainingTP)
            if (verbosePlan && count(chipPlan) > 0) {
                var chipNames = ""
                for (var dbgC = 0; dbgC < count(chipPlan); dbgC++) {
                    chipNames += (dbgC > 0 ? ", " : "") + getChipName(chipPlan[dbgC]._id)
                }
                debug("[DoT-KITE][PLAN][CELL] Chips in plan: " + chipNames)
            }

            var distFactor = stayHighDot ? 7 : 5
            var distancePenalty = pathLen * distFactor
            var adjustedScore = score - distancePenalty

            if ((count(chipPlan) > 0 || (count(chipPlan) == 0 && count(weaponPlan) > 0))) {
                if (adjustedScore > bestAdjustedScore || (adjustedScore == bestAdjustedScore && pathLen < bestPathLen)) {
                    bestAdjustedScore = adjustedScore
                    bestCell = c
                    bestChips = chipPlan
                    bestWeapons = weaponPlan
                    bestRemainingTP = remainingTP
                    bestPathLen = pathLen
                    debug("[DoT-KITE][PLAN][BEST] cell=" + c._id + " rawScore=" + floor(score) + " adjScore=" + floor(adjustedScore) + " pathLen=" + pathLen + " penalty=" + distancePenalty + " stayHighDot=" + stayHighDot)
                }
            }
        }

        if (bestCell == -1) {
            if (verbosePlan) debug("[DoT-KITE][PLAN][FALLBACK] No cells within " + mpAvail + " MP, checking current position " + playerPos)
            if (mapContainsKey(fieldMap.damageMap, playerPos)) {
                var currCell = fieldMap.damageMap[playerPos]
                var currChipPlan = []
                var remainingTP = tpAvail

                if (currCell._chipsList != null) {
                    var localPoisonChips = []
                    for (var lc = 0; lc < count(currCell._chipsList); lc++) {
                        var chipObj = currCell._chipsList[lc]
                        if (chipObj == null) continue
                        var bdChip = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, chipObj._id)
                        if (bdChip['dot'] <= 0) continue
                        push(localPoisonChips, ['chip': chipObj, 'total': bdChip['total'], 'bd': bdChip])
                    }

                    for (var ii = 0; ii < count(localPoisonChips); ii++) {
                        var bestIdx = ii
                        for (var jj = ii + 1; jj < count(localPoisonChips); jj++) {
                            if (localPoisonChips[jj]['total'] > localPoisonChips[bestIdx]['total']) bestIdx = jj
                        }
                        if (bestIdx != ii) {
                            var tmp = localPoisonChips[ii]
                            localPoisonChips[ii] = localPoisonChips[bestIdx]
                            localPoisonChips[bestIdx] = tmp
                        }
                    }

                    for (var lpc = 0; lpc < count(localPoisonChips); lpc++) {
                        var rec = localPoisonChips[lpc]
                        var pc = rec['chip']
                        if (remainingTP < pc._cost) continue
                        if (getCooldown(pc._id, player._id) > 0) continue
                        
                        var dist = getCellDistance(playerPos, target._cellPos)
                        if (dist == null || dist < pc._minRange || dist > pc._maxRange) continue
                        if (!lineOfSight(playerPos, target._cellPos)) continue
                        push(currChipPlan, pc)
                        remainingTP -= pc._cost
                        if (verbosePlan) debug("[DoT-KITE][PLAN][FALLBACK] Added " + getChipName(pc._id) + " from current pos")
                    }
                }

                if (count(currChipPlan) > 0) {
                    if (verbosePlan) debug("[DoT-KITE][PLAN][FALLBACK] Using " + count(currChipPlan) + " chips from current position")
                    return ['cell': currCell, 'chips': currChipPlan, 'weapons': []]
                }
            }
            if (verbosePlan) debug("[DoT-KITE][PLAN][FALLBACK] No chips available from current position")
        }

        if (bestCell == -1) return null

        if (bestCell != null) {
            debug("[DoT-KITE][PLAN][CHOICE] cell=" + bestCell._id + " adjScore=" + floor(bestAdjustedScore) + " chips=" + count(bestChips) + " weapons=" + count(bestWeapons) + " pathLen=" + bestPathLen)

            var weaponSummary = ""
            if (bestCell._weaponsList != null) {
                for (var ws = 0; ws < count(bestCell._weaponsList); ws++) {
                    var wSum = bestCell._weaponsList[ws]
                    var bdWsum = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, wSum._id)
                    var usesPlan = 0
                    for (var pwL = 0; pwL < count(bestWeapons); pwL++) {
                        if (bestWeapons[pwL]['weapon']._id == wSum._id) { usesPlan = bestWeapons[pwL]['uses']; break }
                    }
                    weaponSummary += (ws > 0 ? ", " : "") + getWeaponName(wSum._id) + ":d=" + floor(bdWsum['direct']) + "/p=" + floor(bdWsum['dot']) + "/t=" + floor(bdWsum['total']) + (usesPlan > 0 ? "x" + usesPlan : "")
                }
            }

            var chipSummary = ""
            if (bestCell._chipsList != null) {
                for (var cs = 0; cs < count(bestCell._chipsList); cs++) {
                    var cSum = bestCell._chipsList[cs]
                    var bdCsum = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, cSum._id)
                    if (bdCsum['dot'] <= 0) {
                        chipSummary += (chipSummary != "" ? ", " : "") + getChipName(cSum._id) + "(no-dot d=" + floor(bdCsum['direct']) + ")"
                        continue
                    }
                    chipSummary += (chipSummary != "" ? ", " : "") + getChipName(cSum._id) + ":d=" + floor(bdCsum['direct']) + "/p=" + floor(bdCsum['dot']) + "/t=" + floor(bdCsum['total'])
                }
            }
            debug("[DoT-KITE][PLAN][CHOICE-DETAIL] cell=" + bestCell._id + " TP_rem_est=" + bestRemainingTP + " weapons={" + weaponSummary + "} chips={" + chipSummary + "}")
        } else {
            debug("[DoT-KITE][PLAN][CHOICE] bestCell null (no valid poison plan)")
        }

        return ['cell': bestCell, 'chips': bestChips, 'weapons': bestWeapons]
    }

    static inRangeAndLOS(fromCell, targetCell, minRange, maxRange) {
        var dist = getCellDistance(fromCell, targetCell)
        if (dist == null) return false
        if (dist < minRange || dist > maxRange) return false
        if (!lineOfSight(fromCell, targetCell)) return false
        return true
    }
}
