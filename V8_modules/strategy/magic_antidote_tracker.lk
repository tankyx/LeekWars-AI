include('action.lk')

// ====================================================================
// ANTIDOTE TRACKING SYSTEM
// ====================================================================
// Detects when enemies use CHIP_ANTIDOTE and adjusts poison strategy accordingly
// Bait mode: Use cheap poisons to force antidote usage
// Full offensive: Unleash all poisons after antidote is burned

class AntidoteTracker {
    // Static maps to persist across turns (enemy-focused state)
    static _prevPoisonRemaining = [:]        // enemyId -> previous remaining poison turns
    static _recentAntidoteTurn = [:]         // enemyId -> last turn we inferred antidote usage
    static _baitMode = [:]                   // enemyId -> bool (true = baiting, false = full offensive)

    // Chips allowed during bait mode (cheap poisons to force antidote)
    static isBaitAllowedChip(chipId) {
        // BAIT MODE: Only cheap chips to force antidote
        // CHIP_TOXIN: cheap poison bait (5 TP)
        // NOTE: PLAGUE and COVID saved for full offensive
        return chipId == CHIP_TOXIN
            || chipId == CHIP_FRACTURE
            || chipId == CHIP_BALL_AND_CHAIN
    }

    // Detect if antidote was used (poison cleared earlier than natural expiry)
    static inferAntidoteUse(enemyId, prevRemain, currRemain, wasPoisonedPrev, isPoisonedNow) {
        if (!wasPoisonedPrev) return false
        // Natural decay: remaining should be prevRemain-1 (>=0)
        // If poison vanished and prevRemain > 1 → cleanse
        if (wasPoisonedPrev && !isPoisonedNow && prevRemain > 1) return true
        // If still poisoned but remaining increased → cleanse + reapply
        if (isPoisonedNow && currRemain > prevRemain) return true
        return false
    }

    // Update antidote tracking state for enemy
    static updateAntidoteState(target) {
        var enemyId = target._id
        var poisonActive = target.hasEffect(EFFECT_POISON)
        var poisonRemaining = target.getEffectRemaining(EFFECT_POISON)
        var wasPoisonedPrev = mapContainsKey(AntidoteTracker._prevPoisonRemaining, enemyId) && AntidoteTracker._prevPoisonRemaining[enemyId] >= 0
        var prevRemain = wasPoisonedPrev ? AntidoteTracker._prevPoisonRemaining[enemyId] : -1
        var curTurn = getTurn()
        var antidoteCD = getCooldown(CHIP_ANTIDOTE, enemyId)
        var inferredUse = AntidoteTracker.inferAntidoteUse(enemyId, prevRemain, poisonRemaining, wasPoisonedPrev, poisonActive)

        // Check if enemy has antidote equipped
        var enemyHasAntidote = false
        var enemyChipsList = getChips(enemyId)
        if (enemyChipsList != null) {
            for (var ecIdx = 0; ecIdx < count(enemyChipsList); ecIdx++) {
                if (enemyChipsList[ecIdx] == CHIP_ANTIDOTE) { enemyHasAntidote = true; break }
            }
        }

        if (inferredUse) {
            AntidoteTracker._recentAntidoteTurn[enemyId] = curTurn
            AntidoteTracker._baitMode[enemyId] = false
            debug("[ANTIDOTE][DETECT] Early cleanse (prevRemaining=" + prevRemain + ") enemy=" + enemyId + " turn=" + curTurn)
        }

        if (!enemyHasAntidote) {
            AntidoteTracker._baitMode[enemyId] = false
            if (!inferredUse) debug("[ANTIDOTE][CHECK] enemy=" + enemyId + " has NO antidote -> disabling bait mode")
        } else {
            // Initialize bait mode only on first encounter
            if (!mapContainsKey(AntidoteTracker._baitMode, enemyId)) {
                AntidoteTracker._baitMode[enemyId] = true
                debug("[ANTIDOTE][INIT] enemy=" + enemyId + " has antidote -> entering bait mode")
            }
        }

        var baiting = AntidoteTracker._baitMode[enemyId]
        debug("[ANTIDOTE][STATE] enemy=" + enemyId + " baiting=" + baiting + " inferredUse=" + inferredUse + " cd=" + antidoteCD + " prevRemain=" + prevRemain)

        // Escalate out of bait mode if antidote is on cooldown
        if (baiting && antidoteCD > 0) {
            AntidoteTracker._baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Antidote on cooldown (cd=" + antidoteCD + ") -> full offensive")
        } else if (baiting && wasPoisonedPrev && !poisonActive && prevRemain > 0 && antidoteCD > 0) {
            AntidoteTracker._baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Cleanse + cooldown -> full offensive")
        } else if (baiting && prevRemain == 1 && !poisonActive) {
            if (!mapContainsKey(AntidoteTracker._recentAntidoteTurn, enemyId)) {
                AntidoteTracker._recentAntidoteTurn[enemyId] = curTurn
            } else if (curTurn - AntidoteTracker._recentAntidoteTurn[enemyId] >= 2) {
                AntidoteTracker._baitMode[enemyId] = false
                baiting = false
                debug("[ANTIDOTE][ESCALATE] Repeated natural expiry -> abandon bait mode")
            }
        }

        // Persist poison tracking
        if (poisonActive) AntidoteTracker._prevPoisonRemaining[enemyId] = poisonRemaining
        else AntidoteTracker._prevPoisonRemaining[enemyId] = -1

        return ['baiting': baiting, 'enemyHasAntidote': enemyHasAntidote]
    }

    // Bait offensive: cheap chips to force antidote
    static createBaitOffensive(target, poisonPlan, context, strategy) {
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']

        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (player._currTp < 1) break
                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    strategy.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }
                var usesW = wRec['uses']
                while (usesW > 0 && player._currTp >= wObj._cost) {
                    strategy.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                    player._currTp -= wObj._cost
                    usesW -= 1
                    willAttack = true
                }
            }

            // Only bait-allowed chips
            var chipsToUse = poisonPlan['chips']
            for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                var pc = chipsToUse[cidx]
                if (!AntidoteTracker.isBaitAllowedChip(pc._id)) continue
                if (player._currTp < pc._cost) break
                if (!strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, pc._minRange, pc._maxRange)) continue
                strategy.createAttackAction(Action.ACTION_DIRECT, target, -1, pc._id)
                player._currTp -= pc._cost
                willAttack = true
            }
        }

        // Bait chip: TOXIN
        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN)) {
            var toxinBait = arsenal.playerEquippedChips[CHIP_TOXIN]
            if (getCooldown(CHIP_TOXIN, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, toxinBait._minRange, toxinBait._maxRange)) {
                    var alreadyToxin = false
                    for (var aTox in strategy._actions) {
                        if (aTox.type == Action.ACTION_DIRECT && aTox.chip == CHIP_TOXIN) { alreadyToxin = true; break }
                    }
                    if (!alreadyToxin) {
                        strategy.createAttackAction(Action.ACTION_DIRECT, target, -1, CHIP_TOXIN)
                        player._currTp -= toxinBait._cost
                        willAttack = true
                        debug("[BAIT] Applied CHIP_TOXIN (5 TP)")
                    }
                }
            }
        }

        // Opportunistic debuffs
        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
            var bncBait = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
            if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, bncBait._minRange, bncBait._maxRange)) {
                    var alreadyBNC = false
                    for (var aBNC in strategy._actions) {
                        if (aBNC.type == Action.ACTION_DEBUFF && aBNC.chip == CHIP_BALL_AND_CHAIN) { alreadyBNC = true; break }
                    }
                    if (!alreadyBNC) {
                        strategy.createAttackAction(Action.ACTION_DEBUFF, target, -1, CHIP_BALL_AND_CHAIN)
                        player._currTp -= bncBait._cost
                        willAttack = true
                        debug("[BAIT][DEBUFF] Applied BALL_AND_CHAIN (5 TP)")
                    }
                }
            }
        }

        if (player._currTp >= 4 && mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
            var fracBait = arsenal.playerEquippedChips[CHIP_FRACTURE]
            if (getCooldown(CHIP_FRACTURE, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, fracBait._minRange, fracBait._maxRange)) {
                    var alreadyFRAC = false
                    for (var aFRAC in strategy._actions) {
                        if (aFRAC.type == Action.ACTION_DEBUFF && aFRAC.chip == CHIP_FRACTURE) { alreadyFRAC = true; break }
                    }
                    if (!alreadyFRAC) {
                        strategy.createAttackAction(Action.ACTION_DEBUFF, target, -1, CHIP_FRACTURE)
                        player._currTp -= fracBait._cost
                        willAttack = true
                        debug("[BAIT][DEBUFF] Applied FRACTURE (4 TP)")
                    }
                }
            }
        }

        context['plannedWeapon'] = plannedWeapon
        context['willAttack'] = willAttack
    }
}
