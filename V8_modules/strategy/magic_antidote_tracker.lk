include('action.lk')

class AntidoteTracker {
    
    static isBaitAllowedChip(chipId) {
        
        return chipId == CHIP_TOXIN
            || chipId == CHIP_PLAGUE
            || chipId == CHIP_ARSENIC
            || chipId == CHIP_FRACTURE
            || chipId == CHIP_BALL_AND_CHAIN
    }

    static inferAntidoteUse(enemyId, prevRemain, currRemain, wasPoisonedPrev, isPoisonedNow) {
        if (!wasPoisonedPrev) return false
        
        if (wasPoisonedPrev && !isPoisonedNow && prevRemain > 1) return true
        
        if (isPoisonedNow && currRemain > prevRemain) return true
        return false
    }

    static updateAntidoteState(target, prevPoisonRemaining, recentAntidoteTurn, baitMode, baitStartTurn) {
        var enemyId = target._id
        var poisonActive = target.hasEffect(EFFECT_POISON)
        var poisonRemaining = target.getEffectRemaining(EFFECT_POISON)
        var wasPoisonedPrev = mapContainsKey(prevPoisonRemaining, enemyId) && prevPoisonRemaining[enemyId] >= 0
        var prevRemain = wasPoisonedPrev ? prevPoisonRemaining[enemyId] : -1
        var curTurn = getTurn()
        var antidoteCD = getCooldown(CHIP_ANTIDOTE, enemyId)
        var inferredUse = AntidoteTracker.inferAntidoteUse(enemyId, prevRemain, poisonRemaining, wasPoisonedPrev, poisonActive)

        var enemyHasAntidote = false
        var enemyChipsList = getChips(enemyId)
        if (enemyChipsList != null) {
            for (var ecIdx = 0; ecIdx < count(enemyChipsList); ecIdx++) {
                if (enemyChipsList[ecIdx] == CHIP_ANTIDOTE) { enemyHasAntidote = true; break }
            }
        }

        if (inferredUse) {
            recentAntidoteTurn[enemyId] = curTurn
            baitMode[enemyId] = false
            debug("[ANTIDOTE][DETECT] Early cleanse (prevRemaining=" + prevRemain + ") enemy=" + enemyId + " turn=" + curTurn)
        }

        if (!enemyHasAntidote) {
            baitMode[enemyId] = false
            if (!inferredUse) debug("[ANTIDOTE][CHECK] enemy=" + enemyId + " has NO antidote -> disabling bait mode")
        } else {
            
            if (!mapContainsKey(baitMode, enemyId)) {
                baitMode[enemyId] = true
                baitStartTurn[enemyId] = curTurn
                debug("[ANTIDOTE][INIT] enemy=" + enemyId + " has antidote -> entering bait mode (turn=" + curTurn + ")")
            }
        }

        var baiting = baitMode[enemyId]
        var turnsBaiting = mapContainsKey(baitStartTurn, enemyId) ? (curTurn - baitStartTurn[enemyId]) : 0
        debug("[ANTIDOTE][STATE] enemy=" + enemyId + " baiting=" + baiting + " inferredUse=" + inferredUse + " cd=" + antidoteCD + " prevRemain=" + prevRemain + " turnsBaiting=" + turnsBaiting)

        if (baiting && antidoteCD > 0) {
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Antidote on cooldown (cd=" + antidoteCD + ") -> FULL OFFENSIVE MODE (aggressive combo enabled)")
        } else if (baiting && inferredUse) {
            
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Early cleanse detected (prevRemain=" + prevRemain + ") -> FULL OFFENSIVE MODE")
        } else if (baiting && wasPoisonedPrev && !poisonActive && prevRemain > 0 && antidoteCD > 0) {
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Cleanse + cooldown -> full offensive")
        } else if (baiting && prevRemain == 1 && !poisonActive) {
            if (!mapContainsKey(recentAntidoteTurn, enemyId)) {
                recentAntidoteTurn[enemyId] = curTurn
            } else if (curTurn - recentAntidoteTurn[enemyId] >= 2) {
                baitMode[enemyId] = false
                baiting = false
                debug("[ANTIDOTE][ESCALATE] Repeated natural expiry -> abandon bait mode")
            }
        } else if (baiting && turnsBaiting >= 4) {
            
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Baited for " + turnsBaiting + " turns, enemy not using antidote -> full offensive")
        }

        if (poisonActive) prevPoisonRemaining[enemyId] = poisonRemaining
        else prevPoisonRemaining[enemyId] = -1

        return ['baiting': baiting, 'enemyHasAntidote': enemyHasAntidote]
    }

    static createBaitOffensive(target, poisonPlan, context, strategy) {
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']

        var currHp = getLife()
        var maxHp = getTotalLife()
        var hpPercent = floor((currHp / maxHp) * 100)
        debug("[BAIT][SUSTAIN] HP check: " + currHp + "/" + maxHp + " (" + hpPercent + "%)")

        if (hpPercent < 30 && strategy.isChipAvailable(CHIP_REGENERATION, 8)) {
            debug("[BAIT][EMERGENCY] Using REGENERATION (HP=" + hpPercent + "%, TP=" + player._currTp + ")")
            push(strategy._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, player._cellPos, player))
            player._currTp -= 8
            willAttack = true
            
            strategy.executeAndFlushActions()
            player.updateEntity()
        }
        
        else if (hpPercent >= 40 && hpPercent <= 60 && strategy.isChipAvailable(CHIP_REMISSION, 5)) {
            debug("[BAIT][SUSTAIN] Using REMISSION (HP=" + hpPercent + "%, TP=" + player._currTp + ")")
            push(strategy._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, player._cellPos, player))
            player._currTp -= 5
            willAttack = true
            
            strategy.executeAndFlushActions()
            player.updateEntity()
        }

        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (player._currTp < 1) break
                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    strategy.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }
                
                var actualUses = 0
                while (actualUses < wObj._maxUse && player._currTp >= wObj._cost) {
                    strategy.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                    player._currTp -= wObj._cost
                    actualUses += 1
                    willAttack = true
                }
            }

            if (poisonPlan != null && count(poisonPlan['chips']) > 0) {
                var chipsToUse = poisonPlan['chips']
                var plannedCell = poisonPlan['cell']._id  
                debug("[BAIT] Using " + count(chipsToUse) + " chips from poison plan (TP=" + player._currTp + ") from cell=" + plannedCell)

                for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                    var pc = chipsToUse[cidx]
                    if (!AntidoteTracker.isBaitAllowedChip(pc._id)) continue
                    if (player._currTp < pc._cost) break

                    var inRange = false
                    if (pc._id == CHIP_ARSENIC) {
                        var distFromPlanned = getCellDistance(plannedCell, target._cellPos)
                        inRange = distFromPlanned != null && distFromPlanned >= pc._minRange && distFromPlanned <= pc._maxRange
                        if (!inRange) debug("[BAIT][SKIP] ARSENIC - out of range from planned cell (dist=" + distFromPlanned + ", need 3-4)")
                    } else {
                        inRange = strategy.inRangeAndLOS(plannedCell, target._cellPos, pc._minRange, pc._maxRange)
                        if (!inRange) debug("[BAIT][SKIP] " + getChipName(pc._id) + " - out of range/LOS from planned cell " + plannedCell)
                    }

                    if (!inRange) continue

                    var aoeBait = strategy.checkAoESafetyFromCell(pc._id, target._cellPos, plannedCell)
                    if (!aoeBait['safe'] && aoeBait['needsRepositioning']) {
                        debug("[BAIT][SKIP] " + getChipName(pc._id) + " - would hit player from planned cell " + plannedCell + ", trying from current position")

                        var aoeCurrent = strategy.checkAoESafety(pc._id, target._cellPos)

                        var inRangeFromCurrent = false
                        if (pc._id == CHIP_ARSENIC) {
                            var distFromCurrent = getCellDistance(player._cellPos, target._cellPos)
                            inRangeFromCurrent = distFromCurrent != null && distFromCurrent >= pc._minRange && distFromCurrent <= pc._maxRange
                        } else {
                            inRangeFromCurrent = strategy.inRangeAndLOS(player._cellPos, target._cellPos, pc._minRange, pc._maxRange)
                        }

                        if (aoeCurrent['safe'] && inRangeFromCurrent) {
                            debug("[BAIT] Using " + getChipName(pc._id) + " from CURRENT position IMMEDIATELY (planned cell unsafe)")
                            push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, pc._id, target._cellPos, target))
                            player._currTp -= pc._cost
                            willAttack = true
                            
                            strategy.executeAndFlushActions()
                            player.updateEntity()
                            debug("[BAIT] Executed " + getChipName(pc._id) + " from current position, remaining TP=" + player._currTp)
                        } else {
                            debug("[BAIT][SKIP] " + getChipName(pc._id) + " - also unsafe/out of range from current position")
                        }
                        continue
                    }

                    strategy.createAttackAction(Action.ACTION_DIRECT, target, -1, pc._id)
                    player._currTp -= pc._cost
                    willAttack = true
                    debug("[BAIT] Applied " + getChipName(pc._id) + " from plan (" + pc._cost + " TP)")
                }
            }
        }

        debug("[BAIT][AGGRESSIVE] Checking poison chips from current position (TP=" + player._currTp + ")")

        if (player._currTp >= 3 && mapContainsKey(arsenal.playerEquippedChips, CHIP_VENOM)) {
            var venomC = arsenal.playerEquippedChips[CHIP_VENOM]
            if (getCooldown(CHIP_VENOM, player._id) == 0) {
                if (strategy.inRangeAndLOS(player._cellPos, target._cellPos, venomC._minRange, venomC._maxRange)) {
                    
                    debug("[BAIT][AGGRESSIVE] Using VENOM (non-AoE, safe at close range)")
                    push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_VENOM, target._cellPos, target))
                    player._currTp -= 3
                    willAttack = true
                    
                    strategy.executeAndFlushActions()
                    player.updateEntity()
                    debug("[BAIT][AGGRESSIVE] Applied VENOM (3 TP)")
                }
            }
        }

        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ARSENIC)) {
            var arsenicBait = arsenal.playerEquippedChips[CHIP_ARSENIC]
            var arsenicCD = getCooldown(CHIP_ARSENIC, player._id)

            var arsenicStacks = arsenicCD == 0 ? 2 : 0
            while (arsenicStacks > 0 && player._currTp >= arsenicBait._cost) {
                var dist = getCellDistance(player._cellPos, target._cellPos)
                if (dist != null && dist >= arsenicBait._minRange && dist <= arsenicBait._maxRange) {
                    push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_ARSENIC, target._cellPos, target))
                    player._currTp -= arsenicBait._cost
                    willAttack = true
                    arsenicStacks--
                    debug("[BAIT][AGGRESSIVE] Applied ARSENIC stack (through obstacles, 8 TP) - remaining stacks: " + arsenicStacks)
                    
                    strategy.executeAndFlushActions()
                    player.updateEntity()
                } else {
                    debug("[BAIT][AGGRESSIVE] ARSENIC out of range (dist=" + dist + ", need 3-4)")
                    break
                }
            }
        }

        if (player._currTp >= 6 && mapContainsKey(arsenal.playerEquippedChips, CHIP_PLAGUE)) {
            var plagueC = arsenal.playerEquippedChips[CHIP_PLAGUE]
            if (getCooldown(CHIP_PLAGUE, player._id) == 0) {
                
                var hasDirectLOS = strategy.inRangeAndLOS(player._cellPos, target._cellPos, plagueC._minRange, plagueC._maxRange)
                var plagueTargetCell = target._cellPos

                if (!hasDirectLOS) {
                    var splashResult = strategy.findAoESplashCell(CHIP_PLAGUE, target._cellPos)
                    if (splashResult != null) {
                        plagueTargetCell = splashResult['cell']
                        hasDirectLOS = true  
                        debug("[BAIT][AGGRESSIVE] Using AoE splash for PLAGUE (target=" + plagueTargetCell + " to hit enemy at " + target._cellPos + ")")
                    }
                }

                if (hasDirectLOS) {
                    var aoePlague = strategy.checkAoESafety(CHIP_PLAGUE, plagueTargetCell)
                    if (!aoePlague['safe'] && aoePlague['needsRepositioning']) {
                        var safeCellPlague = strategy.findSafeCellForAoE(CHIP_PLAGUE, plagueTargetCell)
                        if (safeCellPlague != -1 && player._currMp > 0) {
                            debug("[BAIT][AGGRESSIVE-REPOSITION] Moving to safe cell " + safeCellPlague + " for PLAGUE")
                            strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellPlague, target)
                            strategy.executeAndFlushActions()
                            player.updateEntity()
                        } else {
                            debug("[BAIT][AGGRESSIVE-SKIP] PLAGUE - no safe cell found")
                            aoePlague = ['safe': false]
                        }
                    }
                    if (aoePlague['safe'] || aoePlague['needsRepositioning']) {
                        
                        push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_PLAGUE, plagueTargetCell, target))
                        player._currTp -= 6
                        willAttack = true
                        debug("[BAIT][AGGRESSIVE] Applied PLAGUE (6 TP) targeting cell " + plagueTargetCell)
                    }
                }
            }
        }

        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN)) {
            var toxinC = arsenal.playerEquippedChips[CHIP_TOXIN]
            if (getCooldown(CHIP_TOXIN, player._id) == 0) {
                if (strategy.inRangeAndLOS(player._cellPos, target._cellPos, toxinC._minRange, toxinC._maxRange)) {
                    var aoeToxin = strategy.checkAoESafety(CHIP_TOXIN, target._cellPos)
                    if (!aoeToxin['safe'] && aoeToxin['needsRepositioning']) {
                        var safeCellToxin = strategy.findSafeCellForAoE(CHIP_TOXIN, target._cellPos)
                        if (safeCellToxin != -1 && player._currMp > 0) {
                            debug("[BAIT][AGGRESSIVE-REPOSITION] Moving to safe cell " + safeCellToxin + " for TOXIN")
                            strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellToxin, target)
                            strategy.executeAndFlushActions()
                            player.updateEntity()
                        } else {
                            debug("[BAIT][AGGRESSIVE-SKIP] TOXIN - no safe cell found")
                            aoeToxin = ['safe': false]
                        }
                    }
                    if (aoeToxin['safe'] || aoeToxin['needsRepositioning']) {
                        strategy.createAttackAction(Action.ACTION_DIRECT, target, -1, CHIP_TOXIN)
                        player._currTp -= 5
                        willAttack = true
                        debug("[BAIT][AGGRESSIVE] Applied TOXIN (5 TP)")
                    }
                }
            }
        }

        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
            var bncBait = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
            if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, bncBait._minRange, bncBait._maxRange)) {
                    var alreadyBNC = false
                    for (var aBNC in strategy._actions) {
                        if (aBNC.type == Action.ACTION_DEBUFF && aBNC.chip == CHIP_BALL_AND_CHAIN) { alreadyBNC = true; break }
                    }
                    if (!alreadyBNC) {
                        var skipBNC = false
                        
                        var aoeBNC = strategy.checkAoESafety(CHIP_BALL_AND_CHAIN, target._cellPos)
                        if (!aoeBNC['safe'] && aoeBNC['needsRepositioning']) {
                            var safeCellBNC = strategy.findSafeCellForAoE(CHIP_BALL_AND_CHAIN, target._cellPos)
                            if (safeCellBNC != -1 && player._currMp > 0) {
                                debug("[BAIT][BNC-REPOSITION] Moving to safe cell " + safeCellBNC)
                                strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellBNC, target)
                                strategy.executeAndFlushActions()
                                player.updateEntity()
                                targetHitCell = context['targetHitCell']
                            } else {
                                debug("[BAIT] BNC skipped - no safe cell")
                                skipBNC = true
                            }
                        }

                        if (!skipBNC && strategy.inRangeAndLOS(player._cellPos, target._cellPos, bncBait._minRange, bncBait._maxRange)) {
                            strategy.createAttackAction(Action.ACTION_DEBUFF, target, -1, CHIP_BALL_AND_CHAIN)
                            player._currTp -= bncBait._cost
                            willAttack = true
                            debug("[BAIT][DEBUFF] Applied BALL_AND_CHAIN (5 TP)")
                        }
                    }
                }
            }
        }

        if (player._currTp >= 4 && mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
            var fracBait = arsenal.playerEquippedChips[CHIP_FRACTURE]
            if (getCooldown(CHIP_FRACTURE, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, fracBait._minRange, fracBait._maxRange)) {
                    var alreadyFRAC = false
                    for (var aFRAC in strategy._actions) {
                        if (aFRAC.type == Action.ACTION_DEBUFF && aFRAC.chip == CHIP_FRACTURE) { alreadyFRAC = true; break }
                    }
                    if (!alreadyFRAC) {
                        var skipFRAC = false
                        
                        var aoeFRAC = strategy.checkAoESafety(CHIP_FRACTURE, target._cellPos)
                        if (!aoeFRAC['safe'] && aoeFRAC['needsRepositioning']) {
                            var safeCellFRAC = strategy.findSafeCellForAoE(CHIP_FRACTURE, target._cellPos)
                            if (safeCellFRAC != -1 && player._currMp > 0) {
                                debug("[BAIT][FRACTURE-REPOSITION] Moving to safe cell " + safeCellFRAC)
                                strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellFRAC, target)
                                strategy.executeAndFlushActions()
                                player.updateEntity()
                                targetHitCell = context['targetHitCell']
                            } else {
                                debug("[BAIT] FRACTURE skipped - no safe cell")
                                skipFRAC = true
                            }
                        }

                        if (!skipFRAC && strategy.inRangeAndLOS(player._cellPos, target._cellPos, fracBait._minRange, fracBait._maxRange)) {
                            strategy.createAttackAction(Action.ACTION_DEBUFF, target, -1, CHIP_FRACTURE)
                            player._currTp -= fracBait._cost
                            willAttack = true
                            debug("[BAIT][DEBUFF] Applied FRACTURE (4 TP)")
                        }
                    }
                }
            }
        }

        context['plannedWeapon'] = plannedWeapon
        context['willAttack'] = willAttack
    }
}
