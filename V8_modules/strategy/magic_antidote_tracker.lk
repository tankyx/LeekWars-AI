include('action.lk')

// ====================================================================
// ANTIDOTE TRACKING SYSTEM
// ====================================================================
// Detects when enemies use CHIP_ANTIDOTE and adjusts poison strategy accordingly
// Bait mode: Use cheap poisons to force antidote usage
// Full offensive: Unleash all poisons after antidote is burned

class AntidoteTracker {
    // NOTE: State is now managed by MagicStrategy instance variables
    // All methods accept state maps as parameters to avoid cross-fight pollution

    // Chips allowed during bait mode (poisons to force antidote)
    static isBaitAllowedChip(chipId) {
        // BAIT MODE: Use strong poisons to force antidote usage
        // CHIP_TOXIN: cheap poison bait (5 TP, ~567 damage)
        // CHIP_PLAGUE: strong poison bait (6 TP, ~1134 damage)
        // CHIP_ARSENIC: stackable poison bait (8 TP, 62-67 × 2 turns, STACKABLE)
        // NOTE: COVID reserved for combo only
        return chipId == CHIP_TOXIN
            || chipId == CHIP_PLAGUE
            || chipId == CHIP_ARSENIC
            || chipId == CHIP_FRACTURE
            || chipId == CHIP_BALL_AND_CHAIN
    }

    // Detect if antidote was used (poison cleared earlier than natural expiry)
    static inferAntidoteUse(enemyId, prevRemain, currRemain, wasPoisonedPrev, isPoisonedNow) {
        if (!wasPoisonedPrev) return false
        // Natural decay: remaining should be prevRemain-1 (>=0)
        // If poison vanished and prevRemain > 1 → cleanse
        if (wasPoisonedPrev && !isPoisonedNow && prevRemain > 1) return true
        // If still poisoned but remaining increased → cleanse + reapply
        if (isPoisonedNow && currRemain > prevRemain) return true
        return false
    }

    // Update antidote tracking state for enemy
    // Accepts state maps as parameters (managed by MagicStrategy instance)
    static updateAntidoteState(target, prevPoisonRemaining, recentAntidoteTurn, baitMode, baitStartTurn) {
        var enemyId = target._id
        var poisonActive = target.hasEffect(EFFECT_POISON)
        var poisonRemaining = target.getEffectRemaining(EFFECT_POISON)
        var wasPoisonedPrev = mapContainsKey(prevPoisonRemaining, enemyId) && prevPoisonRemaining[enemyId] >= 0
        var prevRemain = wasPoisonedPrev ? prevPoisonRemaining[enemyId] : -1
        var curTurn = getTurn()
        var antidoteCD = getCooldown(CHIP_ANTIDOTE, enemyId)
        var inferredUse = AntidoteTracker.inferAntidoteUse(enemyId, prevRemain, poisonRemaining, wasPoisonedPrev, poisonActive)

        // Check if enemy has antidote equipped
        var enemyHasAntidote = false
        var enemyChipsList = getChips(enemyId)
        if (enemyChipsList != null) {
            for (var ecIdx = 0; ecIdx < count(enemyChipsList); ecIdx++) {
                if (enemyChipsList[ecIdx] == CHIP_ANTIDOTE) { enemyHasAntidote = true; break }
            }
        }

        if (inferredUse) {
            recentAntidoteTurn[enemyId] = curTurn
            baitMode[enemyId] = false
            debug("[ANTIDOTE][DETECT] Early cleanse (prevRemaining=" + prevRemain + ") enemy=" + enemyId + " turn=" + curTurn)
        }

        if (!enemyHasAntidote) {
            baitMode[enemyId] = false
            if (!inferredUse) debug("[ANTIDOTE][CHECK] enemy=" + enemyId + " has NO antidote -> disabling bait mode")
        } else {
            // Initialize bait mode only on first encounter
            if (!mapContainsKey(baitMode, enemyId)) {
                baitMode[enemyId] = true
                baitStartTurn[enemyId] = curTurn
                debug("[ANTIDOTE][INIT] enemy=" + enemyId + " has antidote -> entering bait mode (turn=" + curTurn + ")")
            }
        }

        var baiting = baitMode[enemyId]
        var turnsBaiting = mapContainsKey(baitStartTurn, enemyId) ? (curTurn - baitStartTurn[enemyId]) : 0
        debug("[ANTIDOTE][STATE] enemy=" + enemyId + " baiting=" + baiting + " inferredUse=" + inferredUse + " cd=" + antidoteCD + " prevRemain=" + prevRemain + " turnsBaiting=" + turnsBaiting)

        // Escalate out of bait mode when:
        // 1. Antidote detected on cooldown (enemy used it) - MOST RELIABLE CHECK
        // 2. Cleanse detected via inferAntidoteUse()
        // 3. Repeated natural expiry (enemy letting poison expire)
        // 4. Too many turns in bait mode (enemy not reacting - give up)

        // PRIORITY 1: Antidote cooldown check (reliable, works even with poison tracking timing issues)
        if (baiting && antidoteCD > 0) {
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Antidote on cooldown (cd=" + antidoteCD + ") -> FULL OFFENSIVE MODE (aggressive combo enabled)")
        } else if (baiting && inferredUse) {
            // PRIORITY 2: Early cleanse detected via poison tracking
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Early cleanse detected (prevRemain=" + prevRemain + ") -> FULL OFFENSIVE MODE")
        } else if (baiting && wasPoisonedPrev && !poisonActive && prevRemain > 0 && antidoteCD > 0) {
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Cleanse + cooldown -> full offensive")
        } else if (baiting && prevRemain == 1 && !poisonActive) {
            if (!mapContainsKey(recentAntidoteTurn, enemyId)) {
                recentAntidoteTurn[enemyId] = curTurn
            } else if (curTurn - recentAntidoteTurn[enemyId] >= 2) {
                baitMode[enemyId] = false
                baiting = false
                debug("[ANTIDOTE][ESCALATE] Repeated natural expiry -> abandon bait mode")
            }
        } else if (baiting && turnsBaiting >= 4) {
            // Give up on baiting after 4 turns if enemy isn't reacting
            baitMode[enemyId] = false
            baiting = false
            debug("[ANTIDOTE][ESCALATE] Baited for " + turnsBaiting + " turns, enemy not using antidote -> full offensive")
        }

        // Persist poison tracking
        if (poisonActive) prevPoisonRemaining[enemyId] = poisonRemaining
        else prevPoisonRemaining[enemyId] = -1

        return ['baiting': baiting, 'enemyHasAntidote': enemyHasAntidote]
    }

    // Bait offensive: cheap chips to force antidote
    static createBaitOffensive(target, poisonPlan, context, strategy) {
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']

        // PRIORITY 0: HP-based healing (sustain)
        var currHp = getLife()
        var maxHp = getTotalLife()
        var hpPercent = floor((currHp / maxHp) * 100)
        debug("[BAIT][SUSTAIN] HP check: " + currHp + "/" + maxHp + " (" + hpPercent + "%)")

        // REGENERATION: Emergency heal for HP < 30% (500+ HP over 5 turns)
        if (hpPercent < 30 && strategy.isChipAvailable(CHIP_REGENERATION, 8)) {
            debug("[BAIT][EMERGENCY] Using REGENERATION (HP=" + hpPercent + "%, TP=" + player._currTp + ")")
            push(strategy._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, player._cellPos, player))
            player._currTp -= 8
            willAttack = true
            // Execute immediately so state is updated
            strategy.executeAndFlushActions()
            player.updateEntity()
        }
        // REMISSION: Mid-HP sustain for 40% < HP < 60% (~120 HP instant, 5 TP)
        else if (hpPercent >= 40 && hpPercent <= 60 && strategy.isChipAvailable(CHIP_REMISSION, 5)) {
            debug("[BAIT][SUSTAIN] Using REMISSION (HP=" + hpPercent + "%, TP=" + player._currTp + ")")
            push(strategy._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, player._cellPos, player))
            player._currTp -= 5
            willAttack = true
            // Execute immediately so state is updated
            strategy.executeAndFlushActions()
            player.updateEntity()
        }

        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (player._currTp < 1) break
                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    strategy.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }
                // Spam weapon to max uses (ignore plan's conservative 'uses' value)
                var actualUses = 0
                while (actualUses < wObj._maxUse && player._currTp >= wObj._cost) {
                    strategy.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                    player._currTp -= wObj._cost
                    actualUses += 1
                    willAttack = true
                }
            }

            // Use chips from poison plan if available
            // IMPORTANT: Poison plan cell has already been moved to, so check AoE from TARGET cell, not current
            if (poisonPlan != null && count(poisonPlan['chips']) > 0) {
                var chipsToUse = poisonPlan['chips']
                var plannedCell = poisonPlan['cell']._id  // Cell where we'll be attacking from
                debug("[BAIT] Using " + count(chipsToUse) + " chips from poison plan (TP=" + player._currTp + ") from cell=" + plannedCell)

                for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                    var pc = chipsToUse[cidx]
                    if (!AntidoteTracker.isBaitAllowedChip(pc._id)) continue
                    if (player._currTp < pc._cost) break

                    // Check range from PLANNED cell (where we'll be after movement), not current position
                    if (!strategy.inRangeAndLOS(plannedCell, target._cellPos, pc._minRange, pc._maxRange)) {
                        debug("[BAIT][SKIP] " + getChipName(pc._id) + " - out of range from planned cell " + plannedCell)
                        continue
                    }

                    // Check AoE safety from PLANNED cell (critical: must check from attack position, not current)
                    var aoeBait = strategy.checkAoESafetyFromCell(pc._id, target._cellPos, plannedCell)
                    if (!aoeBait['safe'] && aoeBait['needsRepositioning']) {
                        debug("[BAIT][SKIP] " + getChipName(pc._id) + " - would hit player from planned cell " + plannedCell + ", trying from current position")

                        // Fallback: try using chip from CURRENT position instead of planned cell
                        // CRITICAL: Must execute IMMEDIATELY before any movement happens
                        var aoeCurrent = strategy.checkAoESafety(pc._id, target._cellPos)
                        if (aoeCurrent['safe'] && strategy.inRangeAndLOS(player._cellPos, target._cellPos, pc._minRange, pc._maxRange)) {
                            debug("[BAIT] Using " + getChipName(pc._id) + " from CURRENT position IMMEDIATELY (planned cell unsafe)")
                            push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, pc._id, target._cellPos, target))
                            player._currTp -= pc._cost
                            willAttack = true
                            // Execute NOW before movement to planned cell
                            strategy.executeAndFlushActions()
                            player.updateEntity()
                            debug("[BAIT] Executed " + getChipName(pc._id) + " from current position, remaining TP=" + player._currTp)
                        } else {
                            debug("[BAIT][SKIP] " + getChipName(pc._id) + " - also unsafe from current position")
                        }
                        continue
                    }

                    strategy.createAttackAction(Action.ACTION_DIRECT, target, -1, pc._id)
                    player._currTp -= pc._cost
                    willAttack = true
                    debug("[BAIT] Applied " + getChipName(pc._id) + " from plan (" + pc._cost + " TP)")
                }
            }
        }

        // AGGRESSIVE BAIT: Use poison chips from current position (when no plan available)
        debug("[BAIT][AGGRESSIVE] Checking poison chips from current position (TP=" + player._currTp + ")")

        // PRIORITY: Non-AoE poison chips (VENOM) when close-range (safer than PLAGUE/TOXIN)
        if (player._currTp >= 3 && mapContainsKey(arsenal.playerEquippedChips, CHIP_VENOM)) {
            var venomC = arsenal.playerEquippedChips[CHIP_VENOM]
            if (getCooldown(CHIP_VENOM, player._id) == 0) {
                if (strategy.inRangeAndLOS(player._cellPos, target._cellPos, venomC._minRange, venomC._maxRange)) {
                    // VENOM is non-AoE (AREA_POINT), so always safe from self-damage
                    debug("[BAIT][AGGRESSIVE] Using VENOM (non-AoE, safe at close range)")
                    push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_VENOM, target._cellPos, target))
                    player._currTp -= 3
                    willAttack = true
                    // Execute immediately to ensure it happens before movement
                    strategy.executeAndFlushActions()
                    player.updateEntity()
                    debug("[BAIT][AGGRESSIVE] Applied VENOM (3 TP)")
                }
            }
        }

        // CHIP_ARSENIC: Stackable poison through obstacles (excellent for bait mode)
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ARSENIC)) {
            var arsenicBait = arsenal.playerEquippedChips[CHIP_ARSENIC]
            var arsenicCD = getCooldown(CHIP_ARSENIC, player._id)

            // Stack ARSENIC up to 2 times during bait mode (force antidote with stacked poison)
            var arsenicStacks = arsenicCD == 0 ? 2 : 0
            while (arsenicStacks > 0 && player._currTp >= arsenicBait._cost) {
                var dist = getCellDistance(player._cellPos, target._cellPos)
                if (dist != null && dist >= arsenicBait._minRange && dist <= arsenicBait._maxRange) {
                    push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_ARSENIC, target._cellPos, target))
                    player._currTp -= arsenicBait._cost
                    willAttack = true
                    arsenicStacks--
                    debug("[BAIT][AGGRESSIVE] Applied ARSENIC stack (through obstacles, 8 TP) - remaining stacks: " + arsenicStacks)
                    // Execute immediately
                    strategy.executeAndFlushActions()
                    player.updateEntity()
                } else {
                    debug("[BAIT][AGGRESSIVE] ARSENIC out of range (dist=" + dist + ", need 3-4)")
                    break
                }
            }
        }

        // AoE poison chips (PLAGUE, TOXIN) - use only when safe or splash-able
        if (player._currTp >= 6 && mapContainsKey(arsenal.playerEquippedChips, CHIP_PLAGUE)) {
            var plagueC = arsenal.playerEquippedChips[CHIP_PLAGUE]
            if (getCooldown(CHIP_PLAGUE, player._id) == 0) {
                // Try direct targeting first
                var hasDirectLOS = strategy.inRangeAndLOS(player._cellPos, target._cellPos, plagueC._minRange, plagueC._maxRange)
                var plagueTargetCell = target._cellPos

                // If no direct LOS, try AoE splash through walls
                if (!hasDirectLOS) {
                    var splashResult = strategy.findAoESplashCell(CHIP_PLAGUE, target._cellPos)
                    if (splashResult != null) {
                        plagueTargetCell = splashResult['cell']
                        hasDirectLOS = true  // We found an alternate target
                        debug("[BAIT][AGGRESSIVE] Using AoE splash for PLAGUE (target=" + plagueTargetCell + " to hit enemy at " + target._cellPos + ")")
                    }
                }

                if (hasDirectLOS) {
                    var aoePlague = strategy.checkAoESafety(CHIP_PLAGUE, plagueTargetCell)
                    if (!aoePlague['safe'] && aoePlague['needsRepositioning']) {
                        var safeCellPlague = strategy.findSafeCellForAoE(CHIP_PLAGUE, plagueTargetCell)
                        if (safeCellPlague != -1 && player._currMp > 0) {
                            debug("[BAIT][AGGRESSIVE-REPOSITION] Moving to safe cell " + safeCellPlague + " for PLAGUE")
                            strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellPlague, target)
                            strategy.executeAndFlushActions()
                            player.updateEntity()
                        } else {
                            debug("[BAIT][AGGRESSIVE-SKIP] PLAGUE - no safe cell found")
                            aoePlague = ['safe': false]
                        }
                    }
                    if (aoePlague['safe'] || aoePlague['needsRepositioning']) {
                        // Create action with the actual target cell (may be splash cell, not enemy cell)
                        push(strategy._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_PLAGUE, plagueTargetCell, target))
                        player._currTp -= 6
                        willAttack = true
                        debug("[BAIT][AGGRESSIVE] Applied PLAGUE (6 TP) targeting cell " + plagueTargetCell)
                    }
                }
            }
        }

        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN)) {
            var toxinC = arsenal.playerEquippedChips[CHIP_TOXIN]
            if (getCooldown(CHIP_TOXIN, player._id) == 0) {
                if (strategy.inRangeAndLOS(player._cellPos, target._cellPos, toxinC._minRange, toxinC._maxRange)) {
                    var aoeToxin = strategy.checkAoESafety(CHIP_TOXIN, target._cellPos)
                    if (!aoeToxin['safe'] && aoeToxin['needsRepositioning']) {
                        var safeCellToxin = strategy.findSafeCellForAoE(CHIP_TOXIN, target._cellPos)
                        if (safeCellToxin != -1 && player._currMp > 0) {
                            debug("[BAIT][AGGRESSIVE-REPOSITION] Moving to safe cell " + safeCellToxin + " for TOXIN")
                            strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellToxin, target)
                            strategy.executeAndFlushActions()
                            player.updateEntity()
                        } else {
                            debug("[BAIT][AGGRESSIVE-SKIP] TOXIN - no safe cell found")
                            aoeToxin = ['safe': false]
                        }
                    }
                    if (aoeToxin['safe'] || aoeToxin['needsRepositioning']) {
                        strategy.createAttackAction(Action.ACTION_DIRECT, target, -1, CHIP_TOXIN)
                        player._currTp -= 5
                        willAttack = true
                        debug("[BAIT][AGGRESSIVE] Applied TOXIN (5 TP)")
                    }
                }
            }
        }

        // Opportunistic debuffs
        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
            var bncBait = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
            if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, bncBait._minRange, bncBait._maxRange)) {
                    var alreadyBNC = false
                    for (var aBNC in strategy._actions) {
                        if (aBNC.type == Action.ACTION_DEBUFF && aBNC.chip == CHIP_BALL_AND_CHAIN) { alreadyBNC = true; break }
                    }
                    if (!alreadyBNC) {
                        var skipBNC = false
                        // Check AoE safety and reposition if needed
                        var aoeBNC = strategy.checkAoESafety(CHIP_BALL_AND_CHAIN, target._cellPos)
                        if (!aoeBNC['safe'] && aoeBNC['needsRepositioning']) {
                            var safeCellBNC = strategy.findSafeCellForAoE(CHIP_BALL_AND_CHAIN, target._cellPos)
                            if (safeCellBNC != -1 && player._currMp > 0) {
                                debug("[BAIT][BNC-REPOSITION] Moving to safe cell " + safeCellBNC)
                                strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellBNC, target)
                                strategy.executeAndFlushActions()
                                player.updateEntity()
                                targetHitCell = context['targetHitCell']
                            } else {
                                debug("[BAIT] BNC skipped - no safe cell")
                                skipBNC = true
                            }
                        }

                        if (!skipBNC && strategy.inRangeAndLOS(player._cellPos, target._cellPos, bncBait._minRange, bncBait._maxRange)) {
                            strategy.createAttackAction(Action.ACTION_DEBUFF, target, -1, CHIP_BALL_AND_CHAIN)
                            player._currTp -= bncBait._cost
                            willAttack = true
                            debug("[BAIT][DEBUFF] Applied BALL_AND_CHAIN (5 TP)")
                        }
                    }
                }
            }
        }

        if (player._currTp >= 4 && mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
            var fracBait = arsenal.playerEquippedChips[CHIP_FRACTURE]
            if (getCooldown(CHIP_FRACTURE, player._id) == 0) {
                if (strategy.inRangeAndLOS(targetHitCell._id, target._cellPos, fracBait._minRange, fracBait._maxRange)) {
                    var alreadyFRAC = false
                    for (var aFRAC in strategy._actions) {
                        if (aFRAC.type == Action.ACTION_DEBUFF && aFRAC.chip == CHIP_FRACTURE) { alreadyFRAC = true; break }
                    }
                    if (!alreadyFRAC) {
                        var skipFRAC = false
                        // Check AoE safety and reposition if needed
                        var aoeFRAC = strategy.checkAoESafety(CHIP_FRACTURE, target._cellPos)
                        if (!aoeFRAC['safe'] && aoeFRAC['needsRepositioning']) {
                            var safeCellFRAC = strategy.findSafeCellForAoE(CHIP_FRACTURE, target._cellPos)
                            if (safeCellFRAC != -1 && player._currMp > 0) {
                                debug("[BAIT][FRACTURE-REPOSITION] Moving to safe cell " + safeCellFRAC)
                                strategy.createMovementAction(Action.MOVEMENT_APPROACH, safeCellFRAC, target)
                                strategy.executeAndFlushActions()
                                player.updateEntity()
                                targetHitCell = context['targetHitCell']
                            } else {
                                debug("[BAIT] FRACTURE skipped - no safe cell")
                                skipFRAC = true
                            }
                        }

                        if (!skipFRAC && strategy.inRangeAndLOS(player._cellPos, target._cellPos, fracBait._minRange, fracBait._maxRange)) {
                            strategy.createAttackAction(Action.ACTION_DEBUFF, target, -1, CHIP_FRACTURE)
                            player._currTp -= fracBait._cost
                            willAttack = true
                            debug("[BAIT][DEBUFF] Applied FRACTURE (4 TP)")
                        }
                    }
                }
            }
        }

        context['plannedWeapon'] = plannedWeapon
        context['willAttack'] = willAttack
    }
}
