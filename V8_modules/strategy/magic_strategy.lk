include('action.lk')
include('base_strategy.lk')
include('magic_antidote_tracker.lk')
include('magic_combo_system.lk')
include('magic_poison_planner.lk')

class MagicStrategy extends Strategy {
    
    private static _prevPoisonRemaining = [:]  
    private static _recentAntidoteTurn = [:]   
    private static _baitMode = [:]             
    private static _baitStartTurn = [:]        
    private static _stateInitialized = false   

    constructor() {
        super()

        if (getTurn() == 1 || !MagicStrategy._stateInitialized) {
            debug("[MAGIC][STATE] Initializing antidote tracking state for new fight")
            MagicStrategy._prevPoisonRemaining = [:]
            MagicStrategy._recentAntidoteTurn = [:]
            MagicStrategy._baitMode = [:]
            MagicStrategy._baitStartTurn = [:]
            MagicStrategy._stateInitialized = true
        } else {
            debug("[MAGIC][STATE] Reusing persistent antidote state from previous turns")
        }
    }

    getStrategyName() {
        return "MAGIC"
    }

    findSafeKitingCell(target, maxMP) {
        var safeCells = fieldMap.getSafeCells(maxMP, 0)  

        if (count(safeCells) == 0) {
            debug("[SAFE-KITE] No zero-threat cells found within " + maxMP + " MP")
            return null
        }

        var best = null
        var bestDamage = -1

        for (var i = 0; i < count(safeCells); i++) {
            var cell = safeCells[i]

            if (mapContainsKey(fieldMap.damageMap, cell)) {
                var damageCell = fieldMap.damageMap[cell]
                var damage = damageCell._totalDamage

                if (damage > bestDamage) {
                    bestDamage = damage
                    best = cell
                }
            }
        }

        if (best != null) {
            debug("[SAFE-KITE] Found safe cell " + best + " with damage=" + bestDamage)
            return ['cell': best, 'damage': bestDamage]
        }

        debug("[SAFE-KITE] No safe cells with attack potential")
        return null
    }

    createAndExecuteDotKite(target, targetHitCell) {
        arrayClear(this._actions)

        this._originalTP = player._currTp
        this._originalMP = player._currMp

        var hpPercent = (getLife() * 100) / getTotalLife()
        var currentHP = getLife()
        var maxHP = getTotalLife()
        var healChip = this.selectBestHealingChip(hpPercent)
        var healAvailable = (healChip != null)

        var shouldDefend = false
        var currentThreat = fieldMap.getThreatAtCell(player._cellPos)

        if (hpPercent < 35 && healAvailable) {
            
            if (currentThreat >= currentHP) {
                shouldDefend = true
                debug("[MAGIC][THREAT] Immediate lethal threat: " + floor(currentThreat) + " >= " + currentHP + " HP")
            }
            
            else if (currentThreat * 2 > currentHP && hpPercent < 20) {
                shouldDefend = true
                debug("[MAGIC][THREAT] Two-turn lethal + critical HP: threat=" + floor(currentThreat) + " HP=" + currentHP + " (" + floor(hpPercent) + "%)")
            }
            
            else if (hpPercent < 15) {
                shouldDefend = true
                debug("[MAGIC][THREAT] Critical HP: " + floor(hpPercent) + "% (emergency heal)")
            }
            else {
                debug("[MAGIC][THREAT] HP low (" + floor(hpPercent) + "%) but no lethal threat (threat=" + floor(currentThreat) + ") - continuing offense")
            }
        }

        if (shouldDefend) {
            
            var canHeal = this.verifyHealingExecutable(healChip)
            if (canHeal) {
                debug("[MAGIC] Switching to defensive (HP=" + floor(hpPercent) + "% threat=" + floor(currentThreat) + ")")
                this.createDefensiveScenario(target, targetHitCell)
                this.executeScenario()
                return
            } else {
                debug("[MAGIC] Defensive mode wanted but healing not executable, continuing offense")
            }
        }

        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target (ID: " + chest._id + ")")
            target = chest
            fieldMap.buildHitMap(chest._cellPos)
            targetHitCell = fieldMap.getBestWeaponOrChipCell()
        }

        target.updateEntity()
        player.updateEntity()

        var plannedOffensiveCell = -1

        var poisonActive = target.hasEffect(EFFECT_POISON)
        var poisonRemaining = target.getEffectRemaining(EFFECT_POISON)
        debug("[DoT-KITE] Start poisonActive=" + poisonActive + " remaining=" + poisonRemaining + " TP=" + player._currTp + " MP=" + player._currMp)

        var enemyId = target._id

        var distToEnemy = getCellDistance(player._cellPos, target._cellPos)
        if (distToEnemy != null && distToEnemy >= 15) {
            debug("[MAGIC][LONG-RANGE] Distance " + distToEnemy + " cells - using simple approach mode")

            if (getTurn() >= 2 && player._currTp >= 6 && mapContainsKey(arsenal.playerEquippedChips, CHIP_WIZARDRY)) {
                if (getCooldown(CHIP_WIZARDRY, player._id) == 0) {
                    push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_WIZARDRY, player._cellPos, player))
                    player._currTp -= 6
                    debug("[MAGIC][LONG-RANGE][BUFF] Applied WIZARDRY (+150-170 magic)")
                }
            }

            if (getTurn() >= 2 && player._currTp >= 7 && mapContainsKey(arsenal.playerEquippedChips, CHIP_MUTATION)) {
                if (getCooldown(CHIP_MUTATION, player._id) == 0) {
                    push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_MUTATION, player._cellPos, player))
                    player._currTp -= 7
                    debug("[MAGIC][LONG-RANGE][BUFF] Applied MUTATION (+15-20 max HP)")
                }
            }

            if (player._currTp >= 3 && mapContainsKey(arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS)) {
                if (getCooldown(CHIP_LEATHER_BOOTS, player._id) == 0) {
                    push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_LEATHER_BOOTS, player._cellPos, player))
                    player._currTp -= 3
                    player._currMp += 2
                    debug("[MAGIC][LONG-RANGE][BUFF] Applied LEATHER_BOOTS (+2 MP)")
                }
            }

            var approachInfo = fieldMap.findHideAndSeekCell("approach", target)
            if (approachInfo != null && approachInfo['cell'] != player._cellPos) {
                push(this._actions, new Action(Action.MOVEMENT_APPROACH, -1, -1, approachInfo['cell'], target))
                debug("[MAGIC][LONG-RANGE][MOVE] Approaching via cell " + approachInfo['cell'])
            } else {
                
                push(this._actions, new Action(Action.MOVEMENT_APPROACH, -1, -1, -1, target))
                debug("[MAGIC][LONG-RANGE][MOVE] Direct approach toward enemy")
            }

            debug("[MAGIC][LONG-RANGE] Executing simple approach (TP=" + player._currTp + " MP=" + player._currMp + ")")
            this.executeScenario()
            return
        }

        debug("[MAGIC][CLOSE-RANGE] Distance " + distToEnemy + " cells - using full offensive")

        var antidoteState = AntidoteTracker.updateAntidoteState(target, MagicStrategy._prevPoisonRemaining, MagicStrategy._recentAntidoteTurn, MagicStrategy._baitMode, MagicStrategy._baitStartTurn)
        var baiting = antidoteState['baiting']
        var enemyHasAntidote = antidoteState['enemyHasAntidote']
        var antidoteCD = getCooldown(CHIP_ANTIDOTE, enemyId)

        debug("[MAGIC][ANTIDOTE-STATE] Turn " + getTurn() + ": baiting=" + baiting + " enemyHasAntidote=" + enemyHasAntidote + " antidoteCD=" + antidoteCD)

        if (baiting && mapContainsKey(MagicStrategy._baitStartTurn, enemyId)) {
            var baitDuration = getTurn() - MagicStrategy._baitStartTurn[enemyId]
            if (baitDuration >= 3) {
                debug("[MAGIC][BURST-MODE] Baiting for " + baitDuration + " turns without antidote burn - forcing full offensive")
                baiting = false
                MagicStrategy._baitMode[enemyId] = false  
            }
        }

        if (!baiting && antidoteCD > 0 && enemyHasAntidote) {
            var hasCoreChips = mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE) &&
                              mapContainsKey(arsenal.playerEquippedChips, CHIP_COVID) &&
                              mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)
            var coreChipsReady = getCooldown(CHIP_GRAPPLE, player._id) == 0 &&
                                getCooldown(CHIP_COVID, player._id) == 0 &&
                                getCooldown(CHIP_BOXING_GLOVE, player._id) == 0

            if (hasCoreChips && coreChipsReady) {
                debug("[AGGRESSIVE-COMBO] Antidote on CD=" + antidoteCD + ", checking combo viability")

                var canExecuteNow = ComboSystem.canUseGrappleCovidCombo(target)
                var requiredTP = 13  
                var hasBNC = mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)
                if (hasBNC && getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0) requiredTP = 18

                debug("[AGGRESSIVE-COMBO] canExecuteNow=" + canExecuteNow + " requiredTP=" + requiredTP + " currentTP=" + player._currTp)

                var tpShort = requiredTP - player._currTp
                if (!canExecuteNow && tpShort > 0 && tpShort <= 4 && player._currTp >= 1) {
                    if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ADRENALINE)) {
                        var adrenalineCD = getCooldown(CHIP_ADRENALINE, player._id)
                        if (adrenalineCD == 0) {
                            debug("[AGGRESSIVE-COMBO] Using ADRENALINE to bridge " + tpShort + " TP gap (1 TP â†’ +5 TP)")
                            useChipOnCell(CHIP_ADRENALINE, player._cellPos)
                            player._currTp -= 1
                            player._currTp += 5
                            debug("[AGGRESSIVE-COMBO] TP after ADRENALINE: " + player._currTp)
                        }
                    }
                }

                if (!canExecuteNow) {
                    var comboCell = ComboSystem.findGrappleCovidCell(target)
                    debug("[AGGRESSIVE-COMBO] Not in range, found combo cell: " + comboCell)

                    if (comboCell != -1) {
                        var pathLen = getCachedPathLength(player._cellPos, comboCell)
                        debug("[AGGRESSIVE-COMBO] Path to combo cell: " + pathLen + " cells, available MP: " + player._currMp)

                        if (pathLen != null && pathLen > player._currMp && pathLen <= player._currMp + 2) {
                            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS)) {
                                var bootsCD = getCooldown(CHIP_LEATHER_BOOTS, player._id)
                                if (bootsCD == 0 && player._currTp >= 3) {
                                    debug("[AGGRESSIVE-COMBO] Using LEATHER_BOOTS to reach combo cell (+2 MP)")
                                    useChipOnCell(CHIP_LEATHER_BOOTS, player._cellPos)
                                    player._currTp -= 3
                                    player._currMp += 2
                                    debug("[AGGRESSIVE-COMBO] MP after LEATHER_BOOTS: " + player._currMp)
                                }
                            }
                        }

                        if (pathLen != null && pathLen > player._currMp) {
                            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_TELEPORTATION)) {
                                var teleportCD = getCooldown(CHIP_TELEPORTATION, player._id)
                                if (teleportCD == 0 && player._currTp >= 5) {
                                    debug("[AGGRESSIVE-COMBO] Using TELEPORTATION to reach combo cell (5 TP)")
                                    useChipOnCell(CHIP_TELEPORTATION, comboCell)
                                    player._currTp -= 5
                                    player._cellPos = getCell()
                                    debug("[AGGRESSIVE-COMBO] Teleported to cell: " + player._cellPos)
                                    pathLen = 0  
                                }
                            }
                        }

                        if (pathLen != null && pathLen > 0 && pathLen <= player._currMp) {
                            debug("[AGGRESSIVE-COMBO] Moving to combo cell " + comboCell)
                            moveTowardCell(comboCell)
                            player._currMp -= pathLen
                            player._cellPos = getCell()
                            debug("[AGGRESSIVE-COMBO] Moved to cell: " + player._cellPos)
                        }

                        target.updateEntity()
                        canExecuteNow = ComboSystem.canUseGrappleCovidCombo(target)
                        debug("[AGGRESSIVE-COMBO] After movement, canExecuteNow=" + canExecuteNow + " TP=" + player._currTp)
                    }
                }

                if (canExecuteNow && player._currTp >= 13) {
                    debug("[AGGRESSIVE-COMBO] EXECUTING GRAPPLE-COVID COMBO NOW!")
                    ComboSystem.executeGrappleCovidCombo(target, this)
                    debug("[AGGRESSIVE-COMBO] Combo complete, remaining TP=" + player._currTp + " MP=" + player._currMp)

                    var hnsInfo = fieldMap.findHideAndSeekCell("defensive")
                    if (hnsInfo != null && player._currMp > 0) {
                        var hideCell = hnsInfo['cell']
                        var hidePath = getCachedPathLength(player._cellPos, hideCell)
                        if (hidePath != null && hidePath <= player._currMp) {
                            debug("[AGGRESSIVE-COMBO] Moving to hide cell " + hideCell + " after combo")
                            moveTowardCell(hideCell)
                        }
                    }
                    return  
                } else {
                    debug("[AGGRESSIVE-COMBO] Could not execute combo (viable=" + canExecuteNow + " TP=" + player._currTp + "/13)")
                }
            }
        }

        var shouldPlayDefensive = false
        if (poisonActive && poisonRemaining > 0 && !baiting) {
            var enemyHP = getLife(enemyId)
            var enemyMaxHP = getTotalLife(enemyId)
            var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

            var poisonDamagePerTurn = target.getEffectValue(EFFECT_POISON)
            if (poisonDamagePerTurn <= 0) {
                
                poisonDamagePerTurn = player._magic * 0.5
            }
            var turnsUntilAntidote = antidoteCD
            if (!enemyHasAntidote) turnsUntilAntidote = 999

            var turnsBeforeAntidote = min(poisonRemaining, turnsUntilAntidote)
            var poisonDamageBeforeAntidote = poisonDamagePerTurn * turnsBeforeAntidote

            var poisonWillKill = poisonDamageBeforeAntidote >= enemyHP
            var veryLowHP = enemyHPPercent < 30
            var lowHPWithAntidoteCD = enemyHPPercent < 50 && antidoteCD > 0

            if (poisonWillKill || veryLowHP || lowHPWithAntidoteCD) {
                shouldPlayDefensive = true
                debug("[ATTRITION] Poison active, enemyHP=" + enemyHP + "/" + enemyMaxHP + " (" + floor(enemyHPPercent) + "%) antidoteCD=" + antidoteCD + " turnsBeforeCleanse=" + turnsBeforeAntidote + " poisonDmg=" + floor(poisonDamageBeforeAntidote) + " willKill=" + poisonWillKill + " -> HIDE")
            }
        }

        if (shouldPlayDefensive) {
            var hnsInfo = fieldMap.findHideAndSeekCell("defensive")
            if (hnsInfo != null) {
                var hideCell = hnsInfo['cell']
                var pathLen = getCachedPathLength(player._cellPos, hideCell)
                if (pathLen != null && pathLen <= player._currMp) {
                    push(this._actions, new Action(Action.MOVEMENT_HNS, -1, -1, hideCell, target))
                    player._currMp -= pathLen
                    debug("[ATTRITION] Moving to hide cell " + hideCell + " (danger=" + hnsInfo['danger'] + ")")
                    this.executeScenario()
                    return
                } else {
                    debug("[ATTRITION] Hide cell unreachable, fleeing")
                    push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
                    this.executeScenario()
                    return
                }
            } else {
                debug("[ATTRITION] No hide cell found, fleeing")
                push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
                this.executeScenario()
                return
            }
        }

        var grappleCovidCell = -1
        var shouldPrioritizeCombo = false
        var antidoteSafe = (antidoteCD > 0 || !enemyHasAntidote)
        if (!baiting && antidoteSafe) {
            var hasCoreChips = mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE) &&
                              mapContainsKey(arsenal.playerEquippedChips, CHIP_COVID) &&
                              mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)
            var coreChipsReady = getCooldown(CHIP_GRAPPLE, player._id) == 0 &&
                                getCooldown(CHIP_COVID, player._id) == 0 &&
                                getCooldown(CHIP_BOXING_GLOVE, player._id) == 0
            var hasTP = player._currTp >= 13

            if (hasCoreChips && coreChipsReady && hasTP) {
                grappleCovidCell = ComboSystem.findGrappleCovidCell(target)
                if (grappleCovidCell != -1) {
                    shouldPrioritizeCombo = true
                    debug("[COMBO-POSITIONING] Found optimal GRAPPLE-COVID cell: " + grappleCovidCell + " (antidoteCD=" + antidoteCD + ")")
                }
            }
        } else if (!antidoteSafe) {
            debug("[COMBO-POSITIONING] Skipping - enemy antidote available (CD=" + antidoteCD + ")")
        }

        var hnsStage = fieldMap.findHideAndSeekCell("approach", target)
        var poisonPlan = PoisonPlanner.selectBestPoisonCell(target)

        if (getTurn() >= 2 && mapContainsKey(arsenal.playerEquippedChips, CHIP_WIZARDRY)) {
            var wizardryCD = getCooldown(CHIP_WIZARDRY, player._id)
            if (wizardryCD == 0 && player._currTp >= 6) {
                push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_WIZARDRY, player._cellPos, player))
                player._currTp -= 6
                debug("[DoT-KITE][WIZARDRY] Applied (+150-170 magic, 6 TP)")
            }
        }

        if (getTurn() >= 2 && mapContainsKey(arsenal.playerEquippedChips, CHIP_MUTATION)) {
            var mutationCD = getCooldown(CHIP_MUTATION, player._id)
            if (mutationCD == 0 && player._currTp >= 7) {
                push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_MUTATION, player._cellPos, player))
                player._currTp -= 7
                debug("[DoT-KITE][MUTATION] Applied (+15-20 max HP, 7 TP)")
            }
        }

        var plannedAttackCell = -1
        if (poisonPlan != null) plannedAttackCell = poisonPlan['cell']._id
        else if (targetHitCell != -1 && targetHitCell != null) plannedAttackCell = targetHitCell._id

        var hnsInfoPreCheck = fieldMap.findHideAndSeekCell("defensive")
        var hideCell = hnsInfoPreCheck != null ? hnsInfoPreCheck['cell'] : null
        if (!shouldPrioritizeCombo && plannedAttackCell != -1 && this.shouldUseLeatherBoots(plannedAttackCell, hideCell)) {
            push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_LEATHER_BOOTS, player._cellPos, player))
            player._currTp -= 3
            player._currMp += 2
            debug("[DoT-KITE][LEATHER_BOOTS] Applied (+2 MP)")
        } else if (shouldPrioritizeCombo) {
            debug("[DoT-KITE][LEATHER_BOOTS] Skipping - reserving TP for GRAPPLE-COVID combo")
        }

        if (shouldPrioritizeCombo && grappleCovidCell != -1) {
            if (mapContainsKey(fieldMap.damageMap, grappleCovidCell)) {
                targetHitCell = fieldMap.damageMap[grappleCovidCell]
            } else {
                targetHitCell = ['_id': grappleCovidCell, '_totalDamage': 0]
            }
            debug("[COMBO-POSITIONING] Overriding poison plan with combo cell " + grappleCovidCell)
        } else if (poisonPlan != null) {
            targetHitCell = poisonPlan['cell']
            debug("[DoT-KITE] Plan cell=" + targetHitCell._id + " chips=" + count(poisonPlan['chips']) + " weapons=" + count(poisonPlan['weapons']))
        } else if (targetHitCell == -1 || targetHitCell == null) {
            targetHitCell = fieldMap.getBestWeightedDamageCell(1.8, 1)
            if (targetHitCell != -1) debug("[DoT-KITE] Fallback weighted cell=" + targetHitCell._id)
        }

        if (!shouldPrioritizeCombo && hnsStage != null && targetHitCell != -1) {
            var consider = false
            if (hnsStage['canAttack'] && poisonPlan == null) consider = true
            if (mapContainsKey(fieldMap.damageMap, hnsStage['cell']) && mapContainsKey(fieldMap.damageMap, targetHitCell._id)) {
                var hObj = fieldMap.damageMap[hnsStage['cell']]
                if (hObj._totalDamage == targetHitCell._totalDamage) {
                    var dCur = getCachedPathLength(player._cellPos, targetHitCell._id)
                    var dH = getCachedPathLength(player._cellPos, hObj._id)
                    if (dH != null && dCur != null && dH < dCur) consider = true
                }
            }
            if (consider) {
                if (mapContainsKey(fieldMap.damageMap, hnsStage['cell'])) {
                    targetHitCell = fieldMap.damageMap[hnsStage['cell']]
                    debug("[DoT-KITE][HNS-APPROACH] Switching to approach cell " + hnsStage['cell'])
                }
            }
        }

        if (targetHitCell != -1) {
            fieldMap.markChosenDestinationAndPath(player._cellPos, targetHitCell._id)
        }

        if (shouldPrioritizeCombo && targetHitCell != -1 && targetHitCell._id != player._cellPos) {
            debug("[COMBO-POSITIONING] Executing immediate movement to combo cell " + targetHitCell._id)
            push(this._actions, new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, targetHitCell._id, target))
            this.executeAndFlushActions()
            player._cellPos = getCell()
            debug("[COMBO-POSITIONING] Movement complete, now at cell " + player._cellPos)
        } else if (targetHitCell != -1 && targetHitCell._id != player._cellPos) {
            push(this._actions, new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, targetHitCell._id, target))
            plannedOffensiveCell = targetHitCell._id  
        } else if (targetHitCell != -1) {
            debug("[DoT-KITE] Already positioned on cell " + targetHitCell._id)
        }

        var context = ['willAttack': false, 'plannedWeapon': getWeapon(), 'targetHitCell': targetHitCell, 'comboExecuted': false]

        if (baiting) {
            AntidoteTracker.createBaitOffensive(target, poisonPlan, context, this)
        } else {
            this.createFullOffensiveDoT(target, poisonPlan, context, poisonActive, poisonRemaining, shouldPrioritizeCombo, antidoteCD, enemyHasAntidote)
        }

        if (!context['willAttack']) {
            var activeW = getWeapon()
            if (activeW != null && mapContainsKey(arsenal.playerEquippedWeapons, activeW)) {
                var wObj = arsenal.playerEquippedWeapons[activeW]
                if (targetHitCell != -1 && targetHitCell != null && player._currTp >= wObj._cost && this.inRangeAndLOS(targetHitCell._id, target._cellPos, wObj._minRange, wObj._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    context['willAttack'] = true
                }
            }
        }

        var originalMP = player._currMp
        var pathToAttack = 0
        if (targetHitCell != -1 && targetHitCell != null) pathToAttack = getCachedPathLength(player._cellPos, targetHitCell._id)
        if (pathToAttack == null) pathToAttack = 0

        var safeKiteInfo = this.findSafeKitingCell(target, originalMP - pathToAttack)
        var hnsInfoKite = null

        if (safeKiteInfo != null) {
            
            hnsInfoKite = ['cell': safeKiteInfo['cell'], 'danger': 0]
            debug("[MAGIC][KITE] Using SAFE kiting cell (zero threat)")
        } else {
            
            hnsInfoKite = fieldMap.findHideAndSeekCell("defensive")
            if (hnsInfoKite != null) {
                debug("[MAGIC][KITE] Using standard H&S cell (danger=" + hnsInfoKite['danger'] + ")")
            }
        }

        var addedHide = false
        if (hnsInfoKite != null) {
            var hideCellIdK = hnsInfoKite['cell']
            var extraLeg = 0
            if (targetHitCell != -1 && targetHitCell != null && hideCellIdK != targetHitCell._id) {
                extraLeg = getCachedPathLength(targetHitCell._id, hideCellIdK)
                if (extraLeg == null) extraLeg = 9999
            }

            if (hideCellIdK == player._cellPos) {
                
            } else {
                var totalNeeded = pathToAttack + extraLeg
                if (totalNeeded <= originalMP) {
                    if (hideCellIdK != (targetHitCell != -1 && targetHitCell != null ? targetHitCell._id : player._cellPos)) {
                        push(this._actions, new Action(Action.MOVEMENT_HNS, -1, -1, hideCellIdK, target))
                        addedHide = true
                        debug("[DoT-KITE][HNS] Added hide move to cell " + hideCellIdK + " danger=" + hnsInfoKite['danger'])
                    }
                } else {
                    debug("[DoT-KITE][HNS] Not enough MP for hide pathNeeded=" + totalNeeded + " MP=" + originalMP)
                }
            }
        }

        if (!addedHide) {
            push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
            debug("[DoT-KITE] Fallback flee movement")
        }

        debug("[DoT-KITE] Actions scheduled=" + count(this._actions) + " TP_end=" + player._currTp)

        var actionCountBefore = count(this._actions)
        this.executeScenario()

        if (plannedOffensiveCell != -1 && actionCountBefore > 0 && count(this._actions) == 0 && player._currMp > 0) {
            debug("[DoT-KITE][FALLBACK] All actions removed by validation, executing direct movement to " + plannedOffensiveCell)
            var moveResult = moveTowardCell(plannedOffensiveCell)
            debug("[DoT-KITE][FALLBACK] Movement result: " + getCell() + " (target was " + plannedOffensiveCell + ")")
        }
    }

    createFullOffensiveDoT(target, poisonPlan, context, poisonActive, poisonRemaining, comboPositioned, antidoteCD, enemyHasAntidote) {
        debug("[FULL] ===== ENTERED FULL OFFENSIVE MODE =====")
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']

        var currHp = getLife()
        var maxHp = getTotalLife()
        var hpPercent = floor((currHp / maxHp) * 100)
        debug("[MAGIC][SUSTAIN] HP check: " + currHp + "/" + maxHp + " (" + hpPercent + "%)")

        if (hpPercent < 30 && this.isChipAvailable(CHIP_REGENERATION, 8)) {
            debug("[MAGIC][EMERGENCY] Using REGENERATION (HP=" + hpPercent + "%, TP=" + player._currTp + ")")
            push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REGENERATION, player._cellPos, player))
            player._currTp -= 8
            willAttack = true
        }
        
        else if (hpPercent >= 40 && hpPercent <= 60 && this.isChipAvailable(CHIP_REMISSION, 5)) {
            debug("[MAGIC][SUSTAIN] Using REMISSION (HP=" + hpPercent + "%, TP=" + player._currTp + ")")
            push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, player._cellPos, player))
            player._currTp -= 5
            willAttack = true
        }

        if (player._currTp < 6 && player._currTp >= 2) {
            if (this.shouldUseAdrenaline(6)) {
                push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, player._cellPos, player))
                player._currTp -= 1
                player._currTp += 5
                debug("[DoT-KITE][ADRENALINE] Used Adrenaline, now have " + player._currTp + " TP")
            }
        }

        var reservedTPForCombo = 0
        var antidoteSafe = (antidoteCD > 0 || !enemyHasAntidote)
        debug("[FULL] Checking GRAPPLE-COVID combo... antidoteCD=" + antidoteCD + " enemyHasAntidote=" + enemyHasAntidote + " antidoteSafe=" + antidoteSafe)
        var canExecuteNow = antidoteSafe && ComboSystem.canUseGrappleCovidCombo(target)
        if (canExecuteNow) {
            var hasBNC = mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)
            var cdBNC = hasBNC ? getCooldown(CHIP_BALL_AND_CHAIN, player._id) : 1
            var includeBNC = hasBNC && cdBNC == 0 && player._currTp >= 18
            reservedTPForCombo = includeBNC ? 18 : 13
            debug("[FULL][GRAPPLE-COVID] Combo available NOW - reserving " + reservedTPForCombo + " TP (BNC=" + includeBNC + ")")
        } else if (!antidoteSafe) {
            debug("[FULL][GRAPPLE-COVID] Skipping combo - enemy antidote available (CD=" + antidoteCD + ")")
        } else if (comboPositioned) {
            debug("[FULL][GRAPPLE-COVID] Moving to combo cell - will execute NEXT turn")
        } else {
            debug("[FULL][GRAPPLE-COVID] Combo NOT available")
        }

        if (canExecuteNow) {
            debug("[FULL][GRAPPLE-COVID] Executing combo NOW!")
            ComboSystem.executeGrappleCovidCombo(target, this)
            context['comboExecuted'] = true
            willAttack = true
            reservedTPForCombo = 0  
        }
        
        else if (antidoteSafe && ComboSystem.isWithinCovidRange(target._cellPos)) {
            debug("[FULL][COVID-RANGE] Enemy at close range, applying COVID sequence")

            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_COVID)) {
                var covid = arsenal.playerEquippedChips[CHIP_COVID]
                if (getCooldown(CHIP_COVID, player._id) == 0 && player._currTp >= covid._cost) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, covid._minRange, covid._maxRange)) {
                        push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_COVID, target._cellPos, target))
                        player._currTp -= covid._cost
                        willAttack = true
                        debug("[FULL][COVID] Applied (8 TP)")
                    }
                }
            }

            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
                var bnc = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
                if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0 && player._currTp >= bnc._cost) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, bnc._minRange, bnc._maxRange)) {
                        push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_BALL_AND_CHAIN, target._cellPos, target))
                        player._currTp -= bnc._cost
                        willAttack = true
                        debug("[FULL][BALL_AND_CHAIN] Applied (5 TP)")
                    }
                }
            }

            var distToTarget2 = getCellDistance(player._cellPos, target._cellPos)
            if (distToTarget2 == 1 && isOnSameLine(player._cellPos, target._cellPos)) {
                if (mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)) {
                    var boxing2 = arsenal.playerEquippedChips[CHIP_BOXING_GLOVE]
                    if (getCooldown(CHIP_BOXING_GLOVE, player._id) == 0 && player._currTp >= boxing2._cost) {
                        push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_BOXING_GLOVE, target._cellPos, target))
                        player._currTp -= boxing2._cost
                        willAttack = true
                        debug("[FULL][BOXING_GLOVE] Applied (2 TP) - pushing away")
                    }
                }
            }

            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
                var frac2 = arsenal.playerEquippedChips[CHIP_FRACTURE]
                if (getCooldown(CHIP_FRACTURE, player._id) == 0 && player._currTp >= frac2._cost) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, frac2._minRange, frac2._maxRange)) {
                        push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_FRACTURE, target._cellPos, target))
                        player._currTp -= frac2._cost
                        willAttack = true
                        debug("[FULL][FRACTURE] Applied (4 TP)")
                    }
                }
            }
        }

        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (player._currTp - reservedTPForCombo < 1) break

                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, wObj._id, -1, target._cellPos, target))
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }

                var actualUses = 0
                while (actualUses < wObj._maxUse && player._currTp - reservedTPForCombo >= wObj._cost) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    actualUses += 1
                    willAttack = true
                }
                if (actualUses > 0) {
                    debug("[FULL][WEAPON-SPAM] Used " + getWeaponName(wObj._id) + " x" + actualUses + " TP_left=" + player._currTp)
                }
            }
        }

        if (poisonPlan != null && count(poisonPlan['weapons']) == 0 && player._currTp - reservedTPForCombo >= 3) {
            debug("[FULL][WEAPON-FALLBACK] Poison plan had no DoT weapons, spamming all equipped weapons")
            var allWeapons = []
            if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_AXE)) push(allWeapons, arsenal.playerEquippedWeapons[WEAPON_AXE])
            if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_DESTROYER)) push(allWeapons, arsenal.playerEquippedWeapons[WEAPON_DESTROYER])
            if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_DOUBLE_GUN)) push(allWeapons, arsenal.playerEquippedWeapons[WEAPON_DOUBLE_GUN])
            if (mapContainsKey(arsenal.playerEquippedWeapons, WEAPON_FLAME_THROWER)) push(allWeapons, arsenal.playerEquippedWeapons[WEAPON_FLAME_THROWER])

            for (var fwIdx = 0; fwIdx < count(allWeapons); fwIdx++) {
                var fallbackWeapon = allWeapons[fwIdx]
                if (player._currTp - reservedTPForCombo < fallbackWeapon._cost) continue

                var canUseWeapon = false
                if (targetHitCell != -1 && targetHitCell != null) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, fallbackWeapon._minRange, fallbackWeapon._maxRange)) {
                        canUseWeapon = true
                    }
                }
                if (!canUseWeapon) continue

                if (plannedWeapon != fallbackWeapon._id && player._currTp >= 1) {
                    push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, fallbackWeapon._id, -1, target._cellPos, target))
                    player._currTp -= 1
                    plannedWeapon = fallbackWeapon._id
                }

                var fallbackUses = 0
                while (fallbackUses < fallbackWeapon._maxUse && player._currTp - reservedTPForCombo >= fallbackWeapon._cost) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, fallbackWeapon._id, -1, target._cellPos, target))
                    player._currTp -= fallbackWeapon._cost
                    fallbackUses += 1
                    willAttack = true
                }
                if (fallbackUses > 0) {
                    debug("[FULL][WEAPON-FALLBACK] Used " + getWeaponName(fallbackWeapon._id) + " x" + fallbackUses + " TP_left=" + player._currTp)
                }
            }
        }

        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ARSENIC)) {
            var arsenic = arsenal.playerEquippedChips[CHIP_ARSENIC]
            var arsenicCD = getCooldown(CHIP_ARSENIC, player._id)

            var arsenicUsesLeft = arsenicCD == 0 ? 3 : 0  

            while (arsenicUsesLeft > 0 && player._currTp - reservedTPForCombo >= arsenic._cost) {
                
                var dist = getCellDistance(player._cellPos, target._cellPos)
                if (dist != null && dist >= arsenic._minRange && dist <= arsenic._maxRange) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_ARSENIC, target._cellPos, target))
                    player._currTp -= arsenic._cost
                    willAttack = true
                    arsenicUsesLeft--
                    debug("[FULL][ARSENIC] Applied stack (through obstacles, 8 TP) - remaining uses: " + arsenicUsesLeft + ", TP left: " + player._currTp)
                } else {
                    debug("[FULL][ARSENIC] Out of range (dist=" + dist + ", need 3-4)")
                    break
                }
            }

            if (arsenicCD > 0) {
                debug("[FULL][ARSENIC] On cooldown: " + arsenicCD + " turns")
            }
        }

        if (poisonPlan != null) {
            
            var chipsToUse = poisonPlan['chips']
            debug("[FULL][CHIP-LIST] Found " + count(chipsToUse) + " chips in poison plan, TP available=" + (player._currTp - reservedTPForCombo))
            for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                var pc = chipsToUse[cidx]
                debug("[FULL][CHIP-CHECK] " + getChipName(pc._id) + " cost=" + pc._cost + " cd=" + getCooldown(pc._id, player._id) + " TP=" + (player._currTp - reservedTPForCombo))
                if (player._currTp - reservedTPForCombo < pc._cost) {
                    debug("[FULL][CHIP-SKIP] " + getChipName(pc._id) + " - insufficient TP")
                    break
                }
                if (getCooldown(pc._id, player._id) > 0) {
                    debug("[FULL][CHIP-SKIP] " + getChipName(pc._id) + " - on cooldown")
                    continue
                }

                var chipInRange = false
                if (pc._id == CHIP_ARSENIC) {
                    var distToTarget = getCellDistance(targetHitCell._id, target._cellPos)
                    chipInRange = distToTarget != null && distToTarget >= pc._minRange && distToTarget <= pc._maxRange
                    if (!chipInRange) debug("[FULL][CHIP-SKIP] ARSENIC - out of range (dist=" + distToTarget + ", need 3-4)")
                } else {
                    chipInRange = this.inRangeAndLOS(targetHitCell._id, target._cellPos, pc._minRange, pc._maxRange)
                    if (!chipInRange) debug("[FULL][CHIP-SKIP] " + getChipName(pc._id) + " - out of range/LOS")
                }

                if (!chipInRange) continue

                var aoeCheck = this.checkAoESafety(pc._id, target._cellPos)
                if (!aoeCheck['safe'] && aoeCheck['needsRepositioning']) {
                    var safeCell = this.findSafeCellForAoE(pc._id, target._cellPos)
                    if (safeCell != -1) {
                        debug("[FULL][CHIP-REPOSITION] Moving to safe cell " + safeCell + " for " + getChipName(pc._id))
                        this.createMovementAction(Action.MOVEMENT_APPROACH, safeCell, target)
                        this.executeAndFlushActions()
                        player.updateEntity()
                        fieldMap.buildHitMap(target._cellPos)
                        targetHitCell = fieldMap.getBestWeaponOrChipCell()

                        var recheckSafety = this.checkAoESafety(pc._id, target._cellPos)
                        if (!recheckSafety['safe']) {
                            debug("[FULL][CHIP-SKIP] " + getChipName(pc._id) + " - still unsafe after repositioning")
                            continue
                        }
                        debug("[FULL][CHIP-SAFE] Repositioning successful, now safe to use " + getChipName(pc._id))
                    } else {
                        debug("[FULL][CHIP-SKIP] " + getChipName(pc._id) + " - no safe cell found")
                        continue
                    }
                }

                push(this._actions, new Action(Action.ACTION_DIRECT, -1, pc._id, target._cellPos, target))
                player._currTp -= pc._cost
                willAttack = true
                debug("[FULL][CHIP-USED] " + getChipName(pc._id) + " TP_left=" + player._currTp)
            }
        }

        if (player._currTp - reservedTPForCombo > 0) {
            var priorityChips = []
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN)) push(priorityChips, arsenal.playerEquippedChips[CHIP_TOXIN])
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_PLAGUE)) push(priorityChips, arsenal.playerEquippedChips[CHIP_PLAGUE])
            var allPois = arsenal.getPoisonChipsSorted(player._strength, player._magic, player._wisdom, player._science)
            for (var addIdx = 0; addIdx < count(allPois); addIdx++) {
                var pcAdd = allPois[addIdx]
                if (pcAdd._id == CHIP_TOXIN || pcAdd._id == CHIP_PLAGUE) continue
                push(priorityChips, pcAdd)
            }

            for (var pIdx = 0; pIdx < count(priorityChips); pIdx++) {
                var chipP = priorityChips[pIdx]
                if (player._currTp - reservedTPForCombo < chipP._cost) continue
                if (getCooldown(chipP._id, player._id) > 0) continue

                var fallbackInRange = false
                if (chipP._id == CHIP_ARSENIC) {
                    var distFallback = getCellDistance(targetHitCell._id, target._cellPos)
                    fallbackInRange = distFallback != null && distFallback >= chipP._minRange && distFallback <= chipP._maxRange
                } else {
                    fallbackInRange = targetHitCell != -1 && targetHitCell != null && this.inRangeAndLOS(targetHitCell._id, target._cellPos, chipP._minRange, chipP._maxRange)
                }

                if (!fallbackInRange) continue

                var aoeFallback = this.checkAoESafety(chipP._id, target._cellPos)
                if (!aoeFallback['safe'] && aoeFallback['needsRepositioning']) {
                    var safeCellFB = this.findSafeCellForAoE(chipP._id, target._cellPos)
                    if (safeCellFB != -1) {
                        debug("[FULL][FALLBACK-REPOSITION] Moving to safe cell " + safeCellFB + " for " + getChipName(chipP._id))
                        this.createMovementAction(Action.MOVEMENT_APPROACH, safeCellFB, target)
                        this.executeAndFlushActions()
                        player.updateEntity()
                        fieldMap.buildHitMap(target._cellPos)
                        targetHitCell = fieldMap.getBestWeaponOrChipCell()
                    } else {
                        continue
                    }
                }

                push(this._actions, new Action(Action.ACTION_DIRECT, -1, chipP._id, target._cellPos, target))
                player._currTp -= chipP._cost
                willAttack = true
                debug("[FULL][FALLBACK-CHIP] Used " + getChipName(chipP._id) + " TP_left=" + player._currTp)
            }
        }

        var enemyHP = getLife(target._id)
        var enemyMaxHP = getTotalLife(target._id)
        var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

        if (enemyHPPercent < 75 && player._currTp >= 8 && mapContainsKey(arsenal.playerEquippedChips, CHIP_DESINTEGRATION)) {
            var desint = arsenal.playerEquippedChips[CHIP_DESINTEGRATION]
            if (getCooldown(CHIP_DESINTEGRATION, player._id) == 0) {
                if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, desint._minRange, desint._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_DESINTEGRATION, target._cellPos, target))
                    player._currTp -= desint._cost
                    willAttack = true
                    debug("[DoT-KITE][NOVA] Applied DESINTEGRATION (70-80 nova, 8 TP) - enemy at " + floor(enemyHPPercent) + "% HP")
                }
            }
        }

        if (enemyHPPercent < 100 && player._currTp >= 3 && mapContainsKey(arsenal.playerEquippedChips, CHIP_ALTERATION)) {
            var alter = arsenal.playerEquippedChips[CHIP_ALTERATION]
            if (getCooldown(CHIP_ALTERATION, player._id) == 0) {
                if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, alter._minRange, alter._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_ALTERATION, target._cellPos, target))
                    player._currTp -= alter._cost
                    willAttack = true
                    debug("[DoT-KITE][NOVA] Applied ALTERATION (18-20 nova, 3 TP) - enemy at " + floor(enemyHPPercent) + "% HP")
                }
            }
        }

        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
            var bncDebuff = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
            if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0) {
                if (targetHitCell != -1 && targetHitCell != null && this.inRangeAndLOS(targetHitCell._id, target._cellPos, bncDebuff._minRange, bncDebuff._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_BALL_AND_CHAIN, target._cellPos, target))
                    player._currTp -= bncDebuff._cost
                    willAttack = true
                    debug("[DoT-KITE][DEBUFF] Applied BALL_AND_CHAIN (5 TP)")
                }
            }
        }

        if (player._currTp >= 4 && mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
            var fracDebuff = arsenal.playerEquippedChips[CHIP_FRACTURE]
            if (getCooldown(CHIP_FRACTURE, player._id) == 0) {
                if (targetHitCell != -1 && targetHitCell != null && this.inRangeAndLOS(targetHitCell._id, target._cellPos, fracDebuff._minRange, fracDebuff._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_FRACTURE, target._cellPos, target))
                    player._currTp -= fracDebuff._cost
                    willAttack = true
                    debug("[DoT-KITE][DEBUFF] Applied FRACTURE (4 TP)")
                }
            }
        }

        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REMISSION)) {
            if (getCooldown(CHIP_REMISSION, player._id) == 0 && player._currTp >= 5) {
                push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_REMISSION, player._cellPos, player))
                player._currTp -= 5
                willAttack = true
                debug("[MAGIC][REMISSION] Used CHIP_REMISSION as TP dump (5 TP, heal ~100-150 HP)")
            }
        }

        context['willAttack'] = willAttack
        context['plannedWeapon'] = plannedWeapon
    }

    verifyHealingExecutable(healChip) {
        if (healChip == null) {
            debug("[HEAL-CHECK] No heal chip provided")
            return false
        }
        
        var chipId = healChip['chipId']
        var chipCost = getChipCost(chipId)
        
        debug("[HEAL-CHECK] Verifying " + getChipName(chipId) + " (cost: " + chipCost + " TP, have: " + player._currTp + " TP)")
        
        var cooldown = getCooldown(chipId, player._id)
        if (cooldown > 0) {
            debug("[HEAL-CHECK] Chip on cooldown: " + cooldown + " turns")
            return false
        }
        
        if (player._currTp < chipCost) {
            debug("[HEAL-CHECK] Insufficient TP: " + player._currTp + " < " + chipCost)
            return false
        }
        
        var minRange = getChipMinRange(chipId)
        var maxRange = getChipMaxRange(chipId)
        if (minRange > 0 || maxRange > 0) {
            var targetCell = this.findHealingTargetCell(chipId)
            if (targetCell == -1) {
                debug("[HEAL-CHECK] No valid target cell in range")
                return false
            }
        }
        
        var healAmount = this.estimateHealingAmount(chipId)
        if (healAmount < 50) {
            debug("[HEAL-CHECK] Heal amount too low: " + healAmount + " HP")
            return false
        }
        
        debug("[HEAL-CHECK] Healing executable: chip=" + getChipName(chipId) + 
              " TP=" + player._currTp + " heal=" + healAmount + " HP")
        return true
    }
    
    findHealingTargetCell(chipId) {
        var minRange = getChipMinRange(chipId)
        var maxRange = getChipMaxRange(chipId)
        
        if (minRange == 0 && maxRange == 0) {
            debug("[HEAL-TARGET] Self-target chip, returning player position")
            return player._cellPos
        }
        
        if (getChipArea(chipId) > 0) {
            
            debug("[HEAL-TARGET] AoE heal chip, returning player position")
            return player._cellPos
        }
        
        var distToSelf = 0  
        if (distToSelf >= minRange && distToSelf <= maxRange) {
            return player._cellPos
        }
        
        debug("[HEAL-TARGET] No valid target found for chip: " + getChipName(chipId))
        return -1
    }
    
    estimateHealingAmount(chipId) {
        var effects = getChipEffects(chipId)
        var totalHeal = 0
        
        debug("[HEAL-ESTIMATE] Estimating heal for " + getChipName(chipId))
        
        for (var effect in effects) {
            if (effect[0] == EFFECT_HEAL) {
                totalHeal += effect[1]  
                debug("[HEAL-ESTIMATE] Direct heal: " + effect[1])
            }
            
        }
        
        var chipType = 0
        if (totalHeal > 0 && chipType == 0) {
            var scaledHeal = totalHeal * (1 + player._wisdom / 1000)
            debug("[HEAL-ESTIMATE] Scaled with wisdom (" + player._wisdom + "): " + totalHeal + " -> " + scaledHeal)
            totalHeal = scaledHeal
        }
        
        debug("[HEAL-ESTIMATE] Total estimated heal: " + totalHeal)
        return totalHeal
    }
}
