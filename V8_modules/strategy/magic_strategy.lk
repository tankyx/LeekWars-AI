include('action.lk')
include('base_strategy.lk')
include('magic_antidote_tracker.lk')
include('magic_combo_system.lk')
include('magic_poison_planner.lk')

// ====================================================================
// MAGIC STRATEGY - Main Orchestration
// ====================================================================
// DoT kiting strategy with antidote baiting, GRAPPLE-COVID combo, and poison planning

class MagicStrategy extends Strategy {
    constructor() {
        super()
    }

    getStrategyName() {
        return "MAGIC"
    }

    // ====================================================================
    // MAIN ORCHESTRATION
    // ====================================================================

    createAndExecuteDotKite(target, targetHitCell) {
        arrayClear(this._actions)

        // Check if we should use defensive scenario instead (low HP + regeneration)
        var regenAvailable = false
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)) {
            var regenCooldown = getCooldown(CHIP_REGENERATION, getEntity())
            regenAvailable = (regenCooldown == 0)
        }

        if (getLife() * 100 < getTotalLife() * 35 && regenAvailable) {
            debug("[MAGIC] Low HP (<35%) and regeneration available, switching to defensive")
            this.createDefensiveScenario(target, targetHitCell)
            this.executeScenario()
            return
        }

        // PRIORITY 1: Check for chest
        var chest = fieldMap.getClosestChest()
        if (chest != null) {
            debug("[CHEST] Chest detected! Switching target (ID: " + chest._id + ")")
            target = chest
            targetHitCell = fieldMap.buildHitMap(chest._cellPos)
        }

        target.updateEntity()
        player.updateEntity()

        var poisonActive = target.hasEffect(EFFECT_POISON)
        var poisonRemaining = target.getEffectRemaining(EFFECT_POISON)
        debug("[DoT-KITE] Start poisonActive=" + poisonActive + " remaining=" + poisonRemaining + " TP=" + player._currTp + " MP=" + player._currMp)

        var enemyId = target._id

        // Update antidote tracking
        var antidoteState = AntidoteTracker.updateAntidoteState(target)
        var baiting = antidoteState['baiting']
        var enemyHasAntidote = antidoteState['enemyHasAntidote']
        var antidoteCD = getCooldown(CHIP_ANTIDOTE, enemyId)

        // POISON ATTRITION MODE: If poison will kill, hide and wait
        var shouldPlayDefensive = false
        if (poisonActive && poisonRemaining > 0 && !baiting) {
            var enemyHP = getLife(enemyId)
            var enemyMaxHP = getTotalLife(enemyId)
            var enemyHPPercent = (enemyHP * 100) / enemyMaxHP

            var poisonDamagePerTurn = player._magic * 0.5
            var turnsUntilAntidote = antidoteCD
            if (!enemyHasAntidote) turnsUntilAntidote = 999

            var turnsBeforeAntidote = min(poisonRemaining, turnsUntilAntidote)
            var poisonDamageBeforeAntidote = poisonDamagePerTurn * turnsBeforeAntidote

            var poisonWillKill = poisonDamageBeforeAntidote >= enemyHP
            var veryLowHP = enemyHPPercent < 30
            var lowHPWithAntidoteCD = enemyHPPercent < 50 && antidoteCD > 0

            if (poisonWillKill || veryLowHP || lowHPWithAntidoteCD) {
                shouldPlayDefensive = true
                debug("[ATTRITION] Poison active, enemyHP=" + enemyHP + "/" + enemyMaxHP + " (" + floor(enemyHPPercent) + "%) antidoteCD=" + antidoteCD + " turnsBeforeCleanse=" + turnsBeforeAntidote + " poisonDmg=" + floor(poisonDamageBeforeAntidote) + " willKill=" + poisonWillKill + " -> HIDE")
            }
        }

        // If defensive, skip attacks and hide
        if (shouldPlayDefensive) {
            var hnsInfo = fieldMap.findHideAndSeekCell()
            if (hnsInfo != null) {
                var hideCell = hnsInfo['cell']
                var pathLen = getPathLength(player._cellPos, hideCell)
                if (pathLen != null && pathLen <= player._currMp) {
                    push(this._actions, new Action(Action.MOVEMENT_HNS, -1, -1, hideCell, target))
                    player._currMp -= pathLen
                    debug("[ATTRITION] Moving to hide cell " + hideCell + " (danger=" + hnsInfo['danger'] + ")")
                    this.executeScenario()
                    return
                } else {
                    debug("[ATTRITION] Hide cell unreachable, fleeing")
                    push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
                    this.executeScenario()
                    return
                }
            } else {
                debug("[ATTRITION] No hide cell found, fleeing")
                push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
                this.executeScenario()
                return
            }
        }

        // Cell planning: Check for GRAPPLE-COVID combo opportunity
        var grappleCovidCell = -1
        var shouldPrioritizeCombo = false
        if (!baiting) {
            var hasCoreChips = mapContainsKey(arsenal.playerEquippedChips, CHIP_GRAPPLE) &&
                              mapContainsKey(arsenal.playerEquippedChips, CHIP_COVID) &&
                              mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)
            var coreChipsReady = getCooldown(CHIP_GRAPPLE, player._id) == 0 &&
                                getCooldown(CHIP_COVID, player._id) == 0 &&
                                getCooldown(CHIP_BOXING_GLOVE, player._id) == 0
            var hasTP = player._currTp >= 14

            if (hasCoreChips && coreChipsReady && hasTP) {
                grappleCovidCell = ComboSystem.findGrappleCovidCell(target)
                if (grappleCovidCell != -1) {
                    shouldPrioritizeCombo = true
                    debug("[COMBO-POSITIONING] Found optimal GRAPPLE-COVID cell: " + grappleCovidCell)
                }
            }
        }

        // Try approach-HNS for better staging
        var hnsStage = fieldMap.findApproachHideAndSeekCell(target)
        var poisonPlan = PoisonPlanner.selectBestPoisonCell(target)

        // Check CHIP_LEATHER_BOOTS before movement
        var plannedAttackCell = -1
        if (poisonPlan != null) plannedAttackCell = poisonPlan['cell']._id
        else if (targetHitCell != -1 && targetHitCell != null) plannedAttackCell = targetHitCell._id

        var hnsInfoPreCheck = fieldMap.findHideAndSeekCell()
        var hideCell = hnsInfoPreCheck != null ? hnsInfoPreCheck['cell'] : null
        if (!shouldPrioritizeCombo && plannedAttackCell != -1 && this.shouldUseLeatherBoots(plannedAttackCell, hideCell, 5)) {
            push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_LEATHER_BOOTS, player._cellPos, player))
            player._currTp -= 3
            player._currMp += 2
            debug("[DoT-KITE][LEATHER_BOOTS] Applied (+2 MP)")
        } else if (shouldPrioritizeCombo) {
            debug("[DoT-KITE][LEATHER_BOOTS] Skipping - reserving TP for GRAPPLE-COVID combo")
        }

        // OVERRIDE: Prioritize combo positioning
        if (shouldPrioritizeCombo && grappleCovidCell != -1) {
            if (mapContainsKey(fieldMap.damageMap, grappleCovidCell)) {
                targetHitCell = fieldMap.damageMap[grappleCovidCell]
            } else {
                targetHitCell = ['_id': grappleCovidCell, '_totalDamage': 0]
            }
            debug("[COMBO-POSITIONING] Overriding poison plan with combo cell " + grappleCovidCell)
        } else if (poisonPlan != null) {
            targetHitCell = poisonPlan['cell']
            debug("[DoT-KITE] Plan cell=" + targetHitCell._id + " chips=" + count(poisonPlan['chips']) + " weapons=" + count(poisonPlan['weapons']))
        } else if (targetHitCell == -1 || targetHitCell == null) {
            targetHitCell = fieldMap.getBestWeightedDamageCell(1.8, 1)
            if (targetHitCell != -1) debug("[DoT-KITE] Fallback weighted cell=" + targetHitCell._id)
        }

        // Consider approach-HNS alternative
        if (!shouldPrioritizeCombo && hnsStage != null && targetHitCell != -1) {
            var consider = false
            if (hnsStage['canAttack'] && poisonPlan == null) consider = true
            if (mapContainsKey(fieldMap.damageMap, hnsStage['cell']) && mapContainsKey(fieldMap.damageMap, targetHitCell._id)) {
                var hObj = fieldMap.damageMap[hnsStage['cell']]
                if (hObj._totalDamage == targetHitCell._totalDamage) {
                    var dCur = getPathLength(player._cellPos, targetHitCell._id)
                    var dH = getPathLength(player._cellPos, hObj._id)
                    if (dH != null && dCur != null && dH < dCur) consider = true
                }
            }
            if (consider) {
                if (mapContainsKey(fieldMap.damageMap, hnsStage['cell'])) {
                    targetHitCell = fieldMap.damageMap[hnsStage['cell']]
                    debug("[DoT-KITE][HNS-APPROACH] Switching to approach cell " + hnsStage['cell'])
                }
            }
        }

        // Execute movement immediately if combo positioning
        if (shouldPrioritizeCombo && targetHitCell != -1 && targetHitCell._id != player._cellPos) {
            debug("[COMBO-POSITIONING] Executing immediate movement to combo cell " + targetHitCell._id)
            push(this._actions, new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, targetHitCell._id, target))
            this.executeAndFlushActions()
            player._cellPos = getCell()
            debug("[COMBO-POSITIONING] Movement complete, now at cell " + player._cellPos)
        } else if (targetHitCell != -1 && targetHitCell._id != player._cellPos) {
            push(this._actions, new Action(Action.MOVEMENT_OFFENSIVE, -1, -1, targetHitCell._id, target))
        } else if (targetHitCell != -1) {
            debug("[DoT-KITE] Already positioned on cell " + targetHitCell._id)
        }

        var context = ['willAttack': false, 'plannedWeapon': getWeapon(), 'targetHitCell': targetHitCell, 'comboExecuted': false]

        if (baiting) {
            AntidoteTracker.createBaitOffensive(target, poisonPlan, context, this)
        } else {
            this.createFullOffensiveDoT(target, poisonPlan, context, poisonActive, poisonRemaining, shouldPrioritizeCombo)
        }

        // Opportunistic poke if no attack scheduled
        if (!context['willAttack']) {
            var activeW = getWeapon()
            if (activeW != null && mapContainsKey(arsenal.playerEquippedWeapons, activeW)) {
                var wObj = arsenal.playerEquippedWeapons[activeW]
                if (player._currTp >= wObj._cost && this.inRangeAndLOS(targetHitCell._id, target._cellPos, wObj._minRange, wObj._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    context['willAttack'] = true
                }
            }
        }

        // Movement after attacks: prefer Hide & Seek
        var originalMP = player._currMp
        var pathToAttack = 0
        if (targetHitCell != -1 && targetHitCell != null) pathToAttack = getPathLength(player._cellPos, targetHitCell._id)
        if (pathToAttack == null) pathToAttack = 0

        var hnsInfoKite = fieldMap.findHideAndSeekCell()
        var addedHide = false
        if (hnsInfoKite != null) {
            var hideCellIdK = hnsInfoKite['cell']
            var extraLeg = 0
            if (targetHitCell != -1 && targetHitCell != null && hideCellIdK != targetHitCell._id) {
                extraLeg = getPathLength(targetHitCell._id, hideCellIdK)
                if (extraLeg == null) extraLeg = 9999
            }

            if (hideCellIdK == player._cellPos) {
                // Already at hide cell
            } else {
                var totalNeeded = pathToAttack + extraLeg
                if (totalNeeded <= originalMP) {
                    if (hideCellIdK != (targetHitCell != -1 && targetHitCell != null ? targetHitCell._id : player._cellPos)) {
                        push(this._actions, new Action(Action.MOVEMENT_HNS, -1, -1, hideCellIdK, target))
                        addedHide = true
                        debug("[DoT-KITE][HNS] Added hide move to cell " + hideCellIdK + " danger=" + hnsInfoKite['danger'])
                    }
                } else {
                    debug("[DoT-KITE][HNS] Not enough MP for hide pathNeeded=" + totalNeeded + " MP=" + originalMP)
                }
            }
        }

        if (!addedHide) {
            push(this._actions, new Action(Action.MOVEMENT_FLEE, -1, -1, -1, target))
            debug("[DoT-KITE] Fallback flee movement")
        }

        debug("[DoT-KITE] Actions scheduled=" + count(this._actions) + " TP_end=" + player._currTp)
        this.executeScenario()
    }

    // ====================================================================
    // FULL OFFENSIVE (After antidote burned)
    // ====================================================================

    createFullOffensiveDoT(target, poisonPlan, context, poisonActive, poisonRemaining, comboPositioned) {
        debug("[FULL] ===== ENTERED FULL OFFENSIVE MODE =====")
        var targetHitCell = context['targetHitCell']
        var plannedWeapon = context['plannedWeapon']
        var willAttack = context['willAttack']

        // Check CHIP_ADRENALINE for extra DoT chip usage
        if (player._currTp < 6 && player._currTp >= 2) {
            if (this.shouldUseAdrenaline(6)) {
                push(this._actions, new Action(Action.ACTION_BUFF, -1, CHIP_ADRENALINE, player._cellPos, player))
                player._currTp -= 1
                player._currTp += 5
                debug("[DoT-KITE][ADRENALINE] Used Adrenaline, now have " + player._currTp + " TP")
            }
        }

        // Reserve TP for GRAPPLE-COVID combo if available
        var reservedTPForCombo = 0
        debug("[FULL] Checking GRAPPLE-COVID combo...")
        var canExecuteNow = ComboSystem.canUseGrappleCovidCombo(target)
        if (canExecuteNow) {
            var hasBNC = mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)
            var cdBNC = hasBNC ? getCooldown(CHIP_BALL_AND_CHAIN, player._id) : 1
            var includeBNC = hasBNC && cdBNC == 0 && player._currTp >= 19
            reservedTPForCombo = includeBNC ? 19 : 14
            debug("[FULL][GRAPPLE-COVID] Combo available NOW - reserving " + reservedTPForCombo + " TP (BNC=" + includeBNC + ")")
        } else if (comboPositioned) {
            debug("[FULL][GRAPPLE-COVID] Moving to combo cell - will execute NEXT turn")
        } else {
            debug("[FULL][GRAPPLE-COVID] Combo NOT available")
        }

        // PRIORITY 1: GRAPPLE-COVID combo (14-19 TP)
        if (canExecuteNow) {
            debug("[FULL][GRAPPLE-COVID] Executing combo NOW!")
            ComboSystem.executeGrappleCovidCombo(target)
            context['comboExecuted'] = true
            willAttack = true
        }
        // PRIORITY 2: Close-range COVID sequence (enemy within 0-2 range)
        else if (ComboSystem.isWithinCovidRange(target._cellPos)) {
            debug("[FULL][COVID-RANGE] Enemy at close range, applying COVID sequence")

            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_COVID)) {
                var covid = arsenal.playerEquippedChips[CHIP_COVID]
                if (getCooldown(CHIP_COVID, player._id) == 0 && player._currTp >= covid._cost) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, covid._minRange, covid._maxRange)) {
                        push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_COVID, target._cellPos, target))
                        player._currTp -= covid._cost
                        willAttack = true
                        debug("[FULL][COVID] Applied (8 TP)")
                    }
                }
            }

            // Apply BALL_AND_CHAIN
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
                var bnc = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
                if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0 && player._currTp >= bnc._cost) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, bnc._minRange, bnc._maxRange)) {
                        push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_BALL_AND_CHAIN, target._cellPos, target))
                        player._currTp -= bnc._cost
                        willAttack = true
                        debug("[FULL][BALL_AND_CHAIN] Applied (5 TP)")
                    }
                }
            }

            // Apply BOXING_GLOVE if adjacent and on same line
            var distToTarget2 = getCellDistance(player._cellPos, target._cellPos)
            if (distToTarget2 == 1 && isOnSameLine(player._cellPos, target._cellPos)) {
                if (mapContainsKey(arsenal.playerEquippedChips, CHIP_BOXING_GLOVE)) {
                    var boxing2 = arsenal.playerEquippedChips[CHIP_BOXING_GLOVE]
                    if (getCooldown(CHIP_BOXING_GLOVE, player._id) == 0 && player._currTp >= boxing2._cost) {
                        push(this._actions, new Action(Action.ACTION_DIRECT, -1, CHIP_BOXING_GLOVE, target._cellPos, target))
                        player._currTp -= boxing2._cost
                        willAttack = true
                        debug("[FULL][BOXING_GLOVE] Applied (2 TP) - pushing away")
                    }
                }
            }

            // Apply FRACTURE
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
                var frac2 = arsenal.playerEquippedChips[CHIP_FRACTURE]
                if (getCooldown(CHIP_FRACTURE, player._id) == 0 && player._currTp >= frac2._cost) {
                    if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, frac2._minRange, frac2._maxRange)) {
                        push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_FRACTURE, target._cellPos, target))
                        player._currTp -= frac2._cost
                        willAttack = true
                        debug("[FULL][FRACTURE] Applied (4 TP)")
                    }
                }
            }
        }

        // WEAPON SPAM FIRST: Use all weapon attacks before chips
        if (poisonPlan != null) {
            var wPlan = poisonPlan['weapons']
            for (var wpIdx = 0; wpIdx < count(wPlan); wpIdx++) {
                var wRec = wPlan[wpIdx]
                var wObj = wRec['weapon']
                if (player._currTp - reservedTPForCombo < 1) break

                // Swap if needed
                if (plannedWeapon != wObj._id && player._currTp >= 1) {
                    push(this._actions, new Action(Action.ACTION_WEAPON_SWAP, wObj._id, -1, target._cellPos, target))
                    player._currTp -= 1
                    plannedWeapon = wObj._id
                }

                // Spam weapon to max uses (ignore plan's conservative 'uses' value)
                var actualUses = 0
                while (actualUses < wObj._maxUse && player._currTp - reservedTPForCombo >= wObj._cost) {
                    push(this._actions, new Action(Action.ACTION_DIRECT, wObj._id, -1, target._cellPos, target))
                    player._currTp -= wObj._cost
                    actualUses += 1
                    willAttack = true
                }
                if (actualUses > 0) {
                    debug("[FULL][WEAPON-SPAM] Used " + getWeaponName(wObj._id) + " x" + actualUses + " TP_left=" + player._currTp)
                }
            }

            // THEN use poison chips with remaining TP
            var chipsToUse = poisonPlan['chips']
            for (var cidx = 0; cidx < count(chipsToUse); cidx++) {
                var pc = chipsToUse[cidx]
                if (player._currTp - reservedTPForCombo < pc._cost) break
                if (!this.inRangeAndLOS(targetHitCell._id, target._cellPos, pc._minRange, pc._maxRange)) continue
                push(this._actions, new Action(Action.ACTION_DIRECT, -1, pc._id, target._cellPos, target))
                player._currTp -= pc._cost
                willAttack = true
                debug("[FULL][CHIP] Used " + getChipName(pc._id) + " TP_left=" + player._currTp)
            }
        }

        // Fallback strongest chips (TOXIN, PLAGUE, others)
        if (player._currTp - reservedTPForCombo > 0) {
            var priorityChips = []
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_TOXIN)) push(priorityChips, arsenal.playerEquippedChips[CHIP_TOXIN])
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_PLAGUE)) push(priorityChips, arsenal.playerEquippedChips[CHIP_PLAGUE])
            var allPois = arsenal.getPoisonChipsSorted(player._strength, player._magic, player._wisdom)
            for (var addIdx = 0; addIdx < count(allPois); addIdx++) {
                var pcAdd = allPois[addIdx]
                if (pcAdd._id == CHIP_TOXIN || pcAdd._id == CHIP_PLAGUE) continue
                push(priorityChips, pcAdd)
            }

            for (var pIdx = 0; pIdx < count(priorityChips); pIdx++) {
                var chipP = priorityChips[pIdx]
                if (player._currTp - reservedTPForCombo < chipP._cost) continue
                if (getCooldown(chipP._id, player._id) > 0) continue
                if (!this.inRangeAndLOS(targetHitCell._id, target._cellPos, chipP._minRange, chipP._maxRange)) continue
                push(this._actions, new Action(Action.ACTION_DIRECT, -1, chipP._id, target._cellPos, target))
                player._currTp -= chipP._cost
                willAttack = true
            }
        }

        // OPPORTUNISTIC DEBUFFS with remaining TP
        if (player._currTp >= 5 && mapContainsKey(arsenal.playerEquippedChips, CHIP_BALL_AND_CHAIN)) {
            var bncDebuff = arsenal.playerEquippedChips[CHIP_BALL_AND_CHAIN]
            if (getCooldown(CHIP_BALL_AND_CHAIN, player._id) == 0) {
                if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, bncDebuff._minRange, bncDebuff._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_BALL_AND_CHAIN, target._cellPos, target))
                    player._currTp -= bncDebuff._cost
                    willAttack = true
                    debug("[DoT-KITE][DEBUFF] Applied BALL_AND_CHAIN (5 TP)")
                }
            }
        }

        if (player._currTp >= 4 && mapContainsKey(arsenal.playerEquippedChips, CHIP_FRACTURE)) {
            var fracDebuff = arsenal.playerEquippedChips[CHIP_FRACTURE]
            if (getCooldown(CHIP_FRACTURE, player._id) == 0) {
                if (this.inRangeAndLOS(targetHitCell._id, target._cellPos, fracDebuff._minRange, fracDebuff._maxRange)) {
                    push(this._actions, new Action(Action.ACTION_DEBUFF, -1, CHIP_FRACTURE, target._cellPos, target))
                    player._currTp -= fracDebuff._cost
                    willAttack = true
                    debug("[DoT-KITE][DEBUFF] Applied FRACTURE (4 TP)")
                }
            }
        }

        context['willAttack'] = willAttack
        context['plannedWeapon'] = plannedWeapon
    }
}
