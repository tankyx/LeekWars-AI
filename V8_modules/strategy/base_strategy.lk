include('action.lk')

class Strategy {
    _actions = []
    _playerTP = -1
    _fieldMap = null
    _currentWeaponId = -1  // Track currently equipped weapon

    constructor() {
        this._playerTP = getTP()
        this._currentWeaponId = getWeapon()
    }

    // Helper to centralize repeated distance and line-of-sight checks.
    inRangeAndLOS(fromCell, targetCell, minR, maxR) {
        var dist = getCellDistance(fromCell, targetCell)
        if (dist < minR || dist > maxR) return false
        if (!lineOfSight(fromCell, targetCell)) return false
        return true
    }

    // Validate attack geometry from position with item (weapon or chip)
    // Returns: map with {valid: bool, distance: int}
    // Use this for comprehensive item-aware validation
    validateAttackGeometry(fromCell, targetCell, item) {
        var dist = getCellDistance(fromCell, targetCell)
        if (dist == null) return ['valid': false, 'distance': -1]

        if (dist < item._minRange || dist > item._maxRange) {
            return ['valid': false, 'distance': dist]
        }

        if (!lineOfSight(fromCell, targetCell)) {
            return ['valid': false, 'distance': dist]
        }

        return ['valid': true, 'distance': dist]
    }

    // Helper to check if chip is available (equipped, off cooldown, sufficient TP)
    isChipAvailable(chipId, requiredTP = -1) {
        if (!mapContainsKey(arsenal.playerEquippedChips, chipId)) return false
        if (getCooldown(chipId, player._id) > 0) return false
        if (requiredTP > 0 && player._currTp < requiredTP) return false
        return true
    }

    // Check if CHIP_ADRENALINE should be used tactically
    // CHIP_ADRENALINE: 1 TP cost, +5 TP gain (net +4 TP)
    // Use when short 1-4 TP for required action
    shouldUseAdrenaline(requiredTP) {
        if (!this.isChipAvailable(CHIP_ADRENALINE)) return false

        var playerTP = player._currTp
        // Only use if we're short of required TP by 1-4 points (Adrenaline gives +4 net TP)
        var shortage = requiredTP - playerTP
        if (shortage >= 1 && shortage <= 4) {
            debug("[ADRENALINE] Short " + shortage + " TP (have " + playerTP + " need " + requiredTP + ") - using Adrenaline")
            return true
        }

        return false
    }

    // Check if CHIP_LEATHER_BOOTS should be used for positioning
    // CHIP_LEATHER_BOOTS: 3 TP cost, +2 MP for 2 turns
    // targetCell: primary destination (attack position)
    // secondaryCell: optional secondary destination (hide cell after attack)
    // minRemainingTP: minimum TP needed after boots for meaningful actions
    shouldUseLeatherBoots(targetCell, secondaryCell = -1, minRemainingTP = 7) {
        if (!this.isChipAvailable(CHIP_LEATHER_BOOTS, 3)) return false

        var playerTP = player._currTp
        // Validate TP budget (3 TP for boots + attacks)
        if (!this.validateTPBudget(3)) return false

        // Need TP for boots + at least minRemainingTP for attacks
        if (playerTP < 3 + minRemainingTP) return false

        // Check if we already have MP buff active
        var hasMPBuff = player.hasEffect(EFFECT_BUFF_MP)
        if (hasMPBuff) {
            debug("[LEATHER_BOOTS] MP buff already active")
            return false
        }

        var playerMP = player._currMp
        var pathLen = getPathLength(player._cellPos, targetCell)
        if (pathLen == null) return false

        // Case 1: Simple check - target cell unreachable but within MP+2 range
        if (secondaryCell == -1) {
            if (pathLen > playerMP && pathLen <= playerMP + 2) {
                debug("[LEATHER_BOOTS] Target cell unreachable (need " + pathLen + " MP, have " + playerMP + ") - using boots")
                return true
            }
        }
        // Case 2: Complex check - two destinations (attack + hide)
        else {
            var pathToSecondary = getPathLength(targetCell, secondaryCell)
            if (pathToSecondary == null) return false

            var totalNeeded = pathLen + pathToSecondary
            if (totalNeeded > playerMP && totalNeeded <= playerMP + 2) {
                debug("[LEATHER_BOOTS] Hide cell unreachable after attack (need " + totalNeeded + " MP, have " + playerMP + ") - using boots")
                return true
            }
        }

        return false
    }

    // Generic stat buff check (consolidates STEROID, WARM_UP, etc.)
    // chipId: CHIP_STEROID, CHIP_WARM_UP, etc.
    // buffEffectId: EFFECT_BUFF_STRENGTH, EFFECT_BUFF_AGILITY, etc.
    // minTP: minimum TP required (buff cost + attack reserve)
    // minTurnsRemaining: reapply threshold (default 1)
    shouldApplyStatBuff(chipId, buffEffectId, minTP, minTurnsRemaining = 1) {
        if (!this.isChipAvailable(chipId)) return false

        var playerTP = player._currTp
        if (playerTP < minTP) return false

        // Check if buff already active
        if (player.hasEffect(buffEffectId)) {
            var buffRemaining = player.getEffectRemaining(buffEffectId)
            if (buffRemaining > minTurnsRemaining) {
                return false  // Still active
            }
            return true  // Expiring soon, reapply
        }

        return true  // Not active, apply
    }

    // Calculate minimum TP needed for meaningful attack from current position
    // Returns: minimum TP for at least one weapon use + swap (if needed)
    calculateMinimumAttackTP() {
        var playerPos = player._cellPos

        // Check if any weapon is available from current position
        var minWeaponTP = 999
        if (mapContainsKey(fieldMap.damageMap, playerPos)) {
            var cellObj = fieldMap.damageMap[playerPos]
            if (cellObj._weaponsList != null && count(cellObj._weaponsList) > 0) {
                for (var w in cellObj._weaponsList) {
                    var swapCost = (this._currentWeaponId != w._id) ? 1 : 0
                    var totalCost = swapCost + w._cost
                    if (totalCost < minWeaponTP) {
                        minWeaponTP = totalCost
                    }
                }
            }
        }

        // Fallback: assume need swap + cheapest weapon (typically 6-7 TP)
        if (minWeaponTP == 999) {
            // Get cheapest equipped weapon
            var cheapestCost = 999
            for (var wid in mapKeys(arsenal.playerEquippedWeapons)) {
                var wObj = arsenal.playerEquippedWeapons[wid]
                if (wObj._cost < cheapestCost) cheapestCost = wObj._cost
            }
            minWeaponTP = 1 + cheapestCost  // Swap + use
        }

        return minWeaponTP
    }

    // Validate TP budget before spending on buff/utility
    // buffCost: TP cost of buff/utility chip
    // Returns: true if safe to use buff (enough TP left for attacks)
    validateTPBudget(buffCost) {
        var playerTP = player._currTp
        var minAttackTP = this.calculateMinimumAttackTP()
        var remainingTP = playerTP - buffCost

        if (remainingTP >= minAttackTP) {
            return true
        }

        debug("[TP-BUDGET] Cannot afford buff (cost=" + buffCost + " remaining=" + remainingTP + " need=" + minAttackTP + ")")
        return false
    }

    // Get strategy name for debug logging (override in subclasses)
    getStrategyName() {
        return "BASE"
    }

    // Strategy-specific debug helper (adds strategy prefix)
    debugStrategy(message) {
        debug("[" + this.getStrategyName() + "] " + message)
    }

    // Find best reachable damage cell within MP budget
    // Returns Cell object from damageMap or null if no reachable cells
    findBestReachableDamageCell(maxMP) {
        var playerPos = player._cellPos
        var bestCell = null
        var bestDamage = -1
        var bestDist = 99999

        for (var c in fieldMap.damageMap) {
            var pathLen = getPathLength(playerPos, c._id)
            if (pathLen == null || pathLen > maxMP) continue  // Skip unreachable cells

            // Prioritize: 1) highest damage, 2) closest distance
            if (c._totalDamage > bestDamage || (c._totalDamage == bestDamage && pathLen < bestDist)) {
                bestDamage = c._totalDamage
                bestCell = c
                bestDist = pathLen
            }
        }

        if (bestCell != null) {
            debug("[REACHABLE-CELL] Found best reachable damage cell: " + bestCell._id + " damage=" + bestDamage + " dist=" + bestDist)
        } else {
            debug("[REACHABLE-CELL] No reachable damage cells within " + maxMP + " MP")
        }

        return bestCell
    }

    // Find best damage cell along path to target cell (for fighting retreat)
    // Returns Cell object from damageMap that's on the path, or null if no damage cells on path
    findBestDamageCellOnPath(targetCell, maxMP) {
        var playerPos = player._cellPos

        // Get FULL path to target (without MP limit to get all cells on path)
        var pathCells = getPath(playerPos, targetCell)
        if (pathCells == null || count(pathCells) == 0) {
            debug("[FLEE-PATH] No path to target cell " + targetCell)
            return null
        }

        var bestCell = null
        var bestDamage = -1
        var bestDist = 99999

        // Check each cell on path (excluding start, only reachable cells)
        for (var i = 0; i < count(pathCells); i++) {
            var cell = pathCells[i]

            // Skip current position
            if (cell == playerPos) continue

            // Check if cell is reachable with current MP
            var distToCell = getPathLength(playerPos, cell)
            if (distToCell == null || distToCell > maxMP) continue

            // Check if this cell is in damage map
            if (mapContainsKey(fieldMap.damageMap, cell)) {
                var cellObj = fieldMap.damageMap[cell]
                // Prioritize: 1) highest damage, 2) closest to current position
                if (cellObj._totalDamage > bestDamage || (cellObj._totalDamage == bestDamage && distToCell < bestDist)) {
                    bestDamage = cellObj._totalDamage
                    bestCell = cellObj
                    bestDist = distToCell
                }
            }
        }

        if (bestCell != null) {
            debug("[FLEE-PATH] Found damage cell " + bestCell._id + " on flee path (damage=" + bestDamage + ", dist=" + bestDist + ")")
        } else {
            debug("[FLEE-PATH] No reachable damage cells on flee path to " + targetCell + " (maxMP=" + maxMP + ")")
        }

        return bestCell
    }

    turnOneBuffs() {
        debug("Applying turn one buffs if available")
        debug("Dumping equipped chips:")
        for (var c in mapKeys(arsenal.playerEquippedChips)) {
            debug(" - " + getChipName(c))
        }

        // PRIORITY 1: Stat-based primary buffs (applied before other buffs for maximum effect)
        // Strength build: Apply CHIP_STEROID for weapon damage boost
        if (player._strength >= player._agility && player._strength >= player._magic) {
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_STEROID)) {
                debug("Using CHIP_STEROID (strength build) - +150-170 Strength for 3 turns")
                useChip(CHIP_STEROID, player._id)
            }
        }

        // Agility build: Apply CHIP_WARM_UP before damage return buffs
        if (player._agility >= player._strength && player._agility >= player._magic) {
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_WARM_UP)) {
                debug("Using CHIP_WARM_UP (agility build) - +170-190 Agility for 3 turns")
                useChip(CHIP_WARM_UP, player._id)
            }
            // Then apply damage return for tanky playstyle
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_MIRROR)) {
                debug("Using CHIP_MIRROR (agility build) - Damage return")
                useChip(CHIP_MIRROR, player._id)
            }
        }

        // PRIORITY 2: Universal stat buffs
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_KNOWLEDGE)) {
            debug("Using CHIP_KNOWLEDGE - Science/Magic boost")
            useChip(CHIP_KNOWLEDGE, player._id)
        }
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ARMORING)) {
            debug("Using CHIP_ARMORING - Resistance boost")
            useChip(CHIP_ARMORING, player._id)
        }
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_ELEVATION)) {
            debug("Using CHIP_ELEVATION - Wisdom boost")
            useChip(CHIP_ELEVATION, player._id)
        }

        // PRIORITY 3: Weapon selection
        if (getWeapon() == null) {
            setWeapon(arsenal.getHighestDamageWeapon())
        }

        // NOTE: CHIP_ADRENALINE is reserved for tactical mid-combat usage (not turn 1)
        // NOTE: CHIP_LEATHER_BOOTS is reserved for positioning scenarios (not turn 1)
    }

    createMovementAction(type, targetHitCellID, target) {
        push(this._actions, new Action(
            type,
            -1,
            -1,
            targetHitCellID,
            target
        ))
        debug("Planned movement action: Type " + type + " to cell " + targetHitCellID + " towards entity " + getName(target._id))
    }

    createAttackAction(type, target, weaponID = -1, chipID = -1) {
        push(this._actions, new Action(
            type,
            weaponID,
            chipID,
            target._cellPos,
            target
        ))
        debug("Planned attack action: Type " + type + " on entity " + getName(target._id) + " with weapon " + getWeaponName(weaponID) + " and chip " + getChipName(chipID))
    }

    createOffensiveScenario(target, targetHitCell) {
        // If magic oriented, optionally re-select target cell giving higher weight to DoT
        if (player._magic > player._strength) {
            // heuristic weights: treat total DoT as 1.5x direct for magic builds
            var weightedCell = fieldMap.getBestWeightedDamageCell(1.5, 1)
            if (weightedCell != -1) {
                targetHitCell = weightedCell
            }
        }
        // BEFORE committing to original target cell, see if an approach-hide cell is superior (can still attack + less danger)
        var hnsApproach = fieldMap.findApproachHideAndSeekCell(target)
        if (hnsApproach != null) {
            // Replace target cell if it allows attack or if original target not set
            var adopt = false
            if (hnsApproach['canAttack'] || targetHitCell == -1) adopt = true
            else if (targetHitCell != -1 && targetHitCell != null) {
                // If current target has same total damage but is farther, adopt HNS
                if (mapContainsKey(fieldMap.damageMap, hnsApproach['cell']) && mapContainsKey(fieldMap.damageMap, targetHitCell._id)) {
                    var hCellObj = fieldMap.damageMap[hnsApproach['cell']]
                    if (hCellObj._totalDamage == targetHitCell._totalDamage) {
                        var distCurrent = getPathLength(player._cellPos, targetHitCell._id)
                        var distH = getPathLength(player._cellPos, hCellObj._id)
                        if (distH != null && distCurrent != null && distH < distCurrent) adopt = true
                    }
                }
            }
            if (adopt) {
                if (targetHitCell != -1 && targetHitCell != null && targetHitCell._id != hnsApproach['cell']) {
                    debug("[HNS-APPROACH] Replacing offensive target cell with safer approach cell " + hnsApproach['cell'])
                }
                // Wrap chosen id into existing cell object if present in damageMap
                if (mapContainsKey(fieldMap.damageMap, hnsApproach['cell'])) {
                    targetHitCell = fieldMap.damageMap[hnsApproach['cell']]
                } else {
                    // Fallback: fabricate minimal Cell proxy with id for movement if not a damage cell
                    targetHitCell = new Cell(hnsApproach['cell'], false, -1, 0, 0, false, -1, -1)
                }
            }
        }
        // First, we check if we can reach the target hit cell
        var playerPos = player._cellPos
        var playerMP = player._currMp
        var playerTP = player._currTp
        var pathLength = getPathLength(playerPos, targetHitCell._id)

        debug("Player position: " + playerPos)
        debug("Player MP: " + playerMP + " Player TP: " + playerTP)
        debug("Path length to target hit cell: " + pathLength)

        if (pathLength > playerMP) {
            // Can't reach the target hit cell, we move as close as possible
            createMovementAction(Action.MOVEMENT_APPROACH, targetHitCell._id, target)
            debug("Can't reach target hit cell, moving as close as possible")
            return;
        }
        // We can reach the target hit cell, move only if not already there
        if (pathLength > 0) {
            createMovementAction(Action.MOVEMENT_OFFENSIVE, targetHitCell._id, target)
        } else {
            debug("Already on optimal offensive cell (" + targetHitCell._id + ") skipping movement")
        }

        playerPos = targetHitCell._id
        playerMP -= pathLength

        // Decide primary offensive resource (weapon or chip) based on cell best type
        if (targetHitCell._bestType == 0 && targetHitCell._highestDamageWeapon != -1) {
            // Weapon path
            if (getWeapon() != targetHitCell._highestDamageWeapon._id) {
                if (playerTP < 1 + targetHitCell._highestDamageWeapon._cost) {
                    debug("Not enough TP to swap and use weapon " + getWeaponName(targetHitCell._highestDamageWeapon._id))
                } else {
                    createAttackAction(Action.ACTION_WEAPON_SWAP, target, targetHitCell._highestDamageWeapon._id, -1)
                    playerTP -= 1
                }
            }
            var useCount = targetHitCell._highestDamageWeapon._maxUse
            while (playerTP >= targetHitCell._highestDamageWeapon._cost && useCount > 0) {
                createAttackAction(Action.ACTION_DIRECT, target, targetHitCell._highestDamageWeapon._id, -1)
                playerTP -= targetHitCell._highestDamageWeapon._cost
                useCount -= 1
            }
        }
        else if (targetHitCell._bestType == 1 && targetHitCell._highestDamageChip != -1) {
            // Chip path
            var chipRef = targetHitCell._highestDamageChip
            // Use chip as many times as allowed by TP and maxUse
            var chipUses = chipRef._maxUse
            while (playerTP >= chipRef._cost && chipUses > 0) {
                createAttackAction(Action.ACTION_DIRECT, target, -1, chipRef._id)
                playerTP -= chipRef._cost
                chipUses -= 1
            }
        }

        // No more TP or uses on primary weapon; evaluate other weapons
        var primaryWid = -1
        if (targetHitCell._highestDamageWeapon != -1 && targetHitCell._highestDamageWeapon != null) primaryWid = targetHitCell._highestDamageWeapon._id
        var weaponIds = mapKeys(arsenal.playerEquippedWeapons)
        for (var wi = 0; wi < count(weaponIds); wi++) {
            var wid = weaponIds[wi]
            var wObj = arsenal.playerEquippedWeapons[wid]
            if (wObj == null) continue
            if (wObj._id == primaryWid) continue
            if (playerTP < wObj._cost + 1) {
                debug("Skipping weapon " + getWeaponName(wObj._id) + " since not enough TP for swap and use")
                continue
            }
            debug("Checking weapon " + getWeaponName(wObj._id) + " for possible use")
            var secondHitCell = fieldMap.getClosestHitCellForWeapon(wObj)
            if (secondHitCell == -1) {
                debug("No reachable hit cell found for weapon " + getWeaponName(wObj._id))
                continue
            }
            var secondPathLength = getPathLength(playerPos, secondHitCell._id)
            if (secondPathLength != null && secondPathLength <= playerMP) {
                if (secondPathLength > 0) {
                    createMovementAction(Action.MOVEMENT_OFFENSIVE, secondHitCell._id, target)
                    playerMP -= secondPathLength
                } else {
                    debug("Already on secondary weapon cell for " + getWeaponName(wObj._id))
                }
                createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                playerTP -= 1
                while (playerTP >= wObj._cost) {
                    createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                    playerTP -= wObj._cost
                }
            }
        }

        // Consider spare TP for secondary source (weapon after chip or chip after weapon)
        if (playerTP > 0) {
            if (targetHitCell._bestType == 0) {
                // After weapon usage, try damaging chips
                for (var c in arsenal.playerEquippedChips) {
                    if (playerTP < c._cost) continue
                    if (!mapContainsKey(c._effects, EFFECT_DAMAGE) && !mapContainsKey(c._effects, EFFECT_POISON)) continue
                    createAttackAction(Action.ACTION_DIRECT, target, -1, c._id)
                    playerTP -= c._cost
                }
            } else {
                // After chip usage, attempt remaining weapon attacks with current or swap if efficient
                var activeWeapon = getWeapon()
                if (activeWeapon != null && mapContainsKey(arsenal.playerEquippedWeapons, activeWeapon)) {
                    var aw = arsenal.playerEquippedWeapons[activeWeapon]
                    var useCount2 = aw._maxUse
                    while (playerTP >= aw._cost && useCount2 > 0) {
                        createAttackAction(Action.ACTION_DIRECT, target, aw._id, -1)
                        playerTP -= aw._cost
                        useCount2 -= 1
                    }
                }
            }
        }

        // Post-offensive Hide & Seek: attempt to relocate to a safer cell with remaining MP
        // playerMP tracks remaining MP after initial approach earlier in this function.
        if (playerMP > 0) {
            var hnsInfo = fieldMap.findHideAndSeekCell()
            if (hnsInfo != null) {
                var hideCellId = hnsInfo['cell']
                if (hideCellId != targetHitCell._id) {
                    var legLen = getPathLength(targetHitCell._id, hideCellId)
                    if (legLen != null && legLen <= playerMP) {
                        debug("[HNS] Scheduling post-attack hide move to cell " + hideCellId + " danger=" + hnsInfo['danger'])
                        createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
                        playerMP -= legLen
                    } else if (legLen != null) {
                        debug("[HNS] Can't reach hide cell after attack (need " + legLen + " have " + playerMP + ")")
                    }
                } else {
                    debug("[HNS] Attack cell already optimal hide cell (danger=" + hnsInfo['danger'] + ")")
                }
            }
        }
    }

    // Shared weapon-focused combat logic for Strength and Agility strategies
    // Returns map with remaining MP/TP after combat
    // chipExclusionList: chips to exclude from damage chip usage (e.g., CHIP_MIRROR/THORN for agility)
    executeWeaponFocusedOffensive(target, bestWeaponCell, playerPos, playerMP, playerTP, chipExclusionList, debugPrefix) {
        var currentWeaponId = this._currentWeaponId  // Use tracked weapon state

        // HNS-approach cell check (safer positioning)
        var hnsApproach = fieldMap.findApproachHideAndSeekCell(target)
        if (hnsApproach != null && hnsApproach['canAttack'] && mapContainsKey(fieldMap.damageMap, hnsApproach['cell'])) {
            var hCellObj = fieldMap.damageMap[hnsApproach['cell']]
            if (hCellObj._highestDamageWeapon != -1) {
                var distOrig = getPathLength(playerPos, bestWeaponCell._id)
                var distH = getPathLength(playerPos, hCellObj._id)
                if (distH != null && distOrig != null && hCellObj._weaponDamage >= bestWeaponCell._weaponDamage && distH < distOrig) {
                    debug("[" + debugPrefix + "][HNS-APPROACH] Switching weapon cell to safer/closer cell " + hCellObj._id)
                    bestWeaponCell = hCellObj
                }
            }
        }

        // Movement to weapon cell
        var pathLen = getPathLength(playerPos, bestWeaponCell._id)
        if (pathLen == null) pathLen = 99999
        debug("[" + debugPrefix + "] Movement check: pathLen=" + pathLen + " playerMP=" + playerMP + " bestWeaponCell=" + bestWeaponCell._id + " playerPos=" + playerPos)
        var reachedWeaponCell = false
        if (pathLen > playerMP) {
            // Best cell unreachable - find best reachable alternative
            debug("[" + debugPrefix + "] Best cell " + bestWeaponCell._id + " unreachable (need " + pathLen + " MP, have " + playerMP + ")")
            var reachableCell = this.findBestReachableDamageCell(playerMP)

            if (reachableCell != null && reachableCell._id != playerPos) {
                // Move to best reachable damage cell
                this.createMovementAction(Action.MOVEMENT_APPROACH, reachableCell._id, target)
                debug("[" + debugPrefix + "] Moving to best reachable cell " + reachableCell._id + " (damage=" + reachableCell._totalDamage + ")")

                // Execute movement immediately to get actual position
                this.executeAndFlushActions()
                playerPos = player._cellPos
                playerMP = player._currMp
                playerTP = player._currTp
                currentWeaponId = getWeapon()
                debug("[" + debugPrefix + "] After movement execution: pos=" + playerPos + " MP=" + playerMP + " TP=" + playerTP + " weapon=" + getWeaponName(currentWeaponId))

                // Check if we actually reached the reachable cell
                if (playerPos == reachableCell._id) {
                    reachedWeaponCell = true
                    bestWeaponCell = reachableCell  // Update best cell to the one we reached
                }
            } else {
                // No reachable damage cells - try LEATHER_BOOTS for emergency movement boost
                debug("[" + debugPrefix + "] No reachable damage cells within " + playerMP + " MP")

                var usedLeatherBoots = false
                if (mapContainsKey(arsenal.playerEquippedChips, CHIP_LEATHER_BOOTS) &&
                    getCooldown(CHIP_LEATHER_BOOTS, player._id) == 0 &&
                    playerTP >= 3) {
                    // Use LEATHER_BOOTS for +3 MP boost
                    debug("[" + debugPrefix + "] EMERGENCY: Using LEATHER_BOOTS for +3 MP (current: " + playerMP + ")")
                    useChip(CHIP_LEATHER_BOOTS, player._id)
                    playerTP -= 3
                    playerMP = player._currMp  // Refresh MP after boots
                    usedLeatherBoots = true

                    // Re-check for reachable cells with boosted MP
                    reachableCell = this.findBestReachableDamageCell(playerMP)

                    if (reachableCell != null && reachableCell._id != playerPos) {
                        // Found reachable cell with boosted MP!
                        this.createMovementAction(Action.MOVEMENT_APPROACH, reachableCell._id, target)
                        debug("[" + debugPrefix + "] Moving to reachable cell " + reachableCell._id + " (with LEATHER_BOOTS boost)")

                        this.executeAndFlushActions()
                        playerPos = player._cellPos
                        playerMP = player._currMp
                        playerTP = player._currTp
                        currentWeaponId = getWeapon()
                        debug("[" + debugPrefix + "] After boosted movement: pos=" + playerPos + " MP=" + playerMP + " TP=" + playerTP)

                        if (playerPos == reachableCell._id) {
                            reachedWeaponCell = true
                            bestWeaponCell = reachableCell
                        }
                    }
                }

                // Still no reachable cells - move toward enemy to close distance
                if (reachableCell == null) {
                    debug("[" + debugPrefix + "] " + (usedLeatherBoots ? "Even with LEATHER_BOOTS, no" : "No") + " reachable damage cells - moving toward enemy")
                    if (playerMP > 0) {
                        this.createMovementAction(Action.MOVEMENT_APPROACH, target._cellPos, target)
                        this.executeAndFlushActions()
                        playerPos = player._cellPos
                        playerMP = player._currMp
                        playerTP = player._currTp
                        currentWeaponId = getWeapon()
                        debug("[" + debugPrefix + "] After approach movement: pos=" + playerPos + " MP=" + playerMP)
                    }
                }
            }

        } else if (pathLen > 0) {
            this.createMovementAction(Action.MOVEMENT_OFFENSIVE, bestWeaponCell._id, target)
            playerMP -= pathLen
            playerPos = bestWeaponCell._id
            reachedWeaponCell = true
        } else {
            debug("[" + debugPrefix + "] Already on best weapon cell " + bestWeaponCell._id)
            reachedWeaponCell = true
        }

        debug("[" + debugPrefix + "] After movement logic: reachedWeaponCell=" + reachedWeaponCell + " playerPos=" + playerPos + " playerMP=" + playerMP)

        // Validate that current position has attack options (safety check)
        if (!reachedWeaponCell && playerMP == 0) {
            var curCellCheck = mapContainsKey(fieldMap.damageMap, playerPos) ? fieldMap.damageMap[playerPos] : null
            if (curCellCheck == null || (count(curCellCheck._weaponsList) == 0 && count(curCellCheck._chipsList) == 0)) {
                debug("[" + debugPrefix + "] WARNING: Ended at position " + playerPos + " with no attacks available!")
            }
        }

        // Primary weapon usage (only if we reached the weapon cell)
        var primaryWeapon = bestWeaponCell._highestDamageWeapon
        debug("[" + debugPrefix + "] Primary weapon: reachedWeaponCell=" + reachedWeaponCell + " primaryWeapon=" + (primaryWeapon != -1 && primaryWeapon != null ? getWeaponName(primaryWeapon._id) : "none") + " currentWeapon=" + getWeaponName(currentWeaponId) + " playerTP=" + playerTP)
        if (reachedWeaponCell && primaryWeapon != -1 && primaryWeapon != null) {
            if (currentWeaponId != primaryWeapon._id) {
                debug("[" + debugPrefix + "] Need weapon swap: current=" + getWeaponName(currentWeaponId) + " -> target=" + getWeaponName(primaryWeapon._id) + " (TP=" + playerTP + " need=" + (1 + primaryWeapon._cost) + ")")
                if (playerTP >= 1 + primaryWeapon._cost) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, primaryWeapon._id, -1)
                    playerTP -= 1
                    currentWeaponId = primaryWeapon._id  // Track weapon swap
                    debug("[" + debugPrefix + "] Created weapon swap action")
                } else {
                    debug("[" + debugPrefix + "] Not enough TP to swap and use primary weapon " + getWeaponName(primaryWeapon._id))
                }
            } else {
                debug("[" + debugPrefix + "] Weapon already equipped: " + getWeaponName(currentWeaponId))
            }
            var uses = primaryWeapon._maxUse
            while (playerTP >= primaryWeapon._cost && uses > 0) {
                this.createAttackAction(Action.ACTION_DIRECT, target, primaryWeapon._id, -1)
                playerTP -= primaryWeapon._cost
                uses -= 1
            }
        } else if (!reachedWeaponCell) {
            debug("[" + debugPrefix + "] Did not reach weapon cell - will use weapons from current position " + playerPos)
        }

        // Secondary weapons (use weapons available from current position)
        var primaryWid = (reachedWeaponCell && primaryWeapon != -1 && primaryWeapon != null) ? primaryWeapon._id : -1
        var curCellObj = null
        if (mapContainsKey(fieldMap.damageMap, playerPos)) {
            curCellObj = fieldMap.damageMap[playerPos]
        }

        if (curCellObj != null && count(curCellObj._weaponsList) > 0) {
            // Use weapons directly from cell's _weaponsList (already pre-calculated)
            for (var wL = 0; wL < count(curCellObj._weaponsList); wL++) {
                var wObj = curCellObj._weaponsList[wL]
                if (wObj == null) continue
                if (wObj._id == primaryWid) continue  // Skip primary weapon (already used)
                if (playerTP < wObj._cost) continue  // Need at least weapon cost

                // Only swap if weapon not already equipped
                if (currentWeaponId != wObj._id) {
                    if (playerTP < 1) continue  // Need 1 TP for swap
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, wObj._id, -1)
                    playerTP -= 1
                    currentWeaponId = wObj._id  // Track weapon swap
                }

                var uses2 = wObj._maxUse
                while (playerTP >= wObj._cost && uses2 > 0) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, wObj._id, -1)
                    playerTP -= wObj._cost
                    uses2 -= 1
                }
            }
        } else {
            debug("[" + debugPrefix + "] No weapons available from current position " + playerPos)
        }

        // Spend leftover TP on damage/poison chips (use chips available from current position)
        if (playerTP > 0 && curCellObj != null && count(curCellObj._chipsList) > 0) {
            var dmgChips = []
            // Use chips directly from cell's _chipsList (already pre-calculated with range/LOS)
            for (var cL = 0; cL < count(curCellObj._chipsList); cL++) {
                var chipObj = curCellObj._chipsList[cL]
                if (chipObj == null) continue

                // Skip excluded chips (e.g., CHIP_MIRROR/THORN for agility)
                var excluded = false
                for (var ex = 0; ex < count(chipExclusionList); ex++) {
                    if (chipObj._id == chipExclusionList[ex]) {
                        excluded = true
                        break
                    }
                }
                if (excluded) continue

                // Filter attack chips (damage or poison effects)
                if (!mapContainsKey(chipObj._effects, EFFECT_DAMAGE) && !mapContainsKey(chipObj._effects, EFFECT_POISON)) continue

                var bd = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, chipObj._id)
                push(dmgChips, ['chip': chipObj, 'per': bd['total']])
            }

            // Selection sort descending by per-use total damage
            for (var i = 0; i < count(dmgChips); i++) {
                var bestIdx = i
                for (var j = i + 1; j < count(dmgChips); j++) {
                    if (dmgChips[j]['per'] > dmgChips[bestIdx]['per']) bestIdx = j
                }
                if (bestIdx != i) {
                    var tmp = dmgChips[i]
                    dmgChips[i] = dmgChips[bestIdx]
                    dmgChips[bestIdx] = tmp
                }
            }

            for (var dc = 0; dc < count(dmgChips); dc++) {
                var rec = dmgChips[dc]
                var chipUse = rec['chip']
                if (playerTP < chipUse._cost) continue
                // Spam chip until max uses OR TP exhausted
                var actualUsesC = 0
                while (actualUsesC < chipUse._maxUse && playerTP >= chipUse._cost) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, -1, chipUse._id)
                    playerTP -= chipUse._cost
                    actualUsesC += 1
                }
                if (playerTP <= 0) break
            }
        }

        // Post-offensive HNS relocation (break line of sight with remaining MP)
        if (playerMP > 0) {
            var hnsInfo = fieldMap.findHideAndSeekCell()
            if (hnsInfo != null) {
                var hideCellId = hnsInfo['cell']
                if (hideCellId != playerPos) {
                    var legLen = getPathLength(playerPos, hideCellId)
                    if (legLen != null && legLen <= playerMP) {
                        debug("[" + debugPrefix + "][HNS] Adding hide move to cell " + hideCellId + " danger=" + hnsInfo['danger'])
                        this.createMovementAction(Action.MOVEMENT_HNS, hideCellId, target)
                        playerMP -= legLen
                    }
                }
            }
        }

        return ['playerMP': playerMP, 'playerTP': playerTP]
    }

    // Base defensive scenario usable by all strategies
    createDefensiveScenario(target, targetHitCell) {
        // Optional self-heal before moving away if chip is equipped and usable
        if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)) {
            var regenChip = arsenal.playerEquippedChips[CHIP_REGENERATION]
            if (getCooldown(CHIP_REGENERATION, getEntity()) == 0 && getTP() >= regenChip._cost && getLife() < getTotalLife()) {
                this.createAttackAction(Action.ACTION_DIRECT, player, -1, CHIP_REGENERATION)
            }
        }

        // FIGHTING RETREAT: Check flee path for damage cells, stop to attack if found
        var hns = fieldMap.findHideAndSeekCell()
        if (hns != null) {
            var hCell = hns['cell']
            if (hCell != player._cellPos) {
                // Check if there's a damage cell on the flee path
                var damageCellOnPath = this.findBestDamageCellOnPath(hCell, player._currMp)

                if (damageCellOnPath != null) {
                    // Stop at damage cell to attack while fleeing
                    debug("[FLEE-ATTACK] Stopping at damage cell " + damageCellOnPath._id + " on flee path (damage=" + damageCellOnPath._totalDamage + ")")
                    this.createMovementAction(Action.MOVEMENT_HNS, damageCellOnPath._id, target)
                } else {
                    // No damage cells on path - flee directly to safe cell
                    debug("[HNS] Executing defensive hide movement to cell " + hCell + " safe=" + hns['safe'] + " danger=" + hns['danger'])
                    this.createMovementAction(Action.MOVEMENT_HNS, hCell, target)
                }
            } else {
                debug("[HNS] Current cell already chosen as best hide cell (danger=" + hns['danger'] + ")")
            }
        } else {
            var usedMp = moveAwayFrom(target._id)
            debug("moveAwayFrom used MP: " + usedMp)
        }

        // EXECUTE MOVEMENT IMMEDIATELY so we can validate weapons from actual position
        this.executeAndFlushActions()

        // After moving, refresh
        player.updateEntity()
        fieldMap.updateMapEntities()

        // Try to shoot any available weapon from the new cell
        var playerPos = player._cellPos
        var playerTP = player._currTp

        if (mapContainsKey(fieldMap.damageMap, playerPos)) {
            var cell = fieldMap.damageMap[playerPos]

            // Find best weapon that can ACTUALLY hit from current position
            // (damage map may have stale weapon info if enemy moved)
            var bestWeapon = null
            var bestDamage = -1
            var distToTarget = getCellDistance(playerPos, target._cellPos)

            if (distToTarget != null && count(cell._weaponsList) > 0) {
                for (var wIdx = 0; wIdx < count(cell._weaponsList); wIdx++) {
                    var weapon = cell._weaponsList[wIdx]
                    // Check if weapon can hit at current distance
                    if (distToTarget >= weapon._minRange && distToTarget <= weapon._maxRange) {
                        // Check line of sight
                        if (lineOfSight(playerPos, target._cellPos)) {
                            var bd = arsenal.getDamageBreakdown(player._strength, player._magic, player._wisdom, weapon._id)
                            var dmg = bd['total']
                            if (dmg > bestDamage) {
                                bestDamage = dmg
                                bestWeapon = weapon
                            }
                        }
                    }
                }
            }

            if (bestWeapon != null) {
                var needSwap = (getWeapon() != bestWeapon._id)

                if (needSwap && playerTP >= 1) {
                    this.createAttackAction(Action.ACTION_WEAPON_SWAP, target, bestWeapon._id, -1)
                    playerTP -= 1
                }

                var useCount = bestWeapon._maxUse
                while (playerTP >= bestWeapon._cost && useCount > 0) {
                    this.createAttackAction(Action.ACTION_DIRECT, target, bestWeapon._id, -1)
                    playerTP -= bestWeapon._cost
                    useCount -= 1
                }
            }
        }

        // Continue fleeing to original safe cell if we stopped at intermediate damage cell
        // and still have MP remaining
        if (hns != null) {
            var finalSafeCell = hns['cell']
            var currentPos = player._cellPos
            var remainingMP = player._currMp

            // If we're not at the final safe cell yet and have MP remaining
            if (currentPos != finalSafeCell && remainingMP > 0) {
                var distToSafe = getPathLength(currentPos, finalSafeCell)
                if (distToSafe != null && distToSafe > 0) {
                    debug("[FLEE-CONTINUE] Continuing flee to safe cell " + finalSafeCell + " (dist=" + distToSafe + ", MP=" + remainingMP + ")")
                    this.createMovementAction(Action.MOVEMENT_HNS, finalSafeCell, target)
                }
            }
        }
    }

    createAndExecuteDefensiveScenario(target) {
        arrayClear(this._actions)
        this.createDefensiveScenario(target, -1)
        this.executeScenario()
    }

    // If below 35% HP, use defensive; else offensive
    // Check if should enter emergency/defensive mode
    // Override in strategies for custom logic
    shouldEnterEmergencyMode() {
        var hpPercent = (getLife() * 100) / getTotalLife()

        // Default: HP < 35% AND regeneration available
        if (hpPercent < 35) {
            if (mapContainsKey(arsenal.playerEquippedChips, CHIP_REGENERATION)) {
                var regenCooldown = getCooldown(CHIP_REGENERATION, getEntity())
                if (regenCooldown == 0) {
                    debug("[EMERGENCY] Entering emergency mode (HP=" + floor(hpPercent) + "% regeneration available)")
                    return true
                }
            }
            debug("[EMERGENCY] Low HP (" + floor(hpPercent) + "%) but no regeneration available")
        }

        return false
    }

    // Virtual method - strategies can override for custom emergency behavior
    // Default: flee with regeneration
    createEmergencyScenario(target, targetHitCell) {
        debug("[EMERGENCY] Using default emergency scenario (regeneration + flee)")
        this.createDefensiveScenario(target, targetHitCell)
    }

    createAndExecuteScenario(target, targetHitCell) {
        arrayClear(this._actions)

        // Check for emergency mode first
        if (this.shouldEnterEmergencyMode()) {
            this.createEmergencyScenario(target, targetHitCell)
        } else {
            this.createOffensiveScenario(target, targetHitCell)
        }
        this.executeScenario()
    }

    executeScenario() {
        for (var a in this._actions) {
            if (a.type == Action.MOVEMENT_APPROACH || a.type == Action.MOVEMENT_OFFENSIVE || a.type == Action.MOVEMENT_DEFENSIVE || a.type == Action.MOVEMENT_OTKO || a.type == Action.MOVEMENT_DOT_OFFENSIVE || a.type == Action.MOVEMENT_DEBUFF) {
                debug("Executing movement (toward) action to cell " + a.targetCell)
                var posBefore = getCell()
                moveTowardCell(a.targetCell)
                var posAfter = getCell()
                debug("Movement result: " + posBefore + " -> " + posAfter + " (target was " + a.targetCell + ")")
            }
            else if (a.type == Action.MOVEMENT_FLEE) {
                debug("Executing flee/kite movement away from entity " + a.targetEntity._id)
                moveAwayFrom(a.targetEntity._id)
            }
            else if (a.type == Action.MOVEMENT_HNS) {
                debug("Executing Hide&Seek movement to cell " + a.targetCell)
                moveTowardCell(a.targetCell)
            }
            else if (a.type == Action.ACTION_WEAPON_SWAP) {
                debug("Swapping to weapon " + getWeaponName(a.weaponId))
                setWeapon(a.weaponId)
                this._currentWeaponId = a.weaponId  // Track weapon state
            }
            else if (a.type == Action.ACTION_DIRECT || a.type == Action.ACTION_DOT || a.type == Action.ACTION_DEBUFF) {
                var currentPos = getCell()
                var currentWeap = getWeapon()
                var targetPos = a.targetCell
                var dist = getCellDistance(currentPos, targetPos)

                // Debug action contents
                debug("Executing attack action: type=" + a.type + " weaponId=" + a.weaponId + " chip=" + a.chip + " targetCell=" + a.targetCell)

                if (a.chip != -1) {
                    debug("Using chip " + getChipName(a.chip) + " on cell " + a.targetCell + " (TP=" + getTP() + ")")
                    useChipOnCell(a.chip, a.targetCell)
                }
                else {
                    debug("Using weapon " + getWeaponName(a.weaponId) + " on cell " + a.targetCell + " (pos=" + currentPos + " dist=" + dist + " TP=" + getTP() + ")")
                    useWeaponOnCell(a.targetCell)
                }
            }
            else if (a.type == Action.ACTION_BUFF) {
                debug("Executing buff/utility chip " + getChipName(a.chip) + " on entity " + getName(a.targetEntity._id))
                if (a.chip != -1) {
                    useChip(a.chip, a.targetEntity._id)
                }
            }
            else if (a.type == Action.ACTION_TELEPORT) {
                debug("Executing teleportation to cell " + a.targetCell)
                if (a.chip == CHIP_TELEPORTATION) {
                    useChip(a.chip, a.targetCell)
                }
            }
        }
    }

    // Execute all queued actions immediately and update game state
    // Useful when we need to know actual position/resources before continuing scenario planning
    executeAndFlushActions() {
        this.executeScenario()
        arrayClear(this._actions)
        player.updateEntity()
    }
}
