// ================================
// BOSS FIGHT STRATEGY - Grail & Crystal Puzzle Solver
// ================================
// Hybrid greedy approach: strategic INVERSION + iterative GRAPPLE/BOXING_GLOVE

include('../game_entity.lk')
include('../field_map_core.lk')

// ================================
// BOSS FIGHT DETECTION (Global Function)
// ================================

function detectBossFight() {
    var entities = getAliveEnemies()
    for (var eid in entities) {
        var entityType = getName(eid)
        if (entityType == "graal") {
            return true
        }
    }
    return false
}

class BossFightStrategy {

    // State
    _grail = null
    _crystals = [:]  // Map: crystal_id -> {entity: Enemy, color: string, goalAxis: string}
    _myAssignedCrystal = null
    _usedInversion = false
    _fieldMap = null

    // Crystal color to goal axis mapping
    // Red = South (Y > grail.Y, same X)
    // Blue = East (X > grail.X, same Y)
    // Yellow = West (X < grail.X, same Y)
    // Green = North (Y < grail.Y, same X)

    // ================================
    // CONSTRUCTOR
    // ================================

    constructor() {
        debug("[BOSS] Initializing BossFightStrategy")
        this._fieldMap = new FieldMap()
    }

    // ================================
    // INTERFACE METHODS
    // ================================

    shouldBuildDamageMap() {
        return false;  // Boss fights don't need damage map
    }

    createAndExecuteScenario(target, targetHitCell) {
        // Boss fights use playTurn() instead
        debug("[BOSS] createAndExecuteScenario called")
        this.playTurn()
        debug("[BOSS] playTurn completed")
    }

    // ================================
    // MAIN ENTRY POINT
    // ================================

    playTurn() {
        debug("[BOSS] playTurn START")
        debug("\n[BOSS] ========== TURN " + getTurn() + " ==========")
        debug("[BOSS] MP: " + getMP() + ", TP: " + getTP())

        // 1. Detect grail and crystals
        this.detectGrailAndCrystals()
        debug("[BOSS] Detected grail: " + (this._grail != null))

        var crystalCount = 0
        for (var c in this._crystals) crystalCount++
        debug("[BOSS] Crystal count: " + crystalCount)

        if (this._grail == null) {
            debug("[BOSS] ⚠️ No grail detected, passing turn")
            return
        }

        // 2. Assign crystal to this entity
        this.assignCrystal()
        debug("[BOSS] Assigned crystal: " + (this._myAssignedCrystal != null))

        if (this._myAssignedCrystal == null) {
            debug("[BOSS] ⚠️ No crystal assigned, passing turn")
            return
        }

        // 3. Check if crystal is already solved
        var solved = this.isCrystalSolved(this._myAssignedCrystal)
        debug("[BOSS] Crystal solved: " + solved)

        if (solved) {
            debug("[BOSS] ✅ My crystal is solved, passing turn")
            return
        }

        // 4. Decide and execute action
        debug("[BOSS] Executing action...")
        this.decideAndExecuteAction()

        debug("[BOSS] ========== END TURN ==========\n")
    }

    // ================================
    // DETECTION & ASSIGNMENT
    // ================================

    detectGrailAndCrystals() {
        // Scan all cells to find grail and crystals
        for (var cellId = 0; cellId < 613; cellId++) {
            if (!isEntity(cellId)) continue

            var eid = getEntityOnCell(cellId)
            var entityType = getName(eid)

            if (entityType == "graal") {
                this._grail = {
                    id: eid,
                    cell: cellId,
                    x: getCellX(cellId),
                    y: getCellY(cellId)
                }
                debug("[BOSS] Grail at (" + this._grail.x + ", " + this._grail.y + ")")
            }
            else if (entityType == "red_crystal" || entityType == "blue_crystal" ||
                     entityType == "yellow_crystal" || entityType == "green_crystal") {
                var color = substring(entityType, 0, indexOf(entityType, "_"))
                var goalAxis = this.getGoalAxis(color)

                this._crystals[eid] = {
                    id: eid,
                    color: color,
                    goalAxis: goalAxis,
                    cell: cellId,
                    x: getCellX(cellId),
                    y: getCellY(cellId)
                }

                debug("[BOSS] " + color + " crystal at (" + this._crystals[eid].x + ", " + this._crystals[eid].y + ") [goal: " + goalAxis + "]")
            }
        }
    }

    assignCrystal() {
        // Get all ally entity IDs and sort them
        var myID = getEntity()
        var allAllies = []
        push(allAllies, myID)
        var allies = getAliveAllies()
        for (var aid in allies) {
            push(allAllies, aid)
        }

        // Sort entity IDs to get deterministic order
        sort(allAllies)

        // Find my index
        var myIndex = -1
        for (var i = 0; i < count(allAllies); i++) {
            if (allAllies[i] == myID) {
                myIndex = i
                break
            }
        }

        var crystalCount = 0
        for (var c in this._crystals) crystalCount++

        if (myIndex < 0 || myIndex >= crystalCount) {
            debug("[BOSS] ⚠️ Invalid entity index: " + myIndex + " (total allies: " + count(allAllies) + ", crystals: " + crystalCount + ")")
            return
        }

        // Assign crystal by index: 0=red, 1=blue, 2=yellow, 3=green
        var colorOrder = ["red", "blue", "yellow", "green"]
        var targetColor = colorOrder[myIndex]

        debug("[BOSS] Looking for " + targetColor + " crystal (myIndex=" + myIndex + ")")

        // Find crystal with matching color (iterate over values, not keys)
        for (var crystal in this._crystals) {
            debug("[BOSS]   Checking crystal color=" + crystal.color + " vs target=" + targetColor)

            if (crystal != null && crystal.color == targetColor) {
                this._myAssignedCrystal = crystal
                debug("[BOSS] ✅ Assigned to " + targetColor + " crystal (ID=" + crystal.id + ")")
                return
            }
        }

        debug("[BOSS] ⚠️ Could not find " + targetColor + " crystal")
    }

    getGoalAxis(color) {
        if (color == "red") return "south";
        if (color == "blue") return "east";
        if (color == "yellow") return "west";
        if (color == "green") return "north";
        return "unknown";
    }

    // ================================
    // CRYSTAL STATE CHECKS
    // ================================

    isCrystalSolved(crystal) {
        return this.isOnGoalAxis(crystal) && this.hasLOSToGrail(crystal);
    }

    isOnGoalAxis(crystal) {
        if (this._grail == null) return false;

        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north") {
            return cx == gx && cy < gy;
        } else if (axis == "south") {
            return cx == gx && cy > gy;
        } else if (axis == "east") {
            return cy == gy && cx > gx;
        } else if (axis == "west") {
            return cy == gy && cx < gx;
        }

        return false;
    }

    hasLOSToGrail(crystal) {
        if (this._grail == null) return false;
        return lineOfSight(crystal.cell, this._grail.cell);
    }

    getDistanceToAxis(crystal) {
        if (this._grail == null) return 999;

        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        if (axis == "north" || axis == "south") {
            return abs(cx - gx);  // Distance to vertical axis
        } else {
            return abs(cy - gy);  // Distance to horizontal axis
        }
    }

    // ================================
    // DECISION TREE
    // ================================

    decideAndExecuteAction() {
        var crystal = this._myAssignedCrystal;
        var distToAxis = this.getDistanceToAxis(crystal);

        debug("[BOSS] Crystal distance to axis: " + distToAxis);
        debug("[BOSS] Used INVERSION: " + this._usedInversion);
        debug("[BOSS] Current TP: " + getTP() + ", MP: " + getMP());

        // PHASE 1: Use INVERSION if far from axis (> 8 cells) and haven't used it yet
        if (distToAxis > 8 && !this._usedInversion && getTP() >= 4) {
            debug("[BOSS] Phase 1: Using INVERSION (distance > 8)");
            this.executeInversion(crystal);
            return;
        }

        // PHASE 2: Use GRAPPLE or BOXING_GLOVE to slide crystal toward goal
        debug("[BOSS] Phase 2: Using GRAPPLE/BOXING_GLOVE to slide crystal");
        this.executeSlideTowardGoal(crystal);
    }

    // ================================
    // ACTION EXECUTION
    // ================================

    executeInversion(crystal) {
        var playerCell = getCell();
        var dist = getCellDistance(playerCell, crystal.cell);

        debug("[BOSS] Distance to crystal: " + dist);

        // Walk closer if out of INVERSION range (1-14)
        if (dist > 14) {
            debug("[BOSS] Walking toward crystal (dist=" + dist + ")");
            var moved = moveTowardCell(crystal.cell, getMP());
            debug("[BOSS] Moved " + moved + " cells");

            // Check if now in range
            playerCell = getCell();
            dist = getCellDistance(playerCell, crystal.cell);

            if (dist > 14) {
                debug("[BOSS] Still out of range after moving, will retry next turn");
                return;
            }
        }

        // Use INVERSION to swap positions
        if (getTP() >= 4 && lineOfSight(playerCell, crystal.cell)) {
            debug("[BOSS] ✅ Using INVERSION on crystal at cell " + crystal.cell);
            var result = useChipOnCell(CHIP_INVERSION, crystal.cell);

            if (result == USE_SUCCESS) {
                this._usedInversion = true;
                debug("[BOSS] ✅ INVERSION successful!");
            } else {
                debug("[BOSS] ⚠️ INVERSION failed: " + result);
            }
        } else {
            debug("[BOSS] ⚠️ Cannot use INVERSION: TP=" + getTP() + ", LOS=" + lineOfSight(playerCell, crystal.cell));
        }
    }

    executeSlideTowardGoal(crystal) {
        var axis = crystal.goalAxis;

        // Determine which direction to slide crystal
        var direction = this.getDirectionToSlide(crystal);

        if (direction == null) {
            debug("[BOSS] ⚠️ No valid slide direction found");
            return;
        }

        debug("[BOSS] Slide direction: " + direction);

        // Decide whether to use GRAPPLE or BOXING_GLOVE
        if (direction == "pull") {
            this.executeGrapple(crystal);
        } else {
            this.executeBoxingGlove(crystal);
        }
    }

    getDirectionToSlide(crystal) {
        var axis = crystal.goalAxis;
        var cx = crystal.x;
        var cy = crystal.y;
        var gx = this._grail.x;
        var gy = this._grail.y;

        // Determine if we need to pull (move toward grail) or push (move away)
        if (axis == "north" || axis == "south") {
            // Need to move on vertical axis (change X)
            if (cx < gx) return "pull";  // Crystal is west of axis, pull it east
            if (cx > gx) return "push";  // Crystal is east of axis, push it west

            // Already on axis, check Y position
            if (axis == "north" && cy >= gy) return "push";  // Too far south, push north
            if (axis == "south" && cy <= gy) return "pull";  // Too far north, pull south
        } else {
            // Need to move on horizontal axis (change Y)
            if (cy < gy) return "pull";  // Crystal is north of axis, pull it south
            if (cy > gy) return "push";  // Crystal is south of axis, push it north

            // Already on axis, check X position
            if (axis == "east" && cx <= gx) return "pull";  // Too far west, pull east
            if (axis == "west" && cx >= gx) return "push";  // Too far east, push west
        }

        return null;
    }

    executeGrapple(crystal) {
        var playerCell = getCell();
        var px = getCellX(playerCell);
        var py = getCellY(playerCell);

        // Calculate destination cell (where we want to pull crystal TO)
        // Destination is 1 cell toward player from crystal
        var dx = crystal.x;
        var dy = crystal.y;

        if (crystal.x < px) dx++;
        else if (crystal.x > px) dx--;

        if (crystal.y < py) dy++;
        else if (crystal.y > py) dy--;

        var destCell = getCellFromXY(dx, dy);

        if (destCell == null || !(!isObstacle(destCell) && !isEntity(destCell))) {
            debug("[BOSS] ⚠️ Destination cell blocked or invalid: (" + dx + ", " + dy + ")");
            return;
        }

        // Check if we need to reposition
        var dist = getCellDistance(playerCell, crystal.cell);
        var onSameLine = isOnSameLine(playerCell, crystal.cell);

        debug("[BOSS] GRAPPLE check: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());

        // If not in range (1-8) or not on line, walk to get on same line
        if (dist < 1 || dist > 8 || !onSameLine) {
            debug("[BOSS] Need to position for GRAPPLE");

            // Get on horizontal or vertical line with crystal
            var cx = crystal.x;
            var cy = crystal.y;

            // Try horizontal line first (same Y as crystal)
            var targetCell = getCellFromXY(cx - 4, cy);
            if (targetCell == null || isObstacle(targetCell)) {
                // Try vertical line (same X as crystal)
                targetCell = getCellFromXY(cx, cy - 4);
            }

            if (targetCell != null && !isObstacle(targetCell)) {
                var moved = moveTowardCell(targetCell, getMP());
                debug("[BOSS] Moved " + moved + " cells to align with crystal");

                // Recheck after moving
                playerCell = getCell();
                dist = getCellDistance(playerCell, crystal.cell);
                onSameLine = isOnSameLine(playerCell, crystal.cell);
            }
        }

        // Use GRAPPLE if in range
        if (dist >= 1 && dist <= 8 && onSameLine && getTP() >= 4) {
            debug("[BOSS] ✅ Using GRAPPLE to cell " + destCell);
            var result = useChipOnCell(CHIP_GRAPPLE, destCell);

            if (result == USE_SUCCESS) {
                debug("[BOSS] ✅ GRAPPLE successful!");
            } else {
                debug("[BOSS] ⚠️ GRAPPLE failed: " + result);
            }
        } else {
            debug("[BOSS] ⚠️ Cannot use GRAPPLE: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());
        }
    }

    executeBoxingGlove(crystal) {
        var playerCell = getCell();
        var px = getCellX(playerCell);
        var py = getCellY(playerCell);

        // Calculate destination cell (where we want to push crystal TO)
        // Destination is 1 cell away from player, beyond crystal
        var dx = crystal.x;
        var dy = crystal.y;

        if (crystal.x < px) dx--;
        else if (crystal.x > px) dx++;

        if (crystal.y < py) dy--;
        else if (crystal.y > py) dy++;

        var destCell = getCellFromXY(dx, dy);

        if (destCell == null || !(!isObstacle(destCell) && !isEntity(destCell))) {
            debug("[BOSS] ⚠️ Destination cell blocked or invalid: (" + dx + ", " + dy + ")");
            return;
        }

        // Check if we need to reposition
        var dist = getCellDistance(playerCell, crystal.cell);
        var onSameLine = isOnSameLine(playerCell, crystal.cell);

        debug("[BOSS] BOXING_GLOVE check: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());

        // If not in range (2-8) or not on line, walk to get on same line
        if (dist < 2 || dist > 8 || !onSameLine) {
            debug("[BOSS] Need to position for BOXING_GLOVE");

            // Get on horizontal or vertical line with crystal
            var cx = crystal.x;
            var cy = crystal.y;

            // Try horizontal line first (same Y as crystal)
            var targetCell = getCellFromXY(cx + 4, cy);
            if (targetCell == null || isObstacle(targetCell)) {
                // Try vertical line (same X as crystal)
                targetCell = getCellFromXY(cx, cy + 4);
            }

            if (targetCell != null && !isObstacle(targetCell)) {
                var moved = moveTowardCell(targetCell, getMP());
                debug("[BOSS] Moved " + moved + " cells to align with crystal");

                // Recheck after moving
                playerCell = getCell();
                dist = getCellDistance(playerCell, crystal.cell);
                onSameLine = isOnSameLine(playerCell, crystal.cell);
            }
        }

        // Use BOXING_GLOVE if in range
        if (dist >= 2 && dist <= 8 && onSameLine && getTP() >= 3) {
            debug("[BOSS] ✅ Using BOXING_GLOVE to cell " + destCell);
            var result = useChipOnCell(CHIP_BOXING_GLOVE, destCell);

            if (result == USE_SUCCESS) {
                debug("[BOSS] ✅ BOXING_GLOVE successful!");
            } else {
                debug("[BOSS] ⚠️ BOXING_GLOVE failed: " + result);
            }
        } else {
            debug("[BOSS] ⚠️ Cannot use BOXING_GLOVE: dist=" + dist + ", onLine=" + onSameLine + ", TP=" + getTP());
        }
    }
}
