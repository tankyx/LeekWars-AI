class EffectsInfos {
    _minEffectAmount = 0
    _maxEffectAmount = 0
    _effectDuration = 0
}

class Item {
    _id = -1
    _minRange = 0
    _maxRange = 0
    _cost = 0
    _maxUse = 0
    _launchType = -1
    _aoeType = -1
    _effects = [:]

    constructor(id, minRange, maxRange, effects, cost, maxUse, launchType, aoeType) {
        _id = id
        _minRange = minRange
        _maxRange = maxRange
        _cost = cost
        _maxUse = maxUse
        _launchType = launchType
        _aoeType = aoeType

        parseAllEffects(effects)
    }

    parseAllEffects(effects) {
        for (var e in effects) {
            var effectsInfos = new EffectsInfos()
            effectsInfos._minEffectAmount += e[1]
            effectsInfos._maxEffectAmount += e[2]
            effectsInfos._effectDuration += e[3]

            mapPut(this._effects, e[0], effectsInfos)
        }
    }
}

class Weapon extends Item {
    constructor(id, minRange, maxRange, effects, cost, maxUse, launchType, aoeType) {
        super(id, minRange, maxRange, effects, cost, maxUse, launchType, aoeType)
    }
}

class Chip extends Item {
    cooldown = -1

    constructor(id, minRange, maxRange, effects, cost, maxUse, launchType, aoeType, cooldown) {
        super(id, minRange, maxRange, effects, cost, maxUse, launchType, aoeType)
        this.cooldown = cooldown
    }
}

class Arsenal {
    constructor() {
        buildAllWeaponsList()
        buildAllChipsList()
        getEquippedWeaponsSubMap()
        getEquippedChipsSubMap()
    }

    weaponsList = [:]
    chipsList = [:]
    playerEquippedWeapons = [:]
    playerEquippedChips = [:]

    buildAllWeaponsList() {
        var allWeapons = getAllWeapons()

        for (var w in allWeapons) {
            mapPut(weaponsList, w, new Weapon(
                w,
                getWeaponMinRange(w),
                getWeaponMaxRange(w),
                getWeaponEffects(w),
                getWeaponCost(w),
                getWeaponMaxUses(w),
                getWeaponLaunchType(w),
                getWeaponArea(w)
            ));
        }
    }

    buildAllChipsList() {
        var allChips = getAllChips()

        for (var c in allChips) {
            mapPut(chipsList, c, new Chip(
                c,
                getChipMinRange(c),
                getChipMaxRange(c),
                getChipEffects(c),
                getChipCost(c),
                getChipMaxUses(c),
                getChipLaunchType(c),
                getChipArea(c),
                getCooldown(c, getEntity())
            ));
        }
    }

    getEquippedWeaponsSubMap() {
        var equippedWeapons = getWeapons()

        for (var w in equippedWeapons) {
            mapPut(playerEquippedWeapons, w, weaponsList[w])
        }
    }

    getEquippedChipsSubMap() {
        var equippedChips = getChips()

        for (var c in equippedChips) {
            mapPut(playerEquippedChips, c, chipsList[c])
        }
    }

    // Helper: compute AoE damage modifier based on distance from impact center
    // Returns percentage multiplier (0.0 to 1.0) using formula: max(0, 1 - 0.2 * distance)
    computeAoEModifier(centerCell, targetCell, aoeType) {
        // AREA_POINT (0) has no AoE - only center cell takes damage
        if (aoeType == AREA_POINT) {
            return (centerCell == targetCell) ? 1.0 : 0.0
        }

        // For all AoE types, center cell always takes 100% damage
        if (centerCell == targetCell) return 1.0

        var dist = getCellDistance(centerCell, targetCell)
        if (dist == null) return 0.0

        // Apply linear falloff: percentage = max(0, 1 - 0.2 * distance)
        var percentage = 1.0 - 0.2 * dist
        if (percentage < 0) percentage = 0

        return percentage
    }

    // Helper: compute base damage (without lifesteal) from a map of effects
    // Optional aoeModifier parameter applies AoE falloff (default 1.0 = full damage)
    // Nova damage requires science stat (sci parameter)
    computeEffectsBaseDamage(effectsMap, str, mag, sci, aoeModifier = 1.0) {
        var total = 0
        for (var e in mapKeys(effectsMap)) {
            var info = effectsMap[e]
            if (e == EFFECT_DAMAGE) {
                var avg = (info._minEffectAmount + info._maxEffectAmount) / 2
                total += avg * (1 + (str / 100)) * aoeModifier
            } else if (e == EFFECT_POISON) {
                var avg2 = (info._minEffectAmount + info._maxEffectAmount) / 2
                var totalOverTime = avg2 * info._effectDuration
                total += totalOverTime * (1 + (mag / 100)) * aoeModifier
            } else if (e == EFFECT_NOVA_DAMAGE) {
                // Nova damage scales with both STR and SCI (additive)
                var avgNova = (info._minEffectAmount + info._maxEffectAmount) / 2
                total += avgNova * (1 + (str + sci) / 100) * aoeModifier
            }
        }
        return total
    }

    // Provide separate breakdown for direct (immediate) vs dot (poison) vs nova damage
    // directPerUse: average base damage (EFFECT_DAMAGE) scaled by STR
    // dotPerApply: total poison damage over duration (EFFECT_POISON) scaled by MAG
    // nova: nova damage (EFFECT_NOVA_DAMAGE) scaled by STR+SCI, bypasses shields, reduces max HP
    // Optional parameters for AoE: centerCell (impact point), targetCell (cell taking damage)
    getDamageBreakdown(str, mag, wis, sci, itemID, centerCell = -1, targetCell = -1) {
        // Support both full inventory lists and equipped subsets for weapons & chips.
        var isWeapon = mapContainsKey(this.playerEquippedWeapons, itemID)
        // A chip can reside either in the global chipsList or only in playerEquippedChips.
        var chipInFull = mapContainsKey(this.chipsList, itemID)
        var chipInEquipped = mapContainsKey(this.playerEquippedChips, itemID)
        var isChip = !isWeapon && (chipInFull || chipInEquipped)
        if (!isWeapon && !isChip) return ['direct': 0, 'dot': 0, 'nova': 0, 'total': 0, 'min': 0, 'max': 0]
        var item = isWeapon ? this.playerEquippedWeapons[itemID] : (chipInFull ? this.chipsList[itemID] : this.playerEquippedChips[itemID])

        // Calculate AoE modifier if both cells are provided
        var aoeModifier = 1.0
        if (centerCell != -1 && targetCell != -1) {
            aoeModifier = this.computeAoEModifier(centerCell, targetCell, item._aoeType)
        }

        var direct = 0
        var dot = 0
        var nova = 0
        var minDmg = 0
        var maxDmg = 0

        for (var e in mapKeys(item._effects)) {
            var info = item._effects[e]
            if (e == EFFECT_DAMAGE) {
                var avg = (info._minEffectAmount + info._maxEffectAmount) / 2
                direct += avg * (1 + (str / 100)) * aoeModifier

                // Calculate min/max for probability calculations
                minDmg += info._minEffectAmount * (1 + (str / 100)) * aoeModifier
                maxDmg += info._maxEffectAmount * (1 + (str / 100)) * aoeModifier
            } else if (e == EFFECT_POISON) {
                var avg2 = (info._minEffectAmount + info._maxEffectAmount) / 2
                var totalOverTime = avg2 * info._effectDuration
                dot += totalOverTime * (1 + (mag / 100)) * aoeModifier

                // Poison adds to min/max as well
                var minPoison = info._minEffectAmount * info._effectDuration * (1 + (mag / 100)) * aoeModifier
                var maxPoison = info._maxEffectAmount * info._effectDuration * (1 + (mag / 100)) * aoeModifier
                minDmg += minPoison
                maxDmg += maxPoison
            } else if (e == EFFECT_NOVA_DAMAGE) {
                // Nova damage scales with both STR and SCI (additive)
                var avgNova = (info._minEffectAmount + info._maxEffectAmount) / 2
                nova += avgNova * (1 + (str + sci) / 100) * aoeModifier

                // Nova adds to min/max as well
                var minNova = info._minEffectAmount * (1 + (str + sci) / 100) * aoeModifier
                var maxNova = info._maxEffectAmount * (1 + (str + sci) / 100) * aoeModifier
                minDmg += minNova
                maxDmg += maxNova
            }
        }
        return ['direct': direct, 'dot': dot, 'nova': nova, 'total': direct + dot + nova, 'min': minDmg, 'max': maxDmg]
    }

    // Return an array of poison chip objects sorted by descending dot damage
    getPoisonChipsSorted(str, mag, wis, sci) {
        var arr = []
        for (var cid in mapKeys(this.playerEquippedChips)) {
            var chip = this.playerEquippedChips[cid]
            if (!mapContainsKey(chip._effects, EFFECT_POISON)) continue
            var bd = this.getDamageBreakdown(str, mag, wis, sci, cid)
            push(arr, ['chip': chip, 'dot': bd['dot'], 'direct': bd['direct'], 'nova': bd['nova'], 'total': bd['total']])
        }
        // Simple selection sort (LeekScript lacks higher-order sort)
        var sorted = []
        while (count(arr) > 0) {
            var bestIdx = 0
            var bestDot = arr[0]['dot']
            for (var i = 1; i < count(arr); i++) {
                if (arr[i]['dot'] > bestDot) {
                    bestDot = arr[i]['dot']
                    bestIdx = i
                }
            }
            push(sorted, arr[bestIdx]['chip'])
            remove(arr, bestIdx)
        }
        return sorted
    }

    // Return DoT-capable weapons sorted by descending dot component; include pure direct if no dot weapons
    getDotWeaponsSorted(str, mag, wis, sci) {
        var arr = []
        for (var wid in mapKeys(this.playerEquippedWeapons)) {
            var w = this.playerEquippedWeapons[wid]
            var bd = this.getDamageBreakdown(str, mag, wis, sci, wid)
            if (bd['dot'] > 0 || bd['nova'] > 0) {
                push(arr, ['weapon': w, 'dot': bd['dot'], 'nova': bd['nova'], 'direct': bd['direct'], 'total': bd['total']])
            }
        }
        if (count(arr) == 0) {
            // fallback: use any weapons (direct focus)
            for (var wid2 in mapKeys(this.playerEquippedWeapons)) {
                var w2 = this.playerEquippedWeapons[wid2]
                var bd2 = this.getDamageBreakdown(str, mag, wis, sci, wid2)
                push(arr, ['weapon': w2, 'dot': bd2['dot'], 'nova': bd2['nova'], 'direct': bd2['direct'], 'total': bd2['total']])
            }
        }
        // selection sort by dot then total
        var sorted = []
        while (count(arr) > 0) {
            var bestIdx = 0
            var bestDot = arr[0]['dot']
            var bestTot = arr[0]['total']
            for (var i = 1; i < count(arr); i++) {
                if (arr[i]['dot'] > bestDot || (arr[i]['dot'] == bestDot && arr[i]['total'] > bestTot)) {
                    bestDot = arr[i]['dot']
                    bestTot = arr[i]['total']
                    bestIdx = i
                }
            }
            push(sorted, arr[bestIdx]['weapon'])
            remove(arr, bestIdx)
        }
        return sorted
    }

    // Calculate net damage against target accounting for shields
    // Poison/DoT and Nova damage bypass shields entirely; direct damage is reduced by relative/absolute shields
    getNetDamageAgainstTarget(str, mag, wis, sci, itemID, targetEntity) {
        var bd = this.getDamageBreakdown(str, mag, wis, sci, itemID)
        var directDmg = bd['direct']
        var dotDmg = bd['dot']
        var novaDmg = bd['nova']

        // Apply shields only to direct damage
        var relShield = targetEntity._relShield / 100  // Convert percentage to decimal
        var absShield = targetEntity._absShield

        var netDirect = directDmg * (1 - relShield) - absShield
        if (netDirect < 0) netDirect = 0  // Can't heal enemy

        // Poison and Nova bypass shields completely (Nova reduces max HP)
        return netDirect + dotDmg + novaDmg
    }

    // Calculate total damage to all enemies in AoE with falloff and shield penetration
    // shooterCell: where the player is shooting from
    // aimCell: where the AoE is centered (may be enemy position or offset)
    // itemId: weapon or chip ID
    // enemies: array of Enemy objects to check
    // Returns: {'total': totalDamage, 'enemies': hitEnemies[], 'breakdown': {enemyId: damage}}
    calculateMultiEnemyDamage(shooterCell, aimCell, itemId, enemies) {
        // Get item from equipped weapons or chips
        var item = null
        if (mapContainsKey(this.playerEquippedWeapons, itemId)) {
            item = this.playerEquippedWeapons[itemId]
        } else if (mapContainsKey(this.playerEquippedChips, itemId)) {
            item = this.playerEquippedChips[itemId]
        }

        if (item == null) return ['total': 0, 'enemies': [], 'breakdown': [:]]

        var totalDamage = 0
        var hitEnemies = []
        var breakdown = [:]

        for (var e in enemies) {
            if (isDead(e._id)) continue

            // Calculate AoE falloff from aim point to enemy position
            var aoeModifier = this.computeAoEModifier(aimCell, e._cellPos, item._aoeType)

            if (aoeModifier > 0) {
                // Get base damage breakdown
                var bd = this.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, itemId, aimCell, e._cellPos)

                // Apply shields/vulnerability to direct damage only
                var directAfterShield = bd['direct'] * aoeModifier
                if (bd['direct'] > 0 && (e._relShield > 0 || e._absShield > 0)) {
                    directAfterShield = directAfterShield * (1 - e._relShield / 100) - e._absShield
                    if (directAfterShield < 0) directAfterShield = 0
                }

                // Poison/DoT and Nova bypass shields completely
                var dotDamage = bd['dot'] * aoeModifier
                var novaDamage = bd['nova'] * aoeModifier

                var netDmg = directAfterShield + dotDamage + novaDamage

                totalDamage += netDmg
                push(hitEnemies, e)
                mapPut(breakdown, e._id, netDmg)
            }
        }

        return ['total': totalDamage, 'enemies': hitEnemies, 'breakdown': breakdown]
    }

    getHighestDamageWeapon() {
        var highestDmg = -1
        var highestDmgWeapon = null

        for (var w in mapKeys(this.playerEquippedWeapons)) {
            var bd = this.getDamageBreakdown(player._strength, player._magic, player._wisdom, player._science, w)
            var dmg = bd['total']
            if (dmg > highestDmg) {
                highestDmg = dmg
                highestDmgWeapon = w
            }
        }

        return highestDmgWeapon
    }

    // Calculate scaled damage return value based on agility
    // Formula: FinalReturn = BaseReturn * (1 + Agility / 100)
    getDamageReturnValue(agility, chipID) {
        var baseMin = 0
        var baseMax = 0

        if (chipID == CHIP_BRAMBLE) {
            // CHIP_BRAMBLE: 25% base return, 1 turn, 4 TP (aggressive option)
            baseMin = 25
            baseMax = 25
        } else if (chipID == CHIP_MIRROR) {
            // CHIP_MIRROR: 5-6% base return, 3 turns, 5 TP
            baseMin = 5
            baseMax = 6
        } else if (chipID == CHIP_THORN) {
            // CHIP_THORN: 3-4% base return, 2 turns, 4 TP
            baseMin = 3
            baseMax = 4
        } else {
            return 0
        }

        var baseAvg = (baseMin + baseMax) / 2.0
        return baseAvg * (1 + agility / 100.0)
    }

    // Estimate total return damage per turn based on expected enemy DPS
    // This helps prioritize return chip application
    estimateReturnDamagePerTurn(agility, chipID, estimatedEnemyDPS) {
        var returnPct = this.getDamageReturnValue(agility, chipID) / 100.0
        return estimatedEnemyDPS * returnPct
    }

    /**
     * Calculate kill probability for a combo using probability density functions
     * This is much more accurate than simple damage projection
     *
     * @param itemIds - array of weapon/chip IDs to use
     * @param playerStr, playerMag, playerWis, playerSci - player stats
     * @param playerAgility - for critical hit calculation
     * @param targetEntity - enemy entity with HP and shields
     * @return probability (0.0 to 1.0) that combo will kill target
     *
     * NOTE: Requires math/damage_probability.lk to be included
     */
    getKillProbability(itemIds, playerStr, playerMag, playerWis, playerSci, playerAgility, targetEntity) {
        // This method requires the probability distribution system
        // It will be implemented when DamageProbability is available
        // For now, return simple threshold-based estimate

        var totalDmg = 0
        for (var i = 0; i < count(itemIds); i++) {
            var bd = this.getDamageBreakdown(playerStr, playerMag, playerWis, playerSci, itemIds[i])
            var netDmg = this.getNetDamageAgainstTarget(playerStr, playerMag, playerWis, playerSci, itemIds[i], targetEntity)
            totalDmg += netDmg
        }

        // Simple threshold: if average damage > HP, high probability
        // if average damage < HP * 0.7, low probability
        if (totalDmg >= targetEntity._currHealth) {
            return 0.9  // High confidence
        } else if (totalDmg >= targetEntity._currHealth * 0.8) {
            return 0.5  // Medium confidence
        } else {
            return 0.1  // Low confidence
        }
    }

    /**
     * Calculate accurate kill probability using full probability distribution
     * Requires: include("math/damage_probability") in main.lk
     *
     * @return probability (0.0 to 1.0) of kill
     *
     * NOTE: This method will use the advanced probability system if available,
     * otherwise falls back to simple estimate. Comment out math includes in main.lk
     * if operations limit is exceeded.
     */
    getAccurateKillProbability(itemIds, playerStr, playerMag, playerWis, playerSci, playerAgility, targetEntity) {
        // Check if DamageProbability class is available (requires math includes in main.lk)
        // If not available, LeekScript will throw error on class reference

        // Try to use advanced probability calculation
        // Wrap in try-catch to gracefully handle:
        // 1. Missing DamageProbability class (includes commented out)
        // 2. Operations limit exceeded during calculation

        var usedAdvanced = false
        var killProb = 0.0

        // Attempt advanced calculation
        // Note: LeekScript doesn't have try-catch, so we check for class existence differently
        // For now, we'll always try to use it if included

        // Try advanced method - if it fails due to missing class or operations limit,
        // LeekScript will error and we can't catch it gracefully
        // So we'll just use it directly and let it fail if needed

        // Check if we can use advanced by seeing if the class exists
        // In LeekScript, we can't easily check class existence, so we just try to use it

        // Advanced probability calculation using convolution
        killProb = DamageProbabilityGetKillProbability(
            itemIds,
            targetEntity._currHealth,
            playerStr,
            playerMag,
            playerWis,
            targetEntity._absShield,
            targetEntity._relShield,
            playerAgility,
            this
        )

        return killProb
    }

    /**
     * Calculate damage amplification from Neutrino vulnerability stacking
     * Neutrino applies 8% relative vulnerability per hit (cumulative, 2 turn duration)
     *
     * @param stacks - Number of Neutrino hits to apply (1-3)
     * @param futureAttacks - Estimated number of weapon uses that will benefit from vulnerability
     * @param avgWeaponDamage - Average damage per weapon use (before amplification)
     * @return Map with amplification bonus, TP cost, direct damage, net benefit, multiplier
     */
    calculateNeutrinoAmplification(stacks, futureAttacks, avgWeaponDamage) {
        // Neutrino: 8% relative vulnerability per stack, cumulative
        var vulnPercent = stacks * 8
        var multiplier = 1 + (vulnPercent / 100.0)

        // Calculate amplification value = bonus damage across all future attacks
        var baseTotal = futureAttacks * avgWeaponDamage
        var amplifiedTotal = baseTotal * multiplier
        var amplificationValue = amplifiedTotal - baseTotal

        // Neutrino's own costs and damage
        var neutrinoCost = stacks * 4  // 4 TP per use
        var neutrinoDirectDamage = stacks * 27.5  // 25-30 avg damage per use

        // Net benefit = amplification bonus + Neutrino's direct damage
        var netBenefit = amplificationValue + neutrinoDirectDamage

        return [
            'amplification': amplificationValue,
            'tpCost': neutrinoCost,
            'directDamage': neutrinoDirectDamage,
            'netBenefit': netBenefit,
            'multiplier': multiplier
        ]
    }

    /**
     * Get current vulnerability stacks on target based on relative shield
     * Neutrino applies -8% per stack (cumulative)
     *
     * @param targetEntity - Enemy entity to check
     * @return Number of stacks (0-3) currently active
     */
    getVulnerabilityStacks(targetEntity) {
        var relShield = targetEntity._relShield

        // Neutrino applies -8% per stack
        // Note: relShield is negative for vulnerability
        if (relShield <= -20) return 3  // -24% or more (3 stacks)
        if (relShield <= -12) return 2  // -16% to -23% (2 stacks)
        if (relShield <= -4) return 1   // -8% to -15% (1 stack)
        return 0  // No vulnerability
    }
}